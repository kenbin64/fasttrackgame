<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ButterflyFX ‚Äî The Future of Computing is Dimensional</title>
    
    <meta name="description" content="ButterflyFX: Revolutionary software where shapes hold data. Warp drive for your applications.">
    <meta property="og:title" content="ButterflyFX ‚Äî The Future of Computing">
    <meta property="og:description" content="Revolutionary software where shapes hold data. Warp drive for your applications.">
    
    <style>
        :root {
            --bg: #030306;
            --bg-card: rgba(15, 15, 25, 0.95);
            --neon-purple: #8855ff;
            --neon-pink: #ff55aa;
            --neon-cyan: #40ffff;
            --neon-green: #60ff90;
            --neon-orange: #ff8844;
            --text: #ffffff;
            --text-dim: #a0a8c0;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100%;
            overflow: hidden;
        }
        
        /* Background Canvas */
        #bgCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }
        
        /* ============================================
           HERO STATE
           ============================================ */
        .hero-state {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.8s, transform 0.8s;
        }
        
        .hero-state.hidden {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }
        
        .hero-badge {
            display: inline-block;
            padding: 8px 24px;
            background: rgba(136, 85, 255, 0.2);
            border: 1px solid var(--neon-purple);
            border-radius: 25px;
            font-size: 0.85em;
            color: var(--neon-purple);
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .hero-state h1 {
            font-size: clamp(2.5rem, 8vw, 5rem);
            font-weight: 800;
            line-height: 1.1;
            margin-bottom: 25px;
            max-width: 900px;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink), var(--neon-cyan));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .hero-sub {
            font-size: 1.25em;
            color: var(--text-dim);
            max-width: 600px;
            margin-bottom: 40px;
            line-height: 1.6;
        }
        
        .hero-sub strong { color: var(--text); }
        
        .enter-btn {
            padding: 18px 50px;
            font-size: 1.2em;
            font-weight: 700;
            color: white;
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            box-shadow: 0 0 40px rgba(136, 85, 255, 0.4);
        }
        
        .enter-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 60px rgba(136, 85, 255, 0.6);
        }
        
        /* ============================================
           TESSERACT STATE
           ============================================ */
        .tesseract-state {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s;
        }
        
        .tesseract-state.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* Tesseract Canvas */
        #tesseractCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            cursor: grab;
        }
        
        #tesseractCanvas.dragging { cursor: grabbing; }
        
        /* Back button */
        .back-btn {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 100;
            padding: 12px 24px;
            background: rgba(18, 18, 28, 0.9);
            border: 1px solid rgba(136, 85, 255, 0.4);
            border-radius: 25px;
            color: var(--text);
            font-size: 0.9em;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
        }
        
        .back-btn.visible { opacity: 1; pointer-events: auto; }
        .back-btn:hover { border-color: var(--neon-purple); box-shadow: 0 0 20px rgba(136, 85, 255, 0.3); }
        
        /* Logo */
        .logo-corner {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: inherit;
        }
        
        .logo-icon { font-size: 1.5em; }
        
        .logo-text {
            font-size: 1.2em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Hints */
        .hints {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .tesseract-state.active ~ .hints { opacity: 1; }
        
        .hint {
            padding: 8px 16px;
            background: rgba(18, 18, 28, 0.9);
            border: 1px solid rgba(136, 85, 255, 0.3);
            border-radius: 20px;
            font-size: 0.8em;
            color: var(--text-dim);
        }
    </style>
</head>
<body>
    <!-- Background Canvas -->
    <canvas id="bgCanvas"></canvas>
    
    <!-- Logo -->
    <a href="index.html" class="logo-corner">
        <span class="logo-icon">ü¶ã</span>
        <span class="logo-text">ButterflyFX</span>
    </a>
    
    <!-- Back Button -->
    <button class="back-btn" id="backBtn">‚Üê Back to Start</button>
    
    <!-- HERO STATE -->
    <div class="hero-state" id="heroState">
        <div class="hero-badge">üöÄ The New Dimension</div>
        <h1>Welcome to <span class="gradient-text">Dimensional Computing</span></h1>
        <p class="hero-sub">
            Where <strong>data lives in geometry</strong>, not bits and bytes.<br>
            <strong>Warp drive</strong> for your applications.
        </p>
        <button class="enter-btn" id="enterBtn">Enter the Tesseract ‚Üí</button>
    </div>
    
    <!-- TESSERACT STATE -->
    <div class="tesseract-state" id="tesseractState">
        <canvas id="tesseractCanvas"></canvas>
    </div>
    
    <!-- Hints -->
    <div class="hints">
        <span class="hint">üñ±Ô∏è Drag to rotate</span>
        <span class="hint">‚öôÔ∏è Scroll to zoom</span>
        <span class="hint">üëÜ Click face to explore</span>
    </div>
    
    <script>
    // ============================================
    // STATE MANAGEMENT
    // ============================================
    let currentState = 'hero'; // 'hero' or 'tesseract'
    const heroState = document.getElementById('heroState');
    const tesseractState = document.getElementById('tesseractState');
    const enterBtn = document.getElementById('enterBtn');
    const backBtn = document.getElementById('backBtn');
    
    enterBtn.addEventListener('click', () => {
        currentState = 'tesseract';
        heroState.classList.add('hidden');
        tesseractState.classList.add('active');
        backBtn.classList.add('visible');
    });
    
    backBtn.addEventListener('click', () => {
        currentState = 'hero';
        heroState.classList.remove('hidden');
        tesseractState.classList.remove('active');
        backBtn.classList.remove('visible');
    });
    
    // ============================================
    // BACKGROUND CANVAS (Starfield)
    // ============================================
    (function() {
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        // Stars for depth of field
        let stars = [];
        const STAR_COUNT = 300;
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        
        function createStar() {
            return {
                x: Math.random() * width,
                y: Math.random() * height,
                z: Math.random(), // 0 = far, 1 = near
                baseSize: Math.random() * 1.5 + 0.3,
                twinkle: Math.random() * Math.PI * 2,
                twinkleSpeed: Math.random() * 0.02 + 0.005,
                color: `hsl(${Math.random() * 60 + 220}, ${Math.random() * 30 + 50}%, ${Math.random() * 30 + 60}%)`
            };
        }
        
        function initStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) stars.push(createStar());
        }
        
        function drawHyperspaceStars() {
            // For hero state - fast moving hyperspace
            ctx.fillStyle = 'rgba(3, 3, 6, 0.15)';
            ctx.fillRect(0, 0, width, height);
            
            const cx = width / 2, cy = height / 2;
            
            for (let star of stars) {
                star.z -= 0.015;
                if (star.z <= 0) {
                    star.x = Math.random() * width;
                    star.y = Math.random() * height;
                    star.z = 1;
                }
                
                const scale = 1 / star.z;
                const x = (star.x - cx) * scale + cx;
                const y = (star.y - cy) * scale + cy;
                
                const prevZ = star.z + 0.015;
                const prevScale = 1 / prevZ;
                const px = (star.x - cx) * prevScale + cx;
                const py = (star.y - cy) * prevScale + cy;
                
                const gradient = ctx.createLinearGradient(px, py, x, y);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(1, star.color);
                
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(x, y);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = star.baseSize * (1 - star.z) * 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x, y, star.baseSize * (1 - star.z) * 2, 0, Math.PI * 2);
                ctx.fillStyle = star.color;
                ctx.fill();
            }
        }
        
        function drawDepthStars() {
            // For tesseract state - subtle depth of field
            ctx.fillStyle = 'rgba(3, 3, 6, 0.05)';
            ctx.fillRect(0, 0, width, height);
            
            for (let star of stars) {
                // Subtle drift
                star.x += (star.z - 0.5) * 0.1;
                star.y += (star.z - 0.5) * 0.05;
                
                // Wrap around
                if (star.x < 0) star.x = width;
                if (star.x > width) star.x = 0;
                if (star.y < 0) star.y = height;
                if (star.y > height) star.y = 0;
                
                // Twinkle
                star.twinkle += star.twinkleSpeed;
                const twinkle = 0.5 + Math.sin(star.twinkle) * 0.5;
                
                // Depth of field blur effect (via size/opacity)
                const blur = Math.abs(star.z - 0.5) * 2; // 0 at focus, 1 at extremes
                const size = star.baseSize * (1 + blur * 2);
                const alpha = (1 - blur * 0.7) * twinkle * 0.6;
                
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fillStyle = star.color.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                ctx.fill();
            }
        }
        
        function draw() {
            if (currentState === 'hero') {
                drawHyperspaceStars();
            } else {
                drawDepthStars();
            }
            requestAnimationFrame(draw);
        }
        
        window.addEventListener('resize', resize);
        resize();
        initStars();
        draw();
    })();
    
    // ============================================
    // TESSERACT (4D Hypercube)
    // ============================================
    (function() {
        const canvas = document.getElementById('tesseractCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        // Tesseract parameters
        let scale = 200;
        let rotXY = 0, rotXZ = 0, rotXW = 0.3, rotYZ = 0.2, rotYW = 0, rotZW = 0;
        let targetRotXY = 0, targetRotXZ = 0;
        let isDragging = false;
        let lastX, lastY;
        
        // Color cycling
        let colorPhase = 0;
        
        // Product info for inner cube faces
        const products = [
            { name: 'Universal Hard Drive', icon: 'üíé', url: 'products/universal-hdd.html', 
              tagline: 'One API for Everything', 
              desc: 'Files ‚Ä¢ Databases ‚Ä¢ APIs ‚Ä¢ Services', 
              feature: 'O(1) dimensional access',
              color: '#8855ff' },
            { name: 'Universal Connector', icon: 'üîó', url: 'products/universal-connector.html', 
              tagline: '102 Services Unified', 
              desc: 'AWS ‚Ä¢ Azure ‚Ä¢ GCP ‚Ä¢ AI ‚Ä¢ DBs', 
              feature: 'Single dimensional gateway',
              color: '#ff55aa' },
            { name: 'Data & AI Suite', icon: 'üß†', url: 'products/data-ai-suite.html', 
              tagline: 'Intelligence Amplified', 
              desc: 'AI Amplifier ‚Ä¢ Data Alchemist ‚Ä¢ Oracle', 
              feature: 'Geometry-powered AI',
              color: '#40ffff' },
            { name: 'DimensionOS', icon: 'üåê', url: 'platform.html', 
              tagline: 'The Platform', 
              desc: 'Where shapes hold data', 
              feature: 'Warp drive for apps',
              color: '#60ff90' },
            { name: 'Helix Framework', icon: 'üß¨', url: 'developers.html', 
              tagline: 'Build Dimensional Apps', 
              desc: 'Structural primitives ‚Ä¢ Substrates', 
              feature: 'Code that assembles like DNA',
              color: '#ff8844' },
            { name: 'Get Started', icon: '‚ö°', url: 'register.html', 
              tagline: 'Enter the Dimension', 
              desc: 'Free trial ‚Ä¢ Full access', 
              feature: 'Start building today',
              color: '#ff55aa' }
        ];
        
        // Products for outer cube faces (coming soon / available)
        const outerProducts = [
            { name: 'Quantum Bridge', icon: 'üåâ', url: 'roadmap.html', 
              tagline: 'Coming 2026', 
              desc: 'Cross-dimensional networking', 
              feature: 'Zero-latency data transfer',
              color: '#8855ff', coming: true },
            { name: 'Shape Forge', icon: 'üî•', url: 'roadmap.html', 
              tagline: 'Coming 2026', 
              desc: 'Visual dimensional builder', 
              feature: 'Drag ‚Ä¢ Drop ‚Ä¢ Deploy',
              color: '#ff8844', coming: true },
            { name: 'Manifold Cloud', icon: '‚òÅÔ∏è', url: 'roadmap.html', 
              tagline: 'Coming 2027', 
              desc: 'Dimensional infrastructure', 
              feature: 'Serverless geometry',
              color: '#40ffff', coming: true },
            { name: 'Time Prism', icon: '‚åõ', url: 'roadmap.html', 
              tagline: 'Coming 2027', 
              desc: 'Temporal data operations', 
              feature: 'Version across dimensions',
              color: '#60ff90', coming: true },
            { name: 'Neural Lattice', icon: 'üóß', url: 'roadmap.html', 
              tagline: 'Coming 2027', 
              desc: 'Distributed AI mesh', 
              feature: 'Geometry-native ML',
              color: '#ff55aa', coming: true },
            { name: 'Enterprise', icon: 'üè¢', url: 'enterprise.html', 
              tagline: 'Contact Sales', 
              desc: 'Custom solutions ‚Ä¢ SLA ‚Ä¢ Support', 
              feature: 'Dimensional at scale',
              color: '#8855ff', coming: false }
        ];
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        
        // 4D vertices of hypercube
        function getHypercubeVertices(size) {
            const s = size;
            return [
                [-s, -s, -s, -s], [s, -s, -s, -s], [s, s, -s, -s], [-s, s, -s, -s],
                [-s, -s, s, -s], [s, -s, s, -s], [s, s, s, -s], [-s, s, s, -s],
                [-s, -s, -s, s], [s, -s, -s, s], [s, s, -s, s], [-s, s, -s, s],
                [-s, -s, s, s], [s, -s, s, s], [s, s, s, s], [-s, s, s, s]
            ];
        }
        
        // Edges connecting vertices
        const edges = [
            // Inner cube (w = -1)
            [0,1], [1,2], [2,3], [3,0], [4,5], [5,6], [6,7], [7,4],
            [0,4], [1,5], [2,6], [3,7],
            // Outer cube (w = +1)
            [8,9], [9,10], [10,11], [11,8], [12,13], [13,14], [14,15], [15,12],
            [8,12], [9,13], [10,14], [11,15],
            // Connecting edges (between inner and outer)
            [0,8], [1,9], [2,10], [3,11], [4,12], [5,13], [6,14], [7,15]
        ];
        
        // 4D rotation matrices
        function rotate4D(v, rXY, rXZ, rXW, rYZ, rYW, rZW) {
            let [x, y, z, w] = v;
            
            // XY rotation
            let c = Math.cos(rXY), s = Math.sin(rXY);
            [x, y] = [x*c - y*s, x*s + y*c];
            
            // XZ rotation
            c = Math.cos(rXZ); s = Math.sin(rXZ);
            [x, z] = [x*c - z*s, x*s + z*c];
            
            // XW rotation
            c = Math.cos(rXW); s = Math.sin(rXW);
            [x, w] = [x*c - w*s, x*s + w*c];
            
            // YZ rotation
            c = Math.cos(rYZ); s = Math.sin(rYZ);
            [y, z] = [y*c - z*s, y*s + z*c];
            
            // YW rotation
            c = Math.cos(rYW); s = Math.sin(rYW);
            [y, w] = [y*c - w*s, y*s + w*c];
            
            // ZW rotation
            c = Math.cos(rZW); s = Math.sin(rZW);
            [z, w] = [z*c - w*s, z*s + w*c];
            
            return [x, y, z, w];
        }
        
        // Project 4D to 2D
        function project4D(v) {
            const [x, y, z, w] = v;
            const distance4D = 3;
            const distance3D = 4;
            
            // 4D to 3D projection
            const scale4D = distance4D / (distance4D - w);
            const x3 = x * scale4D;
            const y3 = y * scale4D;
            const z3 = z * scale4D;
            
            // 3D to 2D projection
            const scale3D = distance3D / (distance3D + z3);
            const x2 = x3 * scale3D * scale + width / 2;
            const y2 = y3 * scale3D * scale + height / 2;
            
            return { x: x2, y: y2, z: z3, w: w, scale: scale4D * scale3D };
        }
        
        // Get neon color based on phase and w-depth
        function getEdgeColor(w1, w2, phase) {
            const avgW = (w1 + w2) / 2;
            const hue = (phase + avgW * 30 + 270) % 360;
            const sat = 100;
            const light = 60 + avgW * 10;
            return `hsl(${hue}, ${sat}%, ${light}%)`;
        }
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            // Smooth interpolation for drag rotation
            rotXY += (targetRotXY - rotXY) * 0.1;
            rotXZ += (targetRotXZ - rotXZ) * 0.1;
            
            colorPhase += 0.3;
            
            // Get transformed vertices
            const innerSize = 0.5;
            const outerSize = 1.0;
            const vertices = getHypercubeVertices(1);
            
            const projected = vertices.map(v => {
                const rotated = rotate4D(v, rotXY, rotXZ, rotXW, rotYZ, rotYW, rotZW);
                return project4D(rotated);
            });
            
            // Sort edges by average z for proper depth rendering
            const sortedEdges = edges.map((e, i) => ({
                edge: e,
                index: i,
                avgZ: (projected[e[0]].z + projected[e[1]].z) / 2,
                avgW: (projected[e[0]].w + projected[e[1]].w) / 2
            })).sort((a, b) => a.avgZ - b.avgZ);
            
            // Draw edges
            for (let { edge, index, avgW } of sortedEdges) {
                const [i1, i2] = edge;
                const p1 = projected[i1];
                const p2 = projected[i2];
                
                const isConnecting = index >= 24; // Connecting edges
                const isOuter = index >= 12 && index < 24; // Outer cube
                
                const color = getEdgeColor(p1.w, p2.w, colorPhase);
                
                // Glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = isConnecting ? 15 : 20;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                
                // Create gradient along edge
                const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                const c1 = getEdgeColor(p1.w, p1.w, colorPhase);
                const c2 = getEdgeColor(p2.w, p2.w, colorPhase);
                gradient.addColorStop(0, c1);
                gradient.addColorStop(1, c2);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = isConnecting ? 1.5 : (isOuter ? 2 : 3);
                ctx.lineCap = 'round';
                ctx.stroke();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw vertices as glowing points
            const sortedVertices = projected.map((p, i) => ({ p, i }))
                .sort((a, b) => a.p.z - b.p.z);
            
            for (let { p, i } of sortedVertices) {
                const isInner = i < 8;
                const size = (isInner ? 6 : 4) * p.scale;
                const color = getEdgeColor(p.w, p.w, colorPhase);
                
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw glowing transparent panels on cube faces
            const faceDefs = [
                // Inner cube (current products)
                { verts: [0,1,2,3], product: products[0], isOuter: false }, // front
                { verts: [4,5,6,7], product: products[1], isOuter: false }, // back
                { verts: [1,5,6,2], product: products[2], isOuter: false }, // right
                { verts: [0,4,7,3], product: products[3], isOuter: false }, // left
                { verts: [3,2,6,7], product: products[4], isOuter: false }, // top
                { verts: [0,1,5,4], product: products[5], isOuter: false }, // bottom
                // Outer cube (future/available products)
                { verts: [8,9,10,11], product: outerProducts[0], isOuter: true }, // front
                { verts: [12,13,14,15], product: outerProducts[1], isOuter: true }, // back
                { verts: [9,13,14,10], product: outerProducts[2], isOuter: true }, // right
                { verts: [8,12,15,11], product: outerProducts[3], isOuter: true }, // left
                { verts: [11,10,14,15], product: outerProducts[4], isOuter: true }, // top
                { verts: [8,9,13,12], product: outerProducts[5], isOuter: true }  // bottom
            ];
            
            // Sort faces by z-depth (back to front)
            const sortedFaces = faceDefs.map(f => {
                const avgZ = f.verts.reduce((s, v) => s + projected[v].z, 0) / 4;
                return { ...f, avgZ };
            }).sort((a, b) => b.avgZ - a.avgZ);
            
            for (let face of sortedFaces) {
                const verts = face.verts.map(v => projected[v]);
                const cx = verts.reduce((s, v) => s + v.x, 0) / 4;
                const cy = verts.reduce((s, v) => s + v.y, 0) / 4;
                const cz = face.avgZ;
                
                // Calculate face normal to determine visibility
                const v0 = verts[0], v1 = verts[1], v2 = verts[2];
                const ax = v1.x - v0.x, ay = v1.y - v0.y;
                const bx = v2.x - v0.x, by = v2.y - v0.y;
                const cross = ax * by - ay * bx;
                
                // Only draw faces pointing toward camera
                if (cross > 0) {
                    const p = face.product;
                    const isOuter = face.isOuter;
                    // Outer panels are more ethereal/transparent
                    const baseAlpha = isOuter ? 0.6 : 0.95;
                    const alpha = Math.min(baseAlpha, Math.max(0.3, (isOuter ? 0.5 : 0.8) - cz * 0.2));
                    
                    // Parse color
                    const hex = p.color;
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    
                    // Draw glass panel fill
                    ctx.beginPath();
                    ctx.moveTo(verts[0].x, verts[0].y);
                    for (let i = 1; i < 4; i++) ctx.lineTo(verts[i].x, verts[i].y);
                    ctx.closePath();
                    
                    // Gradient fill - outer is more ethereal
                    const gradient = ctx.createLinearGradient(
                        verts[0].x, verts[0].y,
                        verts[2].x, verts[2].y
                    );
                    if (isOuter) {
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.12})`);
                        gradient.addColorStop(0.5, `rgba(10, 10, 18, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${alpha * 0.08})`);
                    } else {
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.25})`);
                        gradient.addColorStop(0.3, `rgba(15, 15, 25, ${alpha * 0.85})`);
                        gradient.addColorStop(0.7, `rgba(15, 15, 25, ${alpha * 0.85})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${alpha * 0.2})`);
                    }
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Glowing neon border - outer has dashed effect
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.lineWidth = isOuter ? 2 : 3;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = isOuter ? 15 : 30;
                    if (isOuter) ctx.setLineDash([10, 5]);
                    ctx.stroke();
                    if (!isOuter) {
                        ctx.shadowBlur = 15;
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                    
                    // Inner white highlight
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * (isOuter ? 0.2 : 0.4)})`;
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 0;
                    ctx.stroke();
                    
                    // Calculate panel size for text scaling
                    const panelSize = Math.sqrt(
                        Math.pow(verts[1].x - verts[0].x, 2) +
                        Math.pow(verts[1].y - verts[0].y, 2)
                    );
                    const textScale = Math.min(isOuter ? 1.0 : 1.2, panelSize / (isOuter ? 150 : 120));
                    
                    if (textScale > 0.35) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        const textAlpha = isOuter ? 0.7 : 1.0;
                        
                        // Large Icon with glow
                        ctx.font = `${Math.round((isOuter ? 40 : 48) * textScale)}px -apple-system, sans-serif`;
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = isOuter ? 15 : 25;
                        ctx.fillStyle = `rgba(255, 255, 255, ${textAlpha})`;
                        ctx.fillText(p.icon, cx, cy - 45 * textScale);
                        
                        // Product name - bold and prominent
                        ctx.font = `bold ${Math.round((isOuter ? 15 : 18) * textScale)}px -apple-system, sans-serif`;
                        ctx.shadowBlur = isOuter ? 8 : 15;
                        ctx.fillStyle = `rgba(255, 255, 255, ${textAlpha})`;
                        ctx.fillText(p.name, cx, cy - 5 * textScale);
                        
                        // Tagline - colored (shows Coming Soon status for outer)
                        ctx.font = `${Math.round((isOuter ? 11 : 13) * textScale)}px -apple-system, sans-serif`;
                        ctx.fillStyle = p.color;
                        ctx.shadowBlur = isOuter ? 5 : 10;
                        ctx.fillText(p.tagline, cx, cy + 18 * textScale);
                        
                        // Description - dimmer
                        ctx.font = `${Math.round((isOuter ? 10 : 11) * textScale)}px -apple-system, sans-serif`;
                        ctx.fillStyle = `rgba(255, 255, 255, ${isOuter ? 0.4 : 0.6})`;
                        ctx.shadowBlur = 0;
                        ctx.fillText(p.desc, cx, cy + 38 * textScale);
                        
                        // Feature highlight
                        ctx.font = `italic ${Math.round((isOuter ? 9 : 10) * textScale)}px -apple-system, sans-serif`;
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${isOuter ? 0.5 : 0.8})`;
                        ctx.fillText(p.feature, cx, cy + 55 * textScale);
                        
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            requestAnimationFrame(draw);
        }
        
        // Mouse controls
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.classList.add('dragging');
        });
        
        document.addEventListener('mousemove', e => {
            if (!isDragging) return;
            targetRotXY += (e.clientX - lastX) * 0.005;
            targetRotXZ += (e.clientY - lastY) * 0.005;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.classList.remove('dragging');
        });
        
        // Touch controls
        canvas.addEventListener('touchstart', e => {
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchmove', e => {
            if (!isDragging) return;
            targetRotXY += (e.touches[0].clientX - lastX) * 0.005;
            targetRotXZ += (e.touches[0].clientY - lastY) * 0.005;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', () => {
            isDragging = false;
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            scale *= e.deltaY > 0 ? 0.95 : 1.05;
            scale = Math.max(50, Math.min(500, scale));
        }, { passive: false });
        
        // Click to navigate
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            const vertices = getHypercubeVertices(1);
            const proj = vertices.map(v => {
                const rotated = rotate4D(v, rotXY, rotXZ, rotXW, rotYZ, rotYW, rotZW);
                return project4D(rotated);
            });
            
            const faceDefs = [
                // Inner cube
                { verts: [0,1,2,3], product: products[0] },
                { verts: [4,5,6,7], product: products[1] },
                { verts: [1,5,6,2], product: products[2] },
                { verts: [0,4,7,3], product: products[3] },
                { verts: [3,2,6,7], product: products[4] },
                { verts: [0,1,5,4], product: products[5] },
                // Outer cube
                { verts: [8,9,10,11], product: outerProducts[0] },
                { verts: [12,13,14,15], product: outerProducts[1] },
                { verts: [9,13,14,10], product: outerProducts[2] },
                { verts: [8,12,15,11], product: outerProducts[3] },
                { verts: [11,10,14,15], product: outerProducts[4] },
                { verts: [8,9,13,12], product: outerProducts[5] }
            ];
            
            // Sort front to back for click priority
            const sortedFaces = faceDefs.map(f => {
                const avgZ = f.verts.reduce((s, v) => s + proj[v].z, 0) / 4;
                return { ...f, avgZ };
            }).sort((a, b) => a.avgZ - b.avgZ);
            
            for (let face of sortedFaces) {
                const verts = face.verts.map(v => proj[v]);
                
                // Check face normal
                const v0 = verts[0], v1 = verts[1], v2 = verts[2];
                const ax = v1.x - v0.x, ay = v1.y - v0.y;
                const bx = v2.x - v0.x, by = v2.y - v0.y;
                const cross = ax * by - ay * bx;
                
                if (cross > 0) {
                    // Point in polygon test
                    let inside = false;
                    for (let i = 0, j = 3; i < 4; j = i++) {
                        const xi = verts[i].x, yi = verts[i].y;
                        const xj = verts[j].x, yj = verts[j].y;
                        if (((yi > my) !== (yj > my)) && (mx < (xj - xi) * (my - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    if (inside) {
                        window.location.href = face.product.url;
                        return;
                    }
                }
            }
        });
        
        window.addEventListener('resize', resize);
        resize();
        draw();
    })();
    </script>
</body>
</html>

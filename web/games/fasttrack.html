<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastTrack ‚Äî ButterflyFX Dimensional Racing</title>
    <style>
        :root {
            --bg: #050508;
            --bg-card: rgba(18, 18, 28, 0.9);
            --neon-purple: #8855ff;
            --neon-pink: #ff55aa;
            --neon-cyan: #40ffff;
            --neon-green: #60ff90;
            --neon-orange: #ff8844;
            --neon-red: #ff4466;
            --text: #ffffff;
            --text-dim: #a0a8c0;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Starfield */
        #starfield {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        /* Header */
        header {
            position: relative;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: rgba(5, 5, 8, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(136, 85, 255, 0.3);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--text);
            font-size: 1.3em;
            font-weight: 700;
        }
        
        .game-title {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.5em;
            font-weight: 700;
        }
        
        /* Main Layout */
        main {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 20px;
        }
        
        /* Game Container */
        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        
        /* Game Board */
        #gameBoard {
            background: var(--bg-card);
            border: 2px solid var(--neon-purple);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(136, 85, 255, 0.3);
        }
        
        /* Controls Panel */
        .controls {
            background: var(--bg-card);
            border: 1px solid rgba(136, 85, 255, 0.3);
            border-radius: 16px;
            padding: 25px;
            min-width: 280px;
        }
        
        .controls h2 {
            color: var(--neon-cyan);
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .player-status {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }
        
        .player-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 15px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
        }
        
        .player-row.active {
            background: rgba(136, 85, 255, 0.2);
            border: 1px solid var(--neon-purple);
        }
        
        .player-row.winner {
            background: rgba(96, 255, 144, 0.2);
            border: 1px solid var(--neon-green);
        }
        
        .player-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .player-name {
            flex: 1;
            font-weight: 600;
        }
        
        .player-score {
            font-size: 0.9em;
            color: var(--text-dim);
        }
        
        /* Dice */
        .dice-area {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .dice {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #222, #333);
            border: 2px solid var(--neon-cyan);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: 700;
            color: var(--neon-cyan);
            transition: all 0.3s;
        }
        
        .dice.rolling {
            animation: diceRoll 0.1s infinite;
        }
        
        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(10deg); }
            75% { transform: rotate(-10deg); }
        }
        
        .roll-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .roll-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 25px rgba(136, 85, 255, 0.5);
        }
        
        .roll-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Message */
        .message {
            padding: 15px;
            background: rgba(64, 255, 255, 0.1);
            border: 1px solid var(--neon-cyan);
            border-radius: 10px;
            text-align: center;
            font-size: 1em;
            color: var(--neon-cyan);
            margin-bottom: 20px;
            min-height: 50px;
        }
        
        /* Rules Toggle */
        .rules-toggle {
            text-align: center;
        }
        
        .rules-btn {
            background: transparent;
            border: 1px solid var(--text-dim);
            border-radius: 20px;
            padding: 8px 20px;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .rules-btn:hover {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }
        
        .rules-content {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: left;
            font-size: 0.9em;
            color: var(--text-dim);
            line-height: 1.6;
        }
        
        .rules-content.show {
            display: block;
        }
        
        .rules-content h4 {
            color: var(--neon-pink);
            margin: 10px 0 5px;
        }
        
        .rules-content h4:first-child {
            margin-top: 0;
        }
        
        /* Dimensional Info */
        .dimensional-info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(136, 85, 255, 0.1), rgba(255, 85, 170, 0.05));
            border: 1px solid rgba(136, 85, 255, 0.3);
            border-radius: 10px;
        }
        
        .dimensional-info h4 {
            color: var(--neon-purple);
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .level-indicator {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .level {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-dim);
        }
        
        .level.active {
            background: var(--neon-purple);
            color: white;
        }
        
        /* New Game */
        .new-game-btn {
            width: 100%;
            margin-top: 20px;
            padding: 12px;
            background: transparent;
            border: 2px solid var(--neon-green);
            border-radius: 10px;
            color: var(--neon-green);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .new-game-btn:hover {
            background: var(--neon-green);
            color: var(--bg);
        }
        
        /* Mobile */
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            #gameBoard {
                max-width: 100%;
            }
            
            .controls {
                min-width: auto;
                width: 100%;
                max-width: 500px;
            }
        }
    </style>
</head>
<body>
    <canvas id="starfield"></canvas>
    
    <header>
        <a href="../index.html" class="logo">ü¶ã ButterflyFX</a>
        <span class="game-title">‚ö° FastTrack</span>
    </header>
    
    <main>
        <div class="game-container">
            <canvas id="gameBoard" width="600" height="600"></canvas>
            
            <div class="controls">
                <h2>üé≤ Game Controls</h2>
                
                <div class="player-status" id="playerStatus"></div>
                
                <div class="message" id="message">Roll the dice to begin!</div>
                
                <div class="dice-area">
                    <div class="dice-container">
                        <div class="dice" id="dice1">-</div>
                        <div class="dice" id="dice2">-</div>
                    </div>
                    <button class="roll-btn" id="rollBtn" onclick="rollDice()">üé≤ Roll Dice</button>
                </div>
                
                <div class="dimensional-info">
                    <h4>üåÄ Dimensional State</h4>
                    <div class="level-indicator" id="levelIndicator">
                        <span class="level" data-level="0">0: Void</span>
                        <span class="level" data-level="1">1: Point</span>
                        <span class="level" data-level="2">2: Line</span>
                        <span class="level" data-level="3">3: Surface</span>
                        <span class="level" data-level="4">4: Volume</span>
                        <span class="level" data-level="5">5: Network</span>
                        <span class="level" data-level="6">6: Whole</span>
                    </div>
                </div>
                
                <div class="rules-toggle">
                    <button class="rules-btn" onclick="toggleRules()">üìñ Rules</button>
                    <div class="rules-content" id="rulesContent">
                        <h4>üéØ Objective</h4>
                        Move all 4 pieces from your BASE around the track to your HOME.
                        
                        <h4>üé≤ Rolling</h4>
                        Roll two dice. Move one piece the total, or split between two pieces.
                        Roll doubles for an extra turn!
                        
                        <h4>‚ö° Fast Track</h4>
                        Land on a ‚ö° space to take the center shortcut ‚Äî invoking the next spiral level!
                        
                        <h4>üí• Bumping</h4>
                        Land on an opponent's piece to send them back to their base.
                        
                        <h4>üè† Getting Home</h4>
                        Must roll exact number to enter home. Pieces in home are safe.
                        
                        <h4>ü¶ã Dimensional Rules</h4>
                        Each piece exists at a dimensional level. Moving invokes transitions through the 7-level helix. The Fast Track represents a spiral_up() ‚Äî jumping to the next level instantly!
                    </div>
                </div>
                
                <button class="new-game-btn" onclick="newGame()">üîÑ New Game</button>
            </div>
        </div>
    </main>
    
    <script>
    // ============================================
    // BUTTERFLYFX FASTTRACK GAME
    // Dimensional Racing with Identity-First Design
    // ============================================
    
    // === DIMENSIONAL SUBSTRATE ===
    // Each piece has identity BEFORE position (Level 1 before Level 4)
    class DimensionalPiece {
        constructor(id, playerId, color) {
            // Level 1: Identity (exists before manifestation)
            this.id = id;
            this.playerId = playerId;
            this.color = color;
            
            // Level 2: Relationships
            this.state = 'base'; // base, track, fasttrack, home
            
            // Level 3: Structure
            this.position = -1; // -1 = base, 0-63 = track, 100+ = home
            
            // Level 4: Manifestation (canvas coordinates derived from position)
            // NOT stored - computed from manifold
            
            // Level 5: Multiplicity (interactions)
            this.canBeBumped = true;
            
            // Level 6: Meaning (purpose)
            this.purpose = 'race_home';
            
            // Spiral level
            this.spiralLevel = 0;
        }
        
        // O(1) invocation - no iteration
        invoke(targetLevel) {
            this.spiralLevel = Math.min(6, targetLevel);
        }
        
        // Manifestation is DERIVED, not stored
        getManifestCoords() {
            // Position on substrate determines visual coords
            return this.substrate ? this.substrate.evaluate(this.position) : null;
        }
    }
    
    // === MANIFOLD SUBSTRATE ===
    // The board IS the manifold - position determines everything
    class TrackSubstrate {
        constructor(centerX, centerY, radius) {
            this.cx = centerX;
            this.cy = centerY;
            this.radius = radius;
            this.trackSpaces = 64; // Total spaces around track
            this.homeSpaces = 4;
            
            // Fast track positions (shortcuts to center)
            this.fastTrackPositions = [0, 16, 32, 48];
            
            // Player data embedded in substrate geometry
            this.playerColors = ['#ff4466', '#40ffff', '#60ff90', '#ff8844'];
            this.playerStarts = [0, 16, 32, 48];
            this.playerHomeAngles = [0, Math.PI/2, Math.PI, Math.PI * 1.5];
        }
        
        // O(1) evaluation - position ‚Üí coordinates
        evaluate(position, playerId = 0, isHome = false, homeIndex = 0) {
            if (position < 0) {
                // Base position
                return this.getBasePosition(playerId, -position - 1);
            } else if (isHome) {
                // Home position
                return this.getHomePosition(playerId, homeIndex);
            } else if (position >= 100) {
                // Fast track center
                return this.getFastTrackPosition(position - 100);
            } else {
                // Track position
                return this.getTrackPosition(position);
            }
        }
        
        getTrackPosition(pos) {
            const angle = (pos / this.trackSpaces) * Math.PI * 2 - Math.PI / 2;
            return {
                x: this.cx + Math.cos(angle) * this.radius,
                y: this.cy + Math.sin(angle) * this.radius
            };
        }
        
        getBasePosition(playerId, index) {
            const baseAngle = this.playerHomeAngles[playerId];
            const baseRadius = this.radius + 60;
            const baseX = this.cx + Math.cos(baseAngle) * baseRadius;
            const baseY = this.cy + Math.sin(baseAngle) * baseRadius;
            
            const offsetX = (index % 2) * 30 - 15;
            const offsetY = Math.floor(index / 2) * 30 - 15;
            
            return { x: baseX + offsetX, y: baseY + offsetY };
        }
        
        getHomePosition(playerId, index) {
            const angle = this.playerHomeAngles[playerId];
            const homeRadius = this.radius * 0.3 + index * 20;
            return {
                x: this.cx + Math.cos(angle) * homeRadius,
                y: this.cy + Math.sin(angle) * homeRadius
            };
        }
        
        getFastTrackPosition(index) {
            const angle = (index / 4) * Math.PI * 2 - Math.PI / 2;
            const r = this.radius * 0.15;
            return {
                x: this.cx + Math.cos(angle) * r,
                y: this.cy + Math.sin(angle) * r
            };
        }
        
        isFastTrack(position) {
            return this.fastTrackPositions.includes(position % this.trackSpaces);
        }
    }
    
    // === GAME STATE (Helix Kernel Pattern) ===
    const game = {
        spiral: 0,
        level: 0,
        substrate: null,
        players: [],
        pieces: [],
        currentPlayer: 0,
        dice: [0, 0],
        selectedPiece: null,
        phase: 'roll', // roll, move, gameover
        moveOptions: [],
        winner: null
    };
    
    // === CANVAS SETUP ===
    const canvas = document.getElementById('gameBoard');
    const ctx = canvas.getContext('2d');
    const starCanvas = document.getElementById('starfield');
    const starCtx = starCanvas.getContext('2d');
    
    // === INITIALIZATION ===
    function initGame() {
        // Create substrate (manifold)
        game.substrate = new TrackSubstrate(300, 300, 200);
        
        // Create players (identity-first)
        const playerNames = ['Red', 'Cyan', 'Green', 'Orange'];
        const playerColors = ['#ff4466', '#40ffff', '#60ff90', '#ff8844'];
        
        game.players = [];
        game.pieces = [];
        
        for (let p = 0; p < 4; p++) {
            game.players.push({
                id: p,
                name: playerNames[p],
                color: playerColors[p],
                isAI: p > 0, // Player 0 is human
                piecesHome: 0
            });
            
            // Create 4 pieces per player (identity exists before position)
            for (let i = 0; i < 4; i++) {
                const piece = new DimensionalPiece(
                    `${p}-${i}`,
                    p,
                    playerColors[p]
                );
                piece.substrate = game.substrate;
                piece.baseIndex = i;
                game.pieces.push(piece);
            }
        }
        
        game.currentPlayer = 0;
        game.phase = 'roll';
        game.winner = null;
        game.spiral = 0;
        game.level = 1;
        
        updateUI();
        render();
    }
    
    // === DICE ROLLING ===
    function rollDice() {
        if (game.phase !== 'roll' || game.winner) return;
        
        const dice1El = document.getElementById('dice1');
        const dice2El = document.getElementById('dice2');
        const rollBtn = document.getElementById('rollBtn');
        
        // Disable button during roll
        rollBtn.disabled = true;
        dice1El.classList.add('rolling');
        dice2El.classList.add('rolling');
        
        // Animate dice
        let rolls = 0;
        const rollInterval = setInterval(() => {
            game.dice[0] = Math.floor(Math.random() * 6) + 1;
            game.dice[1] = Math.floor(Math.random() * 6) + 1;
            dice1El.textContent = game.dice[0];
            dice2El.textContent = game.dice[1];
            rolls++;
            
            if (rolls > 10) {
                clearInterval(rollInterval);
                dice1El.classList.remove('rolling');
                dice2El.classList.remove('rolling');
                
                // Process roll
                processRoll();
            }
        }, 100);
    }
    
    function processRoll() {
        const total = game.dice[0] + game.dice[1];
        const doubles = game.dice[0] === game.dice[1];
        
        // Find valid moves
        const playerPieces = game.pieces.filter(p => p.playerId === game.currentPlayer);
        game.moveOptions = [];
        
        playerPieces.forEach(piece => {
            if (piece.state === 'base') {
                // Can enter track with doubles or total >= 10
                if (doubles || total >= 10) {
                    game.moveOptions.push({
                        piece: piece,
                        type: 'enter',
                        position: game.substrate.playerStarts[game.currentPlayer]
                    });
                }
            } else if (piece.state === 'track' || piece.state === 'fasttrack') {
                // Can move on track
                const newPos = calculateNewPosition(piece, total);
                if (newPos !== null) {
                    game.moveOptions.push({
                        piece: piece,
                        type: 'move',
                        position: newPos.pos,
                        isHome: newPos.isHome,
                        homeIndex: newPos.homeIndex
                    });
                }
            }
        });
        
        if (game.moveOptions.length === 0) {
            showMessage(`No valid moves! Next player...`);
            setTimeout(() => nextPlayer(), 1500);
        } else {
            game.phase = 'move';
            
            if (game.players[game.currentPlayer].isAI) {
                // AI makes move
                setTimeout(() => aiMove(), 1000);
            } else {
                showMessage(`Rolled ${total}${doubles ? ' (DOUBLES!)' : ''}. Click a piece to move.`);
            }
        }
        
        render();
    }
    
    function calculateNewPosition(piece, moves) {
        const playerStart = game.substrate.playerStarts[piece.playerId];
        const homeEntrance = (playerStart + 60) % 64;
        
        let currentPos = piece.position;
        if (piece.state === 'fasttrack') {
            // Fast track jumps to near home
            currentPos = (playerStart + 48) % 64;
        }
        
        // Check if would pass home entrance
        for (let i = 1; i <= moves; i++) {
            const checkPos = (currentPos + i) % 64;
            if (checkPos === homeEntrance) {
                // Entering home
                const remaining = moves - i;
                if (remaining < 4) {
                    return { pos: homeEntrance, isHome: true, homeIndex: remaining };
                }
            }
        }
        
        // Regular track movement
        return { pos: (currentPos + moves) % 64, isHome: false, homeIndex: 0 };
    }
    
    function movePiece(option) {
        const piece = option.piece;
        const doubles = game.dice[0] === game.dice[1];
        
        // Invoke dimensional transition
        piece.invoke(Math.min(6, piece.spiralLevel + 1));
        game.level = piece.spiralLevel;
        
        if (option.type === 'enter') {
            // Enter track from base
            piece.state = 'track';
            piece.position = option.position;
            showMessage(`${game.players[piece.playerId].name} enters the track!`);
        } else if (option.isHome) {
            // Move into home
            piece.state = 'home';
            piece.homePosition = option.homeIndex;
            game.players[piece.playerId].piecesHome++;
            
            // Level 6 = Whole = piece completes journey
            piece.invoke(6);
            showMessage(`${game.players[piece.playerId].name} piece reaches HOME! üè†`);
            
            // Check for win
            if (game.players[piece.playerId].piecesHome >= 4) {
                game.winner = piece.playerId;
                game.phase = 'gameover';
                showMessage(`üéâ ${game.players[piece.playerId].name} WINS! üéâ`);
                updateUI();
                render();
                return;
            }
        } else {
            // Check for fast track
            if (game.substrate.isFastTrack(option.position) && piece.state !== 'fasttrack') {
                piece.state = 'fasttrack';
                piece.position = option.position;
                
                // Spiral up!
                game.spiral++;
                showMessage(`‚ö° FAST TRACK! spiral_up() to level ${game.spiral}!`);
            } else {
                piece.state = 'track';
                piece.position = option.position;
                
                // Check for bumping
                checkBump(piece);
            }
        }
        
        game.phase = doubles ? 'roll' : 'roll';
        game.moveOptions = [];
        
        // Spiral transition on doubles
        if (doubles) {
            showMessage(`DOUBLES! Roll again!`);
            document.getElementById('rollBtn').disabled = false;
        } else {
            setTimeout(() => nextPlayer(), 1000);
        }
        
        updateUI();
        render();
    }
    
    function checkBump(movedPiece) {
        game.pieces.forEach(piece => {
            if (piece.id !== movedPiece.id && 
                piece.state === 'track' && 
                piece.position === movedPiece.position &&
                piece.playerId !== movedPiece.playerId) {
                
                // Bump! Send back to base
                piece.state = 'base';
                piece.position = -1;
                piece.invoke(0); // Reset to Level 0
                
                showMessage(`üí• ${game.players[movedPiece.playerId].name} bumps ${game.players[piece.playerId].name}!`);
            }
        });
    }
    
    function aiMove() {
        if (game.moveOptions.length === 0) {
            nextPlayer();
            return;
        }
        
        // Simple AI: prioritize home, then bumping, then furthest move
        let bestOption = game.moveOptions[0];
        
        game.moveOptions.forEach(option => {
            if (option.isHome) bestOption = option;
        });
        
        movePiece(bestOption);
    }
    
    function nextPlayer() {
        game.currentPlayer = (game.currentPlayer + 1) % 4;
        game.phase = 'roll';
        document.getElementById('rollBtn').disabled = false;
        
        updateUI();
        showMessage(`${game.players[game.currentPlayer].name}'s turn. Roll the dice!`);
        
        // Auto-roll for AI
        if (game.players[game.currentPlayer].isAI && !game.winner) {
            setTimeout(() => rollDice(), 1000);
        }
    }
    
    // === RENDERING ===
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const sub = game.substrate;
        
        // Draw track (the manifold)
        ctx.strokeStyle = 'rgba(136, 85, 255, 0.5)';
        ctx.lineWidth = 30;
        ctx.beginPath();
        ctx.arc(sub.cx, sub.cy, sub.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw track spaces
        for (let i = 0; i < 64; i++) {
            const pos = sub.getTrackPosition(i);
            const isFast = sub.isFastTrack(i);
            
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, isFast ? 12 : 8, 0, Math.PI * 2);
            
            if (isFast) {
                ctx.fillStyle = '#ffcc00';
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ö°', pos.x, pos.y);
            } else {
                ctx.fillStyle = 'rgba(136, 85, 255, 0.3)';
                ctx.fill();
            }
        }
        
        // Draw fast track center
        ctx.beginPath();
        ctx.arc(sub.cx, sub.cy, 40, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 204, 0, 0.2)';
        ctx.fill();
        ctx.strokeStyle = '#ffcc00';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw "Fast Track" text
        ctx.fillStyle = '#ffcc00';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('FAST', sub.cx, sub.cy - 5);
        ctx.fillText('TRACK', sub.cx, sub.cy + 10);
        
        // Draw player bases and homes
        for (let p = 0; p < 4; p++) {
            const color = sub.playerColors[p];
            
            // Draw base area
            const basePos = sub.getBasePosition(p, 0);
            ctx.beginPath();
            ctx.arc(basePos.x + 7, basePos.y + 7, 35, 0, Math.PI * 2);
            ctx.fillStyle = color + '20';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = color;
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BASE', basePos.x + 7, basePos.y + 30);
            
            // Draw home stretch
            const homeAngle = sub.playerHomeAngles[p];
            ctx.strokeStyle = color + '60';
            ctx.lineWidth = 15;
            ctx.beginPath();
            ctx.moveTo(sub.cx, sub.cy);
            ctx.lineTo(
                sub.cx + Math.cos(homeAngle) * (sub.radius * 0.6),
                sub.cy + Math.sin(homeAngle) * (sub.radius * 0.6)
            );
            ctx.stroke();
            
            // Home spaces
            for (let h = 0; h < 4; h++) {
                const hPos = sub.getHomePosition(p, h);
                ctx.beginPath();
                ctx.arc(hPos.x, hPos.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = color + '40';
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        
        // Draw pieces
        game.pieces.forEach(piece => {
            let pos;
            
            if (piece.state === 'base') {
                pos = sub.getBasePosition(piece.playerId, piece.baseIndex);
            } else if (piece.state === 'home') {
                pos = sub.getHomePosition(piece.playerId, piece.homePosition);
            } else if (piece.state === 'fasttrack') {
                pos = sub.getFastTrackPosition(piece.playerId);
            } else {
                pos = sub.getTrackPosition(piece.position);
            }
            
            // Check if selectable
            const isSelectable = game.moveOptions.some(o => o.piece.id === piece.id);
            const isCurrentPlayer = piece.playerId === game.currentPlayer;
            
            // Glow for selectable pieces
            if (isSelectable) {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 18, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
            }
            
            // Draw piece
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
            
            // Gradient fill
            const grad = ctx.createRadialGradient(pos.x - 3, pos.y - 3, 0, pos.x, pos.y, 12);
            grad.addColorStop(0, piece.color);
            grad.addColorStop(1, shadeColor(piece.color, -30));
            ctx.fillStyle = grad;
            ctx.fill();
            
            // Border
            ctx.strokeStyle = isCurrentPlayer && isSelectable ? '#fff' : piece.color;
            ctx.lineWidth = isSelectable ? 3 : 2;
            ctx.stroke();
            
            // Level indicator
            if (piece.spiralLevel > 0) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(piece.spiralLevel, pos.x, pos.y);
            }
        });
        
        // Instructions highlight
        if (game.phase === 'move' && !game.players[game.currentPlayer].isAI) {
            ctx.fillStyle = 'rgba(136, 85, 255, 0.8)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Click a glowing piece to move', sub.cx, 30);
        }
    }
    
    function shadeColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, Math.min(255, (num >> 16) + amt));
        const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
        const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
        return `rgb(${R},${G},${B})`;
    }
    
    // === UI UPDATES ===
    function updateUI() {
        // Player status
        const statusEl = document.getElementById('playerStatus');
        statusEl.innerHTML = game.players.map((p, i) => `
            <div class="player-row ${i === game.currentPlayer ? 'active' : ''} ${game.winner === i ? 'winner' : ''}">
                <div class="player-indicator" style="background: ${p.color}"></div>
                <span class="player-name">${p.name}${p.isAI ? ' (AI)' : ''}</span>
                <span class="player-score">üè† ${p.piecesHome}/4</span>
            </div>
        `).join('');
        
        // Level indicator
        document.querySelectorAll('.level').forEach(el => {
            const level = parseInt(el.dataset.level);
            el.classList.toggle('active', level === game.level);
        });
        
        // Roll button
        document.getElementById('rollBtn').disabled = 
            game.phase !== 'roll' || 
            game.players[game.currentPlayer].isAI || 
            game.winner !== null;
    }
    
    function showMessage(msg) {
        document.getElementById('message').textContent = msg;
    }
    
    function toggleRules() {
        document.getElementById('rulesContent').classList.toggle('show');
    }
    
    function newGame() {
        initGame();
    }
    
    // === CLICK HANDLING ===
    canvas.addEventListener('click', (e) => {
        if (game.phase !== 'move' || game.players[game.currentPlayer].isAI) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        // Find clicked piece
        for (const option of game.moveOptions) {
            const piece = option.piece;
            let pos;
            
            if (piece.state === 'base') {
                pos = game.substrate.getBasePosition(piece.playerId, piece.baseIndex);
            } else if (piece.state === 'fasttrack') {
                pos = game.substrate.getFastTrackPosition(piece.playerId);
            } else {
                pos = game.substrate.getTrackPosition(piece.position);
            }
            
            const dx = x - pos.x;
            const dy = y - pos.y;
            
            if (dx * dx + dy * dy < 400) { // 20px radius
                movePiece(option);
                return;
            }
        }
    });
    
    // === STARFIELD ===
    function initStarfield() {
        starCanvas.width = window.innerWidth;
        starCanvas.height = window.innerHeight;
        
        const stars = [];
        for (let i = 0; i < 150; i++) {
            stars.push({
                x: Math.random() * starCanvas.width,
                y: Math.random() * starCanvas.height,
                size: Math.random() * 2,
                speed: 0.2 + Math.random() * 0.5
            });
        }
        
        function animateStars() {
            starCtx.fillStyle = 'rgba(5, 5, 8, 0.1)';
            starCtx.fillRect(0, 0, starCanvas.width, starCanvas.height);
            
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > starCanvas.height) {
                    star.y = 0;
                    star.x = Math.random() * starCanvas.width;
                }
                
                starCtx.beginPath();
                starCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                starCtx.fillStyle = `rgba(136, 85, 255, ${0.3 + star.size * 0.3})`;
                starCtx.fill();
            });
            
            requestAnimationFrame(animateStars);
        }
        
        animateStars();
    }
    
    window.addEventListener('resize', () => {
        starCanvas.width = window.innerWidth;
        starCanvas.height = window.innerHeight;
    });
    
    // === START ===
    initStarfield();
    initGame();
    </script>
</body>
</html>

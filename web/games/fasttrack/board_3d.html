
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Fast Track â€” Play Free Online | 3D Board Game</title>
    <meta name="description" content="Play Fast Track free in your browser â€” a 3D card &amp; peg racing board game. Race around the board, take the Fast Track shortcut, capture opponents. 2-4 players, 7 themes, smart bots.">
    <meta name="keywords" content="fast track, board game, online game, free game, 3D board game, card game, multiplayer, peg racing">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://kensgames.com/fasttrack/board_3d.html">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Ken's Games">
    <meta property="og:title" content="Fast Track â€” Play Free Online">
    <meta property="og:description" content="Race your pegs around a stunning 3D board. Shortcuts, captures, 7 themes. Free â€” no download!">
    <meta property="og:url" content="https://kensgames.com/fasttrack/board_3d.html">
    <meta property="og:image" content="https://kensgames.com/fasttrack/assets/images/og-preview.png">
    <meta property="og:image:width" content="1527">
    <meta property="og:image:height" content="1024">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Fast Track â€” Free 3D Board Game">
    <meta name="twitter:description" content="Card &amp; peg racing for 2-4 players. 7 themes, smart bots. Play free now!">
    <meta name="twitter:image" content="https://kensgames.com/fasttrack/assets/images/og-preview.png">

    <!-- Gate: board_3d.html is the game board only. No session params = redirect to lobby -->
    <script>
        (function() {
            const p = new URLSearchParams(window.location.search);
            const hasGame = p.get('session') || p.get('code') || p.get('offline') || p.get('multiplayer') || p.get('demo') || p.get('spectate') || p.get('quickplay') || p.get('debug');
            if (!hasGame) {
                window.location.replace('lobby.html');
            }
        })();
    </script>

    <!-- ButterflyFX Analytics Substrate (GA4 + Dimensional Journey) -->
    <script src="analytics_substrate.js"></script>

    <!-- ButterflyFX SEO Substrate (JSON-LD + Breadcrumbs) -->
    <script src="seo_substrate.js"></script>

    <!-- ButterflyFX Growth Substrate (Viral Spiral Engine) -->
    <script src="growth_substrate.js"></script>
    
    <!-- PWA Manifest (for direct access) -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="assets/images/ftLogo.png">
    <link rel="apple-touch-icon" href="assets/images/ftLogo.png">
    
    <!-- Cache Control -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Responsive Game CSS -->
    <link rel="stylesheet" href="assets/css/responsive-game.css?v=20260223b">
    <link rel="stylesheet" href="assets/css/move-selection-modal.css?v=20260226">
    
    <!-- Global Error Handler -->
    <script>
        window.onerror = function(msg, src, line, col, err) {
            console.error('[FastTrack Error]', msg, 'at', src, line + ':' + col);
            return false;
        };
        window.addEventListener('unhandledrejection', function(e) {
            console.error('[FastTrack Promise]', e.reason);
        });
    </script>

    <!-- Mobile PWA CSS (loaded conditionally) -->
    <script>
        // ğŸŒŠ DIMENSIONAL: Mobile mode exists as potential, manifest CSS when observed
        const urlParams = new URLSearchParams(window.location.search);
        const MOBILE_MODE = urlParams.get('mobile') === 'true' ||
            window.innerWidth <= 768 ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Manifest mobile CSS (no if-statement needed)
        MOBILE_MODE && (() => {
            const mobileCSS = document.createElement('link');
            mobileCSS.rel = 'stylesheet';
            mobileCSS.href = 'assets/css/mobile.css';
            document.head.appendChild(mobileCSS);

            // Observe DOM ready, then manifest mobile class
            document.addEventListener('DOMContentLoaded', () =>
                document.body.classList.add('mobile-mode')
            );
        })();

        // ğŸŒŠ DIMENSIONAL: Manifest iframe notification when parent exists
        (window.parent !== window) && window.addEventListener('load', () =>
            window.parent.postMessage({ type: 'game-ready' }, '*')
        );
        
        // ========================================
        // PWA SUPPORT - Service Worker & Install
        // ========================================
        (function initPWA() {
            // FORCE purge old service workers and caches, then register fresh
            if ('serviceWorker' in navigator) {
                // First: unregister ALL existing service workers
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    const purgePromises = registrations.map(reg => reg.unregister());
                    return Promise.all(purgePromises);
                }).then(() => {
                    // Second: purge ALL caches
                    return caches.keys().then(names => Promise.all(names.map(n => caches.delete(n))));
                }).then(() => {
                    // Third: register the new v3 network-first SW
                    return navigator.serviceWorker.register('sw.js?v=3');
                }).then(reg => {
                    console.log('[PWA] Fresh SW v3 registered (network-first)');
                }).catch(err => console.log('[PWA] SW setup error:', err));
            }
            
            // Platform detection
            const platform = {
                isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
                isAndroid: /Android/.test(navigator.userAgent),
                isWindows: /Windows/.test(navigator.userAgent),
                isMac: /Mac/.test(navigator.userAgent),
                isStandalone: window.matchMedia('(display-mode: standalone)').matches ||
                              window.matchMedia('(display-mode: window-controls-overlay)').matches ||
                              window.navigator.standalone === true
            };
            
            // Don't show install prompts if already installed
            if (platform.isStandalone) {
                console.log('[PWA] Running as installed app');
                return;
            }
            
            let deferredPrompt = null;
            
            // Create install banner UI
            function createInstallBanner() {
                const banner = document.createElement('div');
                banner.id = 'pwa-install-banner';
                banner.innerHTML = `
                    <style>
                        #pwa-install-banner {
                            position: fixed;
                            bottom: 20px;
                            left: 50%;
                            transform: translateX(-50%) translateY(100px);
                            background: linear-gradient(135deg, rgba(30,30,60,0.98), rgba(50,50,80,0.98));
                            padding: 16px 24px;
                            border-radius: 16px;
                            border: 1px solid rgba(255,255,255,0.2);
                            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
                            z-index: 10100;
                            display: flex;
                            align-items: center;
                            gap: 16px;
                            opacity: 0;
                            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
                            backdrop-filter: blur(20px);
                            max-width: 90vw;
                        }
                        #pwa-install-banner.show {
                            transform: translateX(-50%) translateY(0);
                            opacity: 1;
                        }
                        #pwa-install-banner .icon { font-size: 36px; }
                        #pwa-install-banner .text { color: #fff; }
                        #pwa-install-banner .title { font-weight: 600; font-size: 15px; margin-bottom: 4px; }
                        #pwa-install-banner .subtitle { font-size: 12px; color: rgba(255,255,255,0.7); }
                        #pwa-install-banner .actions { display: flex; gap: 10px; margin-left: auto; }
                        #pwa-install-banner button {
                            padding: 10px 20px;
                            border: none;
                            border-radius: 10px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 13px;
                            transition: transform 0.2s, background 0.2s;
                        }
                        #pwa-install-banner button:hover { transform: scale(1.05); }
                        #pwa-install-banner .install-btn {
                            background: linear-gradient(135deg, #6366f1, #8b5cf6);
                            color: white;
                        }
                        #pwa-install-banner .dismiss-btn {
                            background: rgba(255,255,255,0.1);
                            color: rgba(255,255,255,0.8);
                        }
                        @media (max-width: 500px) {
                            #pwa-install-banner { flex-direction: column; text-align: center; gap: 12px; }
                            #pwa-install-banner .actions { margin-left: 0; }
                        }
                    </style>
                    <div class="icon">ğŸ®</div>
                    <div class="text">
                        <div class="title">Install Fast Track</div>
                        <div class="subtitle" id="install-subtitle">Play offline, faster loading</div>
                    </div>
                    <div class="actions">
                        <button class="dismiss-btn" onclick="window.dismissInstall()">Later</button>
                        <button class="install-btn" onclick="window.triggerInstall()">Install</button>
                    </div>
                `;
                document.body.appendChild(banner);
                return banner;
            }
            
            // Platform-specific instructions
            function updateInstructions() {
                const subtitle = document.getElementById('install-subtitle');
                if (!subtitle) return;
                
                if (platform.isIOS) {
                    subtitle.innerHTML = 'Tap <span style="font-size:16px">â¬†ï¸</span> Share â†’ Add to Home Screen';
                } else if (platform.isAndroid) {
                    subtitle.textContent = 'Add to home screen for quick access';
                } else if (platform.isWindows) {
                    subtitle.textContent = 'Install as Windows app';
                } else if (platform.isMac) {
                    subtitle.textContent = 'Install as Mac app';
                } else {
                    subtitle.textContent = 'Install as desktop app';
                }
            }
            
            // Show banner
            function showInstallBanner() {
                if (localStorage.getItem('pwa-install-dismissed-v2')) return;
                
                let banner = document.getElementById('pwa-install-banner');
                if (!banner) {
                    banner = createInstallBanner();
                }
                updateInstructions();
                
                setTimeout(() => banner.classList.add('show'), 100);
            }
            
            // Dismiss handler
            window.dismissInstall = function() {
                const banner = document.getElementById('pwa-install-banner');
                if (banner) banner.classList.remove('show');
                localStorage.setItem('pwa-install-dismissed-v2', 'true');
            };
            
            // Install trigger
            window.triggerInstall = async function() {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('[PWA] Install outcome:', outcome);
                    deferredPrompt = null;
                } else if (platform.isIOS) {
                    // iOS doesn't support beforeinstallprompt - show instructions
                    alert('To install:\n\n1. Tap the Share button â¬†ï¸\n2. Scroll down and tap "Add to Home Screen"\n3. Tap "Add"');
                }
                
                const banner = document.getElementById('pwa-install-banner');
                if (banner) banner.classList.remove('show');
            };
            
            // Listen for install prompt (Chrome/Edge/Android)
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                console.log('[PWA] Install prompt available');
                
                // Show banner after delay
                setTimeout(showInstallBanner, 5000);
            });
            
            // iOS: Show instructions after delay
            if (platform.isIOS) {
                setTimeout(showInstallBanner, 8000);
            }
            
            // Hide banner when installed
            window.addEventListener('appinstalled', () => {
                console.log('[PWA] App installed!');
                const banner = document.getElementById('pwa-install-banner');
                if (banner) banner.classList.remove('show');
                deferredPrompt = null;
            });
        })();
    </script>
    
    <link rel="stylesheet" href="assets/css/board-3d.css?v=20260223">
</head>
<body>
    <!-- Auth & Lobby UI Containers (hidden in dev mode) -->
    <div id="auth-container" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%); z-index: 9999; display: none; align-items: center; justify-content: center; padding: 10px;"></div>
    <div id="lobby-container" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%); z-index: 9998; display: none; padding: 10px; overflow: auto;"></div>
    
    <!-- Start Game Screen â€” Clean Mode Picker (single concern) -->
    <div id="start-game-screen">
        <h1>ğŸ¯ Fast Track</h1>
        <div class="subtitle">ButterflyFX Board Game</div>
        
        <!-- Mode Cards â€” one tap to proceed -->
        <div class="game-mode-selector">
            <div class="game-mode-btn" onclick="window.location.href='ai_setup.html'">
                <div class="mode-icon">ğŸ¤–</div>
                <div class="mode-name">Solo vs Bots</div>
                <div class="mode-desc">Choose avatar, difficulty &amp; play</div>
            </div>
            <div class="game-mode-btn" data-mode="quickmatch" onclick="selectGameMode('quickmatch')">
                <div class="mode-icon">âš¡</div>
                <div class="mode-name">Quick Match</div>
                <div class="mode-desc">Find players online</div>
            </div>
            <div class="game-mode-btn" data-mode="private" onclick="selectGameMode('private')">
                <div class="mode-icon">ğŸ”’</div>
                <div class="mode-name">Private Game</div>
                <div class="mode-desc">Invite friends with code</div>
            </div>
        </div>
        
        <!-- Matchmaking Status (hidden by default) -->
        <div id="matchmaking-status">
            <div class="match-spinner"></div>
            <div class="match-info">Finding players...</div>
            <div class="match-subinfo" id="match-queue-info">Looking for 2-3 more players</div>
            <button class="match-cancel-btn" onclick="cancelMatchmaking()">Cancel Search</button>
        </div>
        
        <!-- Private Game Section (hidden by default, clean 2-action layout) -->
        <div id="private-game-section">
            <h3 style="color: #f59e0b; margin-bottom: 15px;">ğŸ”’ Private Game</h3>
            
            <div id="private-create-section" style="margin-bottom: 20px;">
                <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label style="color: #ccc; font-size: 14px;">Max Players</label>
                        <select id="private-max-players" style="background: #1a1a2e; color: #fff; border: 1px solid #333; border-radius: 6px; padding: 6px 12px; font-size: 14px;">
                            <option value="2">2 Players</option>
                            <option value="3" selected>3 Players</option>
                            <option value="4">4 Players</option>
                            <option value="5">5 Players</option>
                            <option value="6">6 Players</option>
                        </select>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label style="color: #ccc; font-size: 14px;">Allow Bots</label>
                        <label class="toggle-switch" style="position:relative;width:44px;height:24px;">
                            <input type="checkbox" id="private-allow-bots" checked style="display:none;">
                            <span style="position:absolute;inset:0;background:#444;border-radius:12px;cursor:pointer;transition:.3s;" onclick="this.previousElementSibling.checked=!this.previousElementSibling.checked;this.style.background=this.previousElementSibling.checked?'#4ade80':'#444';">
                                <span style="position:absolute;top:2px;left:2px;width:20px;height:20px;background:#fff;border-radius:50%;transition:.3s;"></span>
                            </span>
                        </label>
                    </div>
                </div>
                <button class="private-btn create" onclick="createPrivateGame()">ğŸ® Create New Game</button>
            </div>
            
            <div style="margin-bottom: 15px; color: #888;">â€” or join with code â€”</div>
            <input type="text" class="join-code-input" id="join-code-input" placeholder="CODE" maxlength="6" />
            <div style="margin-top: 10px;">
                <button class="private-btn join" onclick="joinPrivateGame()">Join Game</button>
            </div>
        </div>
        
        <!-- Solo Setup HIDDEN â€” handled by ai_setup.html now -->
        <div id="solo-setup" style="display:none;"></div>
        
        <!-- Quick Match start button (shown only for quickmatch mode) -->
        <button id="start-btn" onclick="startGameSession()" disabled style="display:none; opacity: 0.5; cursor: not-allowed;">ğŸ” FIND MATCH</button>
        
        <div id="loading-status" class="loading-status">Loading board...</div>
    </div>
    
    <!-- Floating Rules Button â€” REMOVED (available in hamburger menu) -->
    
    <!-- Right-Hand Control Buttons (5 buttons with consistent styling) -->

    <!-- Camera Control Button -->
    <button id="camera-btn" onclick="openCameraPanel()" title="Camera Options">ğŸ“¹</button>

    <!-- Theme Button -->
    <button id="theme-btn" onclick="openThemePanel()" title="Change Theme">ğŸ¨</button>

    <!-- Music Toggle Button (Music only, not SFX) -->
    <button id="music-toggle-btn" onclick="toggleGameMusic()" title="Music: OFF">ğŸ”‡</button>

    <!-- Leave Game Button -->
    <button id="leave-game-btn" onclick="showExitConfirm()" title="Leave Game">ğŸšª</button>

    <!-- Fixed Views Button (persistent preset views) -->
    <button id="board-view-btn" onclick="setBoardViewMode()" title="Fixed Views">ğŸ¯</button>
    
    <!-- Exit Confirmation Modal -->
    <div id="exit-confirm-modal">
        <div id="exit-confirm-content">
            <h3>ğŸšª Exit Game?</h3>
            <p>If you leave, a bot will take over your pegs. The game will continue for other players.</p>
            <div class="exit-modal-btns">
                <button class="cancel-btn" onclick="hideExitConfirm()">Cancel</button>
                <button class="lobby-btn" onclick="exitToLobby()" style="background: #3498db;">ğŸ  Lobby</button>
                <button class="confirm-btn" onclick="confirmExitGame()">Exit Game</button>
            </div>
        </div>
    </div>
    
    <!-- Illegal Move Popup (Hard Mode) -->
    <div id="illegal-move-popup">
        <h3>ğŸš« Illegal Move!</h3>
        <p id="illegal-move-reason">That move is not allowed.</p>
        <button onclick="hideIllegalMovePopup()">OK</button>
    </div>
    
    <!-- Mom Introduction Modal -->
    <div id="mom-intro-modal">
        <div id="mom-intro-content">
            <div class="mom-avatar">ğŸ‘©</div>
            <h2>Hi, I'm Mom!</h2>
            <p>I'm your game guide and I'm here to help you learn Fast Track! 
            Whenever you need help, just click the <strong>Ask Mom</strong> button 
            and I'll give you tips and explain what you can do.</p>
            <button class="mom-btn" onclick="closeMomIntro()">Let's Play! ğŸ¯</button>
        </div>
    </div>
    
    <!-- Mom Help Panel -->
    <div id="mom-help-panel">
        <div class="mom-header">
            <div class="mom-title">
                <span>ğŸ‘©</span>
                <span>Mom says...</span>
            </div>
            <button class="close-btn" onclick="hideMomHelp()">Ã—</button>
        </div>
        <div class="mom-message" id="mom-message-text">
            I'm here to help!
        </div>
        <div class="mom-options" id="mom-options">
            <!-- Options will be populated dynamically -->
        </div>
    </div>
    
    <!-- Rules Modal (in-game) -->
    <div id="rules-modal">
        <div id="rules-modal-content">
            <button id="rules-modal-close" onclick="toggleRulesModal()">Ã—</button>
            <h3 style="color: #4ade80; margin-bottom: 15px;">ğŸ“œ Game Rules</h3>
            <ul style="list-style: none; padding: 0;">
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>ğŸ¯</span> Move all 5 pegs clockwise around the board into your safe zone to win
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>ğŸƒ</span> Ace, Joker, 6 = Enter from holding + extra turn
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>ğŸ‘‘</span> J, Q, K = Move 1 + extra turn + exit bullseye (only these 3!)
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>âš¡</span> Land exactly on a FastTrack hole to enter the shortcut loop
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>ğŸ±</span> Bullseye: Enter from FT with 1-step card; exit only with J/Q/K
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>â¬…ï¸</span> Card 4 = Back 4 spaces (can't enter FT, bullseye, or safe zone)
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>âœ¨</span> Card 7 = Wild card - move any token 1-7 spaces
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>ğŸ’¥</span> Land on opponent = Cut them back to holding
                </li>
                <li style="padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
                    <span>ğŸ”¥</span> FT pegs lose status if you move a non-FT peg instead
                </li>
                <li style="padding: 6px 0; display: flex; gap: 8px;">
                    <span>ğŸš«</span> Can't pass or land on your own peg
                </li>
            </ul>
        </div>
    </div>
    
    <!-- Tutorial Modal -->
    <div id="tutorial-modal">
        <div id="tutorial-content">
            <div class="tutorial-header">
                <h2>ğŸ“š How to Play Fast Track</h2>
                <p style="color: #888;">Master the game in minutes!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸ¯ Objective</h3>
                <p>Be the first to move all <strong>5 pegs</strong> from your holding area, around the board clockwise, and into your <strong>safe zone</strong>.</p>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸš€ Getting Started</h3>
                <ul>
                    <li>Click the <strong>deck</strong> to draw a card</li>
                    <li>Your pegs start in the <strong>holding area</strong> (off the track)</li>
                    <li>To enter the track, you need: <strong>Ace, 6, or Joker</strong></li>
                    <li>Once on track, move clockwise based on card values</li>
                </ul>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸƒ Card Effects</h3>
                <div class="card-chart">
                    <div class="card-row"><span class="card-value" style="color:#f00;">A</span><span class="card-effect">Enter track + Extra turn</span></div>
                    <div class="card-row"><span class="card-value">2-3</span><span class="card-effect">Move 2-3 spaces forward</span></div>
                    <div class="card-row"><span class="card-value" style="color:#ff6b6b;">4</span><span class="card-effect">Move 4 spaces BACKWARD</span></div>
                    <div class="card-row"><span class="card-value">5</span><span class="card-effect">Move 5 spaces forward</span></div>
                    <div class="card-row"><span class="card-value" style="color:#4ade80;">6</span><span class="card-effect">Enter track + Extra turn</span></div>
                    <div class="card-row"><span class="card-value" style="color:#ffd700;">7</span><span class="card-effect">Wild card - move any token 1-7 spaces</span></div>
                    <div class="card-row"><span class="card-value">8-10</span><span class="card-effect">Move 8-10 spaces forward</span></div>
                    <div class="card-row"><span class="card-value" style="color:#9400ff;">J/Q/K</span><span class="card-effect">Move 1 + Extra turn + Exit Bullseye</span></div>
                    <div class="card-row"><span class="card-value" style="color:#ff00ff;">Joker</span><span class="card-effect">Enter track + Extra turn</span></div>
                </div>
            </div>
            
            <div class="tutorial-section">
                <h3>âš¡ FastTrack Shortcut</h3>
                <ul>
                    <li>Land <strong>exactly</strong> on the FastTrack hole (marked âš¡)</li>
                    <li>Take the shortcut loop to skip ahead!</li>
                    <li>Strategic use can give you a huge advantage</li>
                </ul>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸ± Bullseye</h3>
                <ul>
                    <li>The center <strong>bullseye</strong> is a safe haven â€” you can't be cut there</li>
                    <li>Enter from <strong>FastTrack</strong> with a 1-step card (A, J, Q, K, Joker)</li>
                    <li>Exit <strong>only</strong> with <strong>J, Q, or K</strong> â€” Ace and Joker <em>cannot</em> exit!</li>
                    <li>Exit teleports you to your own FastTrack hole</li>
                </ul>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸ’¥ Cutting Opponents</h3>
                <ul>
                    <li>Land on an opponent's peg to <strong>cut</strong> them</li>
                    <li>Cut pegs return to their holding area (or home if holding is full)</li>
                    <li>You CANNOT cut pegs in safe zones or bullseye</li>
                    <li>You CANNOT pass or land on your own pegs</li>
                </ul>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸ”¥ FastTrack Tips</h3>
                <ul>
                    <li>FT pegs <strong>lose status</strong> if you move a different (non-FT) peg</li>
                    <li>Drawing a <strong>4</strong> forces your FT peg off the fast track</li>
                    <li>7 card is a wild card - move any token 1-7 spaces</li>
                </ul>
            </div>
            
            <div class="tutorial-section">
                <h3>ğŸ† Winning</h3>
                <ul>
                    <li>Fill all <strong>4 safe zone</strong> holes with your pegs</li>
                    <li>Then land the <strong>5th peg</strong> exactly on your winner hole</li>
                    <li>Safe zone = forward only, exact landing, protected from cuts</li>
                    <li>If stuck with no moves, your turn is skipped</li>
                </ul>
            </div>
            
            <button class="close-tutorial" onclick="hideTutorial()">Got it! Let's Play ğŸ¯</button>
        </div>
    </div>
    
    <!-- Private Game Lobby (Waiting Room) -->
    <div id="private-lobby">
        <div class="private-lobby-header">
            <h2>ğŸ”’ Private Game Lobby</h2>
            <p style="color: #888;">Share the code below to invite friends</p>
        </div>
        
        <!-- Share Section -->
        <div class="share-section">
            <div style="color: #888; font-size: 14px;">Your Game Code</div>
            <div class="share-code-display" id="private-share-code">------</div>
            
            <div class="share-url-box">
                <input type="text" class="share-url-input" id="private-share-url" readonly value="" />
                <button class="copy-btn" id="copy-url-btn" onclick="copyShareUrl()">ğŸ“‹ Copy</button>
            </div>
            
            <div style="color: #888; font-size: 13px; margin: 15px 0;">Share via:</div>
            <div class="social-share-btns">
                <button class="social-btn whatsapp" onclick="shareVia('whatsapp')">
                    <span>ğŸ“±</span> WhatsApp
                </button>
                <button class="social-btn telegram" onclick="shareVia('telegram')">
                    <span>âœˆï¸</span> Telegram
                </button>
                <button class="social-btn messenger" onclick="shareVia('messenger')">
                    <span>ğŸ’¬</span> Messenger
                </button>
                <button class="social-btn sms" onclick="shareVia('sms')">
                    <span>ğŸ“²</span> SMS
                </button>
                <button class="social-btn email" onclick="shareVia('email')">
                    <span>ğŸ“§</span> Email
                </button>
                <button class="social-btn copy-link" onclick="copyShareUrl()">
                    <span>ğŸ”—</span> Copy Link
                </button>
            </div>
        </div>
        
        <!-- Pending Join Requests (host only) -->
        <div id="pending-requests-section" style="display: none; margin: 15px 0;">
            <h4 style="color: #f59e0b; margin-bottom: 10px;">ğŸ“¥ Pending Requests</h4>
            <div id="pending-requests-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
        </div>
        
        <!-- Host Settings Panel -->
        <div id="lobby-host-settings" style="display: none; margin: 10px 0; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px;">
            <h4 style="color: #4ade80; margin-bottom: 10px; font-size: 14px;">âš™ï¸ Host Settings</h4>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="private-btn" id="add-ai-btn" onclick="addAIPlayer()" style="font-size: 12px; padding: 6px 14px; background: #2563eb;">ğŸ¤– Add Bot</button>
                <button class="private-btn" id="toggle-music-all-btn" onclick="toggleMusicForAll()" style="font-size: 12px; padding: 6px 14px; background: #7c3aed;">ğŸµ Music: ON</button>
            </div>
        </div>
        
        <!-- Players Waiting -->
        <div style="text-align: center; margin: 10px 0;">
            <h3 style="color: #fff;">Players (<span id="player-count">1</span>/<span id="max-player-count">4</span>)</h3>
        </div>
        <div class="players-waiting" id="players-waiting">
            <!-- Dynamically populated -->
        </div>
        
        <!-- My Ready Toggle -->
        <div style="text-align: center; margin: 15px 0;">
            <button id="my-ready-btn" onclick="toggleMyReady()" style="padding: 12px 32px; border-radius: 10px; border: 2px solid #666; background: rgba(100,100,100,0.3); color: #aaa; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                â¬œ Not Ready
            </button>
        </div>
        
        <!-- Chat -->
        <div class="private-chat">
            <div class="chat-header">ğŸ’¬ Game Chat</div>
            <div class="chat-messages" id="private-chat-messages">
                <div class="chat-message system">Welcome to the private lobby! Chat with your friends here.</div>
            </div>
            <div class="chat-input-area">
                <input type="text" class="chat-input" id="private-chat-input" placeholder="Type a message..." maxlength="200" onkeypress="if(event.key==='Enter')sendPrivateChat()" />
                <button class="chat-send-btn" onclick="sendPrivateChat()">Send</button>
            </div>
        </div>
        
        <!-- Actions -->
        <div class="lobby-actions">
            <button class="lobby-action-btn" onclick="toggleRulesModal()" style="background: rgba(74,222,128,0.15); color: #4ade80; border: 1px solid rgba(74,222,128,0.3);">ğŸ“œ Rules</button>
            <button class="lobby-action-btn leave" onclick="leavePrivateLobby()">Leave</button>
            <button class="lobby-action-btn start-game" id="start-private-game-btn" onclick="startPrivateGame()" disabled>
                Start Game (Waiting for ready...)
            </button>
        </div>
    </div>
    
    <!-- Move Announcement Indicator -->
    <div id="ai-thinking" class="ai-thinking">
        ğŸ² <span id="ai-name">Player</span> <span id="move-info">moving</span><span class="dots"></span>
    </div>
    
    <!-- Turn Action Banner -->
    <div id="turn-action-banner">
        <div class="banner-title" id="banner-title">Player's Turn</div>
        <div class="banner-subtitle" id="banner-subtitle">Please draw a card</div>
        <div class="banner-card-display" id="banner-card-display" style="display: none;"></div>
        <button class="banner-btn primary" id="banner-action-btn" style="display: none;" onclick="handleBannerAction()">Make Move</button>
    </div>
    
    <!-- Turn Timer â€” REMOVED -->
    
    <!-- Pause Button â€” REMOVED -->
    
    <!-- Game Controls Bar â€” Leave/Rules REMOVED (available in hamburger menu) -->
    <div id="game-controls-bar">
        <button id="organizer-menu-btn" onclick="toggleOrganizerMenu()" title="Host Controls" style="display: none;">
            ğŸ‘‘
            <span id="join-request-badge" class="join-request-badge" style="display: none;">0</span>
        </button>
    </div>
    
    <!-- Turn Timer Display -->
    <div id="turn-timer-display" style="display: none;">
        <div id="turn-timer-label">Time Remaining</div>
        <div id="turn-timer-countdown">1:00</div>
        <div id="turn-timer-warning" style="display: none;">âš ï¸ Make your move!</div>
    </div>
    
    <!-- Leave Game Modal -->
    <div id="leave-game-modal" style="display: none;">
        <div class="leave-game-content">
            <h3>ğŸšª Leave Game?</h3>
            <p id="leave-game-message">Your position will be replaced by a bot until you return.</p>
            <div class="leave-game-buttons">
                <button class="leave-btn-cancel" onclick="closeLeaveGameModal()">Cancel</button>
                <button class="leave-btn-confirm" onclick="confirmLeaveGame()">Leave Game</button>
            </div>
        </div>
    </div>
    
    <!-- Return to Game Banner (shown when player has left but can return) -->
    <div id="return-game-banner" style="display: none;">
        <div class="return-content">
            <span>ğŸ¤– A bot is playing for you</span>
            <button onclick="returnToGame()">â†©ï¸ Return to Game</button>
        </div>
    </div>
    
    <!-- Game Chat Toggle Button (for minimized chat) -->
    <button id="game-chat-toggle" class="game-chat-toggle-btn" onclick="toggleGameChat()">
        ğŸ’¬
        <span class="unread-badge" id="chat-unread-badge" style="display: none;">0</span>
    </button>
    
    <!-- Game Chat Panel (Tournament/Guild games) -->
    <div id="game-chat-panel">
        <div class="game-chat-header" onclick="minimizeGameChat()">
            <span>ğŸ’¬ Game Chat</span>
            <div class="game-chat-header-actions">
                <button onclick="event.stopPropagation(); showGameChatSettings()" title="Chat Settings">âš™ï¸</button>
                <button onclick="event.stopPropagation(); minimizeGameChat()" title="Minimize">âˆ’</button>
            </div>
        </div>
        
        <!-- Chat disabled notice -->
        <div id="game-chat-disabled" class="game-chat-disabled" style="display: none;">
            ğŸ”‡ Chat disabled
        </div>
        
        <!-- Chat opted out notice -->
        <div id="game-chat-opted-out" class="game-chat-disabled" style="display: none;">
            ğŸ”• You have opted out of chat
            <button onclick="toggleGameChatOptOut()" style="margin-top: 10px; padding: 5px 15px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.3); background: none; color: #fff; cursor: pointer;">Re-enable</button>
        </div>
        
        <!-- Active chat area -->
        <div id="game-chat-active">
            <div id="game-chat-messages">
                <div style="text-align: center; color: rgba(255,255,255,0.4); font-size: 12px; padding: 20px;">No messages yet</div>
            </div>
            <div class="game-chat-input-area">
                <input type="text" id="game-chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter')sendGameChatMessage()">
                <button class="game-chat-send-btn" onclick="sendGameChatMessage()">Send</button>
            </div>
        </div>
    </div>
    
    <!-- Game Chat Settings Modal -->
    <div id="game-chat-settings-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 9500; align-items: center; justify-content: center;">
        <div style="background: linear-gradient(135deg, rgba(30,40,60,0.98), rgba(20,25,40,0.99)); border: 1px solid rgba(100,200,255,0.3); border-radius: 15px; padding: 20px; max-width: 350px; width: 90%;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #64d8ff; margin: 0;">âš™ï¸ Chat Settings</h3>
                <button onclick="hideGameChatSettings()" style="background: none; border: none; color: #fff; font-size: 20px; cursor: pointer;">Ã—</button>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 10px;">
                <div>
                    <div style="color: #fff; font-weight: 500;">Opt Out of Chat</div>
                    <div style="font-size: 12px; color: rgba(255,255,255,0.5);">Hide all messages</div>
                </div>
                <button id="game-chat-opt-btn" onclick="toggleGameChatOptOut()" style="padding: 8px 15px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold;">
                    ğŸ”‡ Opt Out
                </button>
            </div>
            
            <button onclick="showGameBlockedUsers()" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; cursor: pointer; text-align: left;">
                ğŸš« Manage Blocked Users
            </button>
        </div>
    </div>
    
    <!-- Organizer Menu (Host Controls) -->
    <div id="organizer-menu" style="display: none;">
        <div class="organizer-menu-header">
            <span>ğŸ‘‘ Host Controls</span>
            <button onclick="closeOrganizerMenu()">Ã—</button>
        </div>
        
        <!-- Join Requests Section -->
        <div id="join-requests-section" class="join-requests-section" style="display: none;">
            <div class="join-requests-header">
                <span>ğŸ“¥</span>
                <span>Join Requests</span>
            </div>
            <div id="join-requests-list"></div>
        </div>
        
        <!-- Players List -->
        <div id="organizer-player-list"></div>
    </div>
    
    <!-- Join Request Notification Popup -->
    <div id="join-request-notification">
        <div class="join-notify-header">
            <span>ğŸ“¥</span>
            <span>Join Request</span>
        </div>
        <div class="join-notify-player">
            <span class="join-notify-avatar" id="join-notify-avatar">ğŸ‘¤</span>
            <span class="join-notify-name" id="join-notify-name">Player Name</span>
        </div>
        
        <!-- Slot Assignment Options (shown when both options available) -->
        <div id="join-slot-options" style="display: none; margin-bottom: 15px;">
            <div style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">Assign to:</div>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <label id="join-replace-bot-option" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(100,200,255,0.1); border-radius: 8px; cursor: pointer; border: 1px solid transparent;">
                    <input type="radio" name="join-slot-type" value="replace-bot" checked style="width: 16px; height: 16px;">
                    <span>ğŸ¤– Replace a bot</span>
                </label>
                <label id="join-new-slot-option" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(100,200,255,0.1); border-radius: 8px; cursor: pointer; border: 1px solid transparent;">
                    <input type="radio" name="join-slot-type" value="new-slot" style="width: 16px; height: 16px;">
                    <span>â• New slot (start fresh)</span>
                </label>
            </div>
        </div>
        
        <!-- Slot info (when only one option) -->
        <div id="join-slot-info" style="display: none; font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 15px; text-align: center;"></div>
        
        <div class="join-notify-buttons">
            <button class="join-notify-deny" onclick="denyJoinRequest()">Deny</button>
            <button class="join-notify-approve" onclick="approveJoinRequest()">âœ“ Approve</button>
        </div>
    </div>
    
    <!-- Pause Overlay -->
    <div id="pause-overlay">
        <div class="pause-title">â¸ï¸ GAME PAUSED</div>
        <div class="pause-timer" id="pause-timer">5:00</div>
        <div class="pause-message">Return within 5 minutes or game will resume automatically</div>
        
        <!-- Settings Section -->
        <div class="pause-settings">
            <div class="setting-row">
                <label for="auto-move-toggle">Auto-move when only one choice:</label>
                <input type="checkbox" id="auto-move-toggle" checked onchange="toggleAutoMove(this.checked)">
                <span class="toggle-label" id="auto-move-label">ON</span>
            </div>
        </div>
        
        <button class="resume-btn" onclick="resumeGame()">â–¶ï¸ Resume Game</button>
    </div>
    
    <!-- Peg Move Dropdown -->
    <div id="peg-move-dropdown">
        <div class="dropdown-header">
            <span class="dropdown-title">Choose Destination</span>
            <button class="dropdown-close" onclick="hidePegMoveDropdown()" title="Close (Esc)">Ã—</button>
        </div>
        <div id="dropdown-items"></div>
    </div>

    <!-- Move Choice Modal (prominent popup for multiple moves) -->
    <div id="move-choice-modal" onclick="if(event.target===this)hideMoveChoiceModal()">
        <div class="modal-card">
            <div class="modal-header" style="position:relative;">
                <div class="modal-title" id="choice-modal-title">Choose Your Move</div>
                <div class="modal-subtitle" id="choice-modal-subtitle"></div>
                <button onclick="hideMoveChoiceModal()" style="position:absolute;top:6px;right:10px;background:none;border:none;color:#aaa;font-size:22px;cursor:pointer;padding:4px 8px;line-height:1;" title="Close and pick manually">&times;</button>
            </div>
            <div id="choice-modal-items"></div>
            <div style="text-align:center;padding:8px 0 4px;border-top:1px solid rgba(255,255,255,0.1);margin-top:4px;">
                <button onclick="hideMoveChoiceModal()" style="background:none;border:1px solid #666;color:#aaa;border-radius:6px;padding:5px 14px;cursor:pointer;font-size:12px;">Inspect board &amp; pick manually</button>
            </div>
        </div>
    </div>
    
    <!-- Bot Replacement Alert -->
    <div id="bot-alert">
        <div class="alert-icon">ğŸ¤–</div>
        <div class="alert-title" id="bot-alert-title">Player Replaced</div>
        <div class="alert-message" id="bot-alert-message">A player has been replaced with a bot</div>
    </div>
    
    <!-- Game UI -->
    <div id="player-panels" style="position: fixed; top: 0; left: 0; right: 0; justify-content: center; gap: 30px; padding: 10px; background: linear-gradient(180deg, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0) 100%); z-index: 10001; flex-wrap: wrap;"></div>
    <div id="player-cube-container" style="display: none;"></div>
    
    <div id="container"></div>
    
    <!-- Responsive CSS for desktop vs mobile -->
    
    <!-- Floating Draggable Reaction Bar -->
    <div id="floating-reactions" class="floating-reactions-bar">
        <div class="reactions-handle" id="reactions-handle">â‹®â‹®</div>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ˜±', 'shock')" title="Shock">ğŸ˜±</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ‘', 'clap')" title="Well played">ğŸ‘</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ˜¬', 'ouch')" title="Ouch">ğŸ˜¬</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ˜ˆ', 'revenge')" title="Revenge">ğŸ˜ˆ</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ”¥', 'fire')" title="On fire">ğŸ”¥</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ˜­', 'cry')" title="Sad">ğŸ˜­</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ‰', 'celebrate')" title="Celebrate">ğŸ‰</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ’€', 'dead')" title="Dead">ğŸ’€</button>
        <button class="reaction-btn-desktop" onclick="sendDesktopReaction('ğŸ‘»', 'boo')" title="Boo">ğŸ‘»</button>
    </div>
    
    <!-- Suggestions Toggle Button -->
    <button id="suggestions-toggle" onclick="toggleSuggestions()" title="Toggle move suggestion popups on/off" style="
        position: fixed; bottom: 16px; left: 16px; z-index: 10002;
        background: rgba(30,30,50,0.9); color: #ffd700; border: 2px solid #ffd700;
        border-radius: 8px; padding: 6px 12px; font-size: 13px; cursor: pointer;
        font-family: inherit; backdrop-filter: blur(4px); transition: all 0.2s;
        box-shadow: 0 2px 10px rgba(0,0,0,0.4);
    ">ğŸ’¡ Suggestions ON</button>

    <div id="info">
        <div>Drag to rotate | Scroll to zoom</div>
        <div id="stats" style="margin-top: 8px; font-size: 11px; color: #aaa;"></div>
    </div>

    <!-- jQuery (for reliable DOM ready handling) -->
    <script src="assets/js/jquery-3.7.1.min.js"></script>

    <!-- Three.js -->
    <script src="assets/js/three.min.js"></script>
    <script src="assets/js/OrbitControls.js"></script>

    <!-- Fibonacci Spiral Backdrop for Board View -->
    <script src="fibonacci_backdrop.js?v=20260228"></script>

    <!-- ğŸŒŠ DIMENSIONAL PROGRAMMING CORE SUBSTRATES -->
    <!-- "Everything exists. Only observation manifests reality." -->
    <script src="observation_substrate.js?v=20260228"></script>
    <script src="intent_manifold.js?v=20260228"></script>
    <script src="potential_substrate.js?v=20260228"></script>

    <!-- FastTrack Substrates -->
    <script src="themes.js?v=20260225c"></script>
    <script src="themes/vr_immersive.js?v=20260227"></script>
    <script src="avatar_substrate.js?v=20260223"></script>
    <script src="social_substrate.js?v=20260223"></script>
    <script src="security.js?v=20260227"></script>
    <script src="auth_substrate.js?v=20260227"></script>
    <script src="admin_substrate.js?v=20260223"></script>
    <script src="game_session_manager.js?v=20260223"></script>
    <script src="lobby_substrate.js?v=20260223"></script>
    <script src="game_ui_minimal.js?v=20260225c"></script>
    <!-- BoardManifold: Every hole, card, peg, rule on z=xy / z=xyÂ² surfaces -->
    <script src="board_manifold.js?v=20260223"></script>
    <!-- ValidationSubstrate: Universal validation - zero duplication -->
    <script src="validation_substrate.js?v=20260226"></script>
    <!-- EventSubstrate: Universal event management - zero duplication -->
    <script src="event_substrate.js?v=20260226"></script>
    <!-- StateSubstrate: Universal state management - zero duplication -->
    <script src="state_substrate.js?v=20260226"></script>
    <!-- ArraySubstrate: Dimensional array operations - zero duplication -->
    <script src="array_substrate.js?v=20260226"></script>
    <!-- SubstrateManifold: Meta-substrate - substrates as points on manifold -->
    <script src="substrate_manifold.js?v=20260226"></script>
    
    <!-- Dimensional Game Engine Substrates -->
    <script src="move_generation_substrate.js?v=20260226"></script>
    <script src="card_logic_substrate.js?v=20260226"></script>
    <script src="ui_manifold.js?v=20260226"></script>
    <script src="ai_manifold.js?v=20260226"></script>
    <script src="game_engine_manifold.js?v=20260226"></script>
    
    <!-- Test Suite -->
    <script src="test_fasttrack_rules.js?v=20260226"></script>
    
    <script src="manifold_ai.js?v=20260223"></script>
    <!-- Unified Game Initialization System -->
    <script src="game_init.js?v=20260223"></script>
    <script src="mobile_ui.js?v=20260223"></script>
    <script src="mobile_dimensional_fixes.js?v=20260228"></script>
    <!-- Advanced Mobile Touch Engine (NEW) -->
    <script src="mobile_touch_engine.js?v=20260228"></script>
    <!-- ğŸŒŠ Meta Quest VR - Entangled Substrate Protocol (ESP) -->
    <script src="vr_esp.js?v=20260228"></script>
    <script src="move_selection_modal.js?v=20260226"></script>
    <script src="lobby_ui.js?v=20260223"></script>
    <script src="auth_ui.js?v=20260223"></script>
    
    <!-- Card Game System -->
    <script src="card_deck_substrate.js?v=20260223"></script>
    <script src="game_state_broadcaster.js?v=20260223"></script>
    <!-- card_ui.js REMOVED â€” using compact GameUIMinimal panel -->
    <script src="peg_substrate.js?v=20260223"></script>
    <script src="smart_peg.js?v=20260223"></script>
    <!-- ButterflyFX Natural Lens System -->
    <script src="natural_lens.js?v=20260223"></script>
    <!-- Stadium Audio System -->
    <script src="music_substrate.js?v=20260225b"></script>
    <script src="crowd_substrate.js?v=20260223"></script>
    <script src="commentary_substrate.js?v=20260223"></script>
    <script src="audio_substrate.js?v=20260223"></script>
    <script src="stadium_controller.js?v=20260223"></script>
    <!-- Game Sound Effects -->
    <script src="game_sfx.js?v=20260225"></script>
    <script src="game_engine.js?v=20260225"></script>
    <script src="victory_ceremony.js?v=20260225"></script>
    
    <!-- Multiplayer & Prestige Systems -->
    <script src="prestige.js?v=20260223"></script>
    <script src="multiplayer_client.js?v=20260223"></script>
    <script src="avatars.js?v=20260223"></script>

    <!-- Tutorial & Ask Mom Advisor -->
    <script src="tutorial.js?v=20260225"></script>
    <script src="ask_mom.js?v=20260225"></script>
    <script src="mom_daemon.js?v=20260227"></script>
    <script src="board_tooltips.js?v=20260225"></script>

    <script>
    // ============================================================
    // FAST TRACK 3D - BUTTERFLYFX MANIFOLD SUBSTRATE
    // Complete game board with hole registry and peg system
    // ============================================================

    let scene, camera, renderer, controls;
    let boardGroup, pegGroup;
    
    // References for theme color updates
    let boardMesh = null;
    let borderSegments = [];
    let coloredMarkers = [];  // {mesh, playerIndex} for pentagons, diamonds, circles, rings
    let currentBoardPalette = null;

    // ============================================================
    // GOLDEN RATIO PROPORTIONS (Ï† = 1.618033988749895)
    // All dimensions cascade from a base unit using Ï†
    // ============================================================
    // PHI is already declared globally by external substrates
    const BASE_UNIT = 5;  // Fundamental unit

    // Board dimensions (anchor point)
    const BOARD_RADIUS = 300;
    
    // Golden cascade: each level = previous Ã— Ï†
    // Level 1: 5 Ã— Ï† = 8.09 â†’ 8
    // Level 2: 8 Ã— Ï† = 12.94 â†’ 13
    // Level 3: 13 Ã— Ï† = 21.03 â†’ 21
    // Level 4: 21 Ã— Ï† = 34.0 â†’ 34
    const LEVEL_1 = Math.round(BASE_UNIT * PHI);           // 8
    const LEVEL_2 = Math.round(LEVEL_1 * PHI);             // 13
    const LEVEL_3 = Math.round(LEVEL_2 * PHI);             // 21
    const LEVEL_4 = Math.round(LEVEL_3 * PHI);             // 34

    // Hole dimensions (Level 1)
    const HOLE_RADIUS = LEVEL_1;                           // 8
    const TRACK_HOLE_RADIUS = LEVEL_1;                     // 8
    const CENTER_HOLE_RADIUS = LEVEL_1;                    // 8

    // Marker/ring dimensions (Level 2)
    const RING_WIDTH = LEVEL_2;                            // 13
    const DIAMOND_SIZE = LEVEL_2;                          // 13
    const LINE_HEIGHT = 15;                                // Above board surface (board top ~13.5 with bevel)
    const BORDER_WIDTH = LEVEL_2;                          // 13

    // Larger elements (Level 3)
    const PENTAGON_SIZE = LEVEL_3;                         // 21
    const BOARD_THICKNESS = LEVEL_3;                       // 21

    // Largest elements (Level 4)
    const HOLDING_CIRCLE_RADIUS = LEVEL_4;                 // 34
    const HOLDING_HOLE_SPACING = LEVEL_3;                  // 21

    // Peg dimensions derived from HOLE_RADIUS using Ï†
    const PEG_BOTTOM_RADIUS = LEVEL_1;                     // 8
    const PEG_TOP_RADIUS = Math.round(LEVEL_1 / PHI);      // 5
    const PEG_HEIGHT = LEVEL_4;                            // 34
    const PEG_DOME_RADIUS = LEVEL_1;                       // 8

    // Border height
    const BORDER_HEIGHT = BOARD_THICKNESS + LEVEL_1;       // 29

    // Key radii calculations using golden ratio
    const outerRadius = BOARD_RADIUS * Math.cos(Math.PI / 6);      // ~259.8 (geometric)
    const innerRadius = Math.round(outerRadius / (PHI * PHI));     // ~99 (Ï†Â² relationship)
    const innerHexRadius = innerRadius / Math.cos(Math.PI / 6);    // ~114
    const wedgeFactor = 0.85;                                      // Visual balance (geometric)

    // Maximally distinct player colors â€” no two are close
    const RAINBOW_COLORS = [
        0xff2020, // Red
        0x2196ff, // Blue
        0x4caf50, // Green
        0xffeb3b, // Yellow
        0xff9800, // Orange
        0x9c27b0  // Purple
    ];
    const COLORS = RAINBOW_COLORS;  // Alias for convenience

    const PLAYER_NAMES = ['Red', 'Blue', 'Green', 'Yellow', 'Orange', 'Purple'];

    // Track safe zone planes for theme color updates
    const safeZonePlanes = [];

    // ============================================================
    // MANIFOLD SUBSTRATE: Hole Registry (ButterflyFX)
    // Each hole has identity, type, position, and relationships
    // ============================================================
    
    const holeRegistry = new Map();  // id -> HoleObject
    const pegRegistry = new Map();   // id -> PegObject
    
    // Active player count - only create pegs/decks for this many players
    let activePlayerCount = 3;  // Default: 1 human + 2 AI (indices 0, 1, 2)
    
    // Export to window for game engine access
    window.holeRegistry = holeRegistry;
    window.pegRegistry = pegRegistry;

    // ============================================================
    // HOLE PROPERTY TAGGING SYSTEM
    // Based on FastTrack Universal Specification
    // A hole can have multiple roles/properties
    // ============================================================
    
    // Helper function to normalize hole type (side-left/side-right â†’ outer)
    function getNormalizedHoleType(holeId) {
        if (!holeId) return 'unknown';
        if (holeId === 'center') return 'center';
        if (holeId.startsWith('hold-')) return 'holding';
        if (holeId.startsWith('home-')) return 'home';
        if (holeId.startsWith('ft-')) return 'fasttrack';
        if (holeId.startsWith('safe-')) return 'safezone';
        if (holeId.startsWith('outer-') || holeId.startsWith('side-')) return 'outer';
        return 'unknown';
    }
    
    function createHole(id, type, playerIndex, x, y, z, marker = null, properties = {}) {
        const hole = {
            id: id,
            type: type,
            playerIndex: playerIndex,
            position: { x: x, y: y, z: z },
            radius: TRACK_HOLE_RADIUS,
            occupied: false,
            occupiedBy: null,
            marker: marker,
            mesh: null,
            connections: [],
            // Property tags - a hole can have multiple roles
            properties: {
                isHoldingExit: properties.isHoldingExit || false,      // Holding pen exit (also winner hole)
                isWinnerHole: properties.isWinnerHole || false,        // Where 5th peg wins
                isSafeZoneEntry: properties.isSafeZoneEntry || false,  // Pivot point before safe zone
                isSafeZone: properties.isSafeZone || false,            // Inside safe zone
                isFastTrack: properties.isFastTrack || false,          // FastTrack ring hole
                isFastTrackEntry: properties.isFastTrackEntry || false,// Can enter FastTrack from here
                isFastTrackExit: properties.isFastTrackExit || false,  // Player's own FT hole (exit point)
                isBullseye: properties.isBullseye || false,            // Center bullseye
                isOuterTrack: properties.isOuterTrack || false         // Regular perimeter track
            }
        };
        holeRegistry.set(id, hole);
        // Debug: Log first few holes
        if (holeRegistry.size <= 3) {
            console.log('ğŸ•³ï¸ Created hole:', id, 'Registry size:', holeRegistry.size, 'Props:', hole.properties);
        }
        return hole;
    }

    // Color names for player areas
    const COLOR_NAMES = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Purple'];
    
    // Get peg number from id (peg-X-4 = #1, peg-X-0 = #2, etc)
    function getPegNumber(pegId) {
        const match = pegId.match(/peg-(\d+)-(\d+)/);
        if (!match) return 0;
        const pegIdx = parseInt(match[2]);
        // peg-X-4 (starts on home) = #1, then 0-3 = #2-5 in order they leave holding
        return pegIdx === 4 ? 1 : pegIdx + 2;
    }
    
    // Get color name by board position
    function getColorName(boardPosition) {
        return COLOR_NAMES[boardPosition] || 'Unknown';
    }
    
    // Get peg label like "Red 1" or "Blue 3"
    function getPegLabel(pegId, boardPosition) {
        const num = getPegNumber(pegId);
        const color = getColorName(boardPosition);
        return `${color} ${num}`;
    }
    
    // â”€â”€ Friendly hole name helper â”€â”€
    // Converts raw hole IDs to simple, human-readable descriptions
    function friendlyHoleName(holeId) {
        if (!holeId) return 'Unknown';

        // Helper: get player name or color from board position in hole ID
        function ownerOf(boardPos) {
            if (gameState && gameState.players) {
                const owner = gameState.players.find(p => p.boardPosition == boardPos);
                if (owner) return owner.name;
            }
            return COLOR_NAMES[boardPos] || 'Player';
        }

        // Bullseye / Center
        if (holeId === 'center') return 'the Bullseye';

        // Holding area
        if (holeId.startsWith('hold-')) return 'Holding Area';

        // Home hole â€” say whose
        if (holeId.startsWith('home-')) {
            const bp = parseInt(holeId.split('-')[1]);
            return `${ownerOf(bp)}'s Home Hole`;
        }

        // Safe zone â€” say whose and which slot
        if (holeId.startsWith('safe-')) {
            const parts = holeId.split('-');
            const bp = parseInt(parts[1]);
            const num = parts[2];
            return `${ownerOf(bp)}'s Safe Zone #${num}`;
        }

        // FastTrack corners
        if (holeId.startsWith('ft-')) {
            const bp = parseInt(holeId.split('-')[1]);
            return `${COLOR_NAMES[bp] || ''} FastTrack corner`;
        }

        // Outer track â€” check for safe zone gateway
        if (holeId.startsWith('outer-')) {
            const parts = holeId.split('-');
            const bp = parseInt(parts[1]);
            const idx = parseInt(parts[2]);
            if (idx === 2) return `${ownerOf(bp)}'s Safe Zone Gateway`;
            return 'the perimeter track';
        }

        // Side tracks
        if (holeId.startsWith('side-')) return 'the perimeter track';

        return holeId;
    }

    // Create a floating number sprite for a peg
    function createPegNumberSprite(number, pegColor) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // Draw circle background
        ctx.beginPath();
        ctx.arc(32, 32, 28, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw number
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(number.toString(), 32, 34);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            depthTest: false
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(15, 15, 1);
        return sprite;
    }
    
    // Show number labels on pegs that have choices
    function showPegNumbers(pegIds) {
        pegIds.forEach(pegId => {
            const peg = pegRegistry.get(pegId);
            if (peg && peg.numberSprite) {
                peg.numberSprite.visible = true;
            }
        });
    }
    
    // Hide all peg number labels
    function hidePegNumbers() {
        pegRegistry.forEach(peg => {
            if (peg.numberSprite) {
                peg.numberSprite.visible = false;
            }
        });
    }

    function createPeg(id, playerIndex, holeId, colorIndex = null) {
        // Use colorIndex if provided, otherwise fall back to playerIndex
        // Use themed colors if available, fallback to RAINBOW_COLORS
        const colorIdx = colorIndex !== null ? colorIndex : playerIndex;
        const color = (currentBoardPalette && currentBoardPalette.playerColors) 
            ? currentBoardPalette.playerColors[colorIdx] 
            : RAINBOW_COLORS[colorIdx];
        const hole = holeRegistry.get(holeId);
        const pegNumber = getPegNumber(id);
        
        // Create peg group to hold body + flat top
        const pegGroup = new THREE.Group();
        
        // Tapered cylinder body (Light Bright style)
        const bodyGeo = new THREE.CylinderGeometry(
            PEG_TOP_RADIUS, PEG_BOTTOM_RADIUS, PEG_HEIGHT, 32
        );
        
        // Translucent glowing body material
        const bodyMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.2,
            metalness: 0.3,
            emissive: color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.85
        });
        
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        bodyMesh.position.y = PEG_HEIGHT / 2;
        pegGroup.add(bodyMesh);
        
        // Flat glowing disc top
        const discGeo = new THREE.CylinderGeometry(PEG_DOME_RADIUS, PEG_DOME_RADIUS, 3, 32);
        
        // Flat top material - same color as body
        const discMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.2,
            metalness: 0.3,
            emissive: color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.85
        });
        
        const discMesh = new THREE.Mesh(discGeo, discMat);
        discMesh.position.y = PEG_HEIGHT + 1.5;
        discMesh.castShadow = true;
        pegGroup.add(discMesh);

        // Add invisible touch zone to increase clickable area for pegs (helps mobile)
        try {
            const touchGeo = new THREE.CylinderGeometry(PEG_DOME_RADIUS * 2.8, PEG_DOME_RADIUS * 2.8, 6, 24);
            const touchMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
            const touchMesh = new THREE.Mesh(touchGeo, touchMat);
            touchMesh.position.y = PEG_HEIGHT + 1.5;
            touchMesh.name = 'peg-touch-zone';
            // Make sure it doesn't cast/receive shadows or affect visuals
            touchMesh.castShadow = false;
            touchMesh.receiveShadow = false;
            pegGroup.add(touchMesh);
            peg.touchMesh = touchMesh;
        } catch (e) {
            console.warn('[createPeg] touch zone creation failed', e);
        }
        
        // Position on top of hole
        if (hole) {
            pegGroup.position.set(hole.position.x, hole.position.y + 2, hole.position.z);
            hole.occupied = true;
            hole.occupiedBy = id;
        }
        
        // Create number label sprite (hidden by default)
        const numberSprite = createPegNumberSprite(pegNumber, color);
        numberSprite.position.y = PEG_HEIGHT + 20; // Above the peg
        numberSprite.visible = false;
        pegGroup.add(numberSprite);
        
        const peg = {
            id: id,
            playerIndex: playerIndex,
            colorIndex: colorIdx,  // Board position index for matching area colors
            pegNumber: pegNumber,  // 1-5, order they leave holding
            color: color,
            currentHole: holeId,
            mesh: pegGroup,
            bodyMesh: bodyMesh,
            discMesh: discMesh,
            numberSprite: numberSprite
        };
        
        pegRegistry.set(id, peg);
        // Add peg group to global pegGroup container if present so raycasts against boardGroup/pegGroup find them
        try {
            if (typeof window.pegGroup !== 'undefined' && window.pegGroup && window.pegGroup.add) {
                window.pegGroup.add(pegGroup);
            } else {
                scene.add(pegGroup);
            }
        } catch (e) {
            scene.add(pegGroup);
        }
        
        return peg;
    }

    // Helper to create shiny material for board elements
    function createShinyMaterial(color, isEmissive = true) {
        return new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.2,
            metalness: 0.7,
            emissive: isEmissive ? color : 0x000000,
            emissiveIntensity: isEmissive ? 0.2 : 0,
            side: THREE.DoubleSide
        });
    }
    
    // Create branding ring with curved text - gradient lettering with drop shadow
    function createBrandingRing(radius, yPosition) {
        // Create canvas for text texture
        const canvas = document.createElement('canvas');
        const size = 1024;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.clearRect(0, 0, size, size);
        
        // Draw circular text
        ctx.save();
        ctx.translate(size / 2, size / 2);
        
        // Text radius - position filling the pink circle width
        const textRadius = size * 0.44;
        
        // Full circle text: "Fastrack!" repeated with star glyphs
        const brandText = "â˜… Fastrack! â˜… Fastrack! â˜… Fastrack! â˜… Fastrack! ";
        ctx.font = 'bold 72px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Create gradient (gold to orange)
        const gradient = ctx.createLinearGradient(-size/2, 0, size/2, 0);
        gradient.addColorStop(0, '#FFD700');
        gradient.addColorStop(0.5, '#FFA500');
        gradient.addColorStop(1, '#FFD700');
        
        // Calculate angle per character for full circle
        const totalAngle = Math.PI * 2;
        const anglePerChar = totalAngle / brandText.length;
        
        // Draw each character around the full circle
        for (let i = 0; i < brandText.length; i++) {
            const angle = -Math.PI / 2 - i * anglePerChar;  // Start at top, go counter-clockwise
            
            ctx.save();
            ctx.rotate(angle);
            ctx.translate(0, -textRadius);  // Place on outer edge
            ctx.rotate(Math.PI);  // Flip letters right-side up
            
            // Drop shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // Gradient fill
            ctx.fillStyle = gradient;
            ctx.fillText(brandText[i], 0, 0);
            
            ctx.restore();
        }
        
        ctx.restore();
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        
        // Create circular plane for the text - sized to fit on divider circle
        const textGeo = new THREE.CircleGeometry(radius + 5, 64);
        const textMat = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        const textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.rotation.x = -Math.PI / 2;
        textMesh.position.y = yPosition;
        boardGroup.add(textMesh);
    }

    // ============================================================
    // INITIALIZATION
    // ============================================================
    
    // Theme system variables
    let mouseX = 0, mouseY = 0;
    let targetMouseX = 0, targetMouseY = 0;
    let currentThemeName = 'cosmic';
    let isVRMode = false;
    
    // ============================================================
    // VR DETECTION & SUPPORT
    // ============================================================
    async function detectVRMode() {
        console.log('[VR Detection] Checking for VR headset...');
        
        // Check if WebXR is supported
        if (!navigator.xr) {
            console.log('[VR Detection] WebXR not supported');
            return false;
        }
        
        try {
            // Check if VR is supported
            const isVRSupported = await navigator.xr.isSessionSupported('immersive-vr');
            
            if (isVRSupported) {
                console.log('[VR Detection] âœ… VR headset detected! Auto-switching to VR Immersive theme');
                return true;
            } else {
                console.log('[VR Detection] VR not available');
                return false;
            }
        } catch (error) {
            console.log('[VR Detection] Error checking VR support:', error);
            return false;
        }
    }
    
    function addVRButton() {
        console.log('[VR] Adding VR button...');
        
        // Create VR button
        const vrButton = document.createElement('button');
        vrButton.id = 'vr-button';
        vrButton.innerHTML = 'ğŸ¥½ ENTER VR';
        vrButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            background: linear-gradient(135deg, #ff00ff 0%, #00ffff 100%);
            color: white;
            border: 3px solid #ffffff;
            border-radius: 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            cursor: pointer;
            z-index: 10000;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            transition: all 0.3s;
        `;
        
        vrButton.addEventListener('mouseenter', () => {
            vrButton.style.transform = 'scale(1.1)';
            vrButton.style.boxShadow = '0 0 30px rgba(255, 0, 255, 0.8)';
        });
        
        vrButton.addEventListener('mouseleave', () => {
            vrButton.style.transform = 'scale(1)';
            vrButton.style.boxShadow = '0 0 20px rgba(255, 0, 255, 0.6)';
        });
        
        vrButton.addEventListener('click', async () => {
            console.log('[VR] Entering VR mode...');
            
            try {
                // Request VR session
                const session = await navigator.xr.requestSession('immersive-vr', {
                    requiredFeatures: ['local-floor']
                });
                
                console.log('[VR] VR session started');
                
                // Enable XR on renderer
                await renderer.xr.setSession(session);
                renderer.xr.enabled = true;
                
                // Hide VR button when in VR
                vrButton.style.display = 'none';
                
                // Handle session end
                session.addEventListener('end', () => {
                    console.log('[VR] VR session ended');
                    renderer.xr.enabled = false;
                    vrButton.style.display = 'block';
                });
                
            } catch (error) {
                console.error('[VR] Failed to enter VR mode:', error);
                alert('Failed to enter VR mode. Please ensure your VR headset is connected and permissions are granted.');
            }
        });
        
        document.body.appendChild(vrButton);
        console.log('[VR] VR button added');
    }
    
    function init() {
        console.log('ğŸ”„ init() started');
        try {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a14);

        // Camera - far plane extended to see distant theme backdrops (stars, planets, etc.)
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
        // Default: 30Â° above center â€” clear view of all holes
        // 30Â° â†’ Y = dist*sin(30) = 320, Z = dist*cos(30) = 554
        camera.position.set(0, 320, 554);
        camera.lookAt(0, 0, 0);

        // Renderer
        const urlP = new URLSearchParams(window.location.search);
        const isPromo = urlP.has('promo');
        renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true, preserveDrawingBuffer: isPromo });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        var container = document.getElementById('container');
        container.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        // Protect camera from external scripts when Fixed Views or Manual are active.
        (function protectCameraWrites() {
            // Helper: capture a concise stack trace for debugging caller
            function _captureStack() {
                try {
                    const raw = new Error().stack || '';
                    return raw.split('\n').slice(2, 8).map(s => s.trim()).join('\n');
                } catch (e) { return 'stack-unavailable'; }
            }

            // Expose last override attempt for debugging
            window._lastCameraOverrideAttempt = null;
            try {
                if (!camera || !camera.position) return;
                // Preserve originals
                const _origPosSet = camera.position.set.bind(camera.position);
                const _origPosCopy = camera.position.copy.bind(camera.position);
                const _origLookAt = camera.lookAt.bind(camera);

                camera.position.set = function(x, y, z) {
                    if (window._allowCameraWrite) return _origPosSet(x, y, z);
                    if (typeof fixedViewsActive !== 'undefined' && fixedViewsActive) {
                        const stack = _captureStack();
                        console.warn('[CameraGuard] Blocked position.set while fixedViewsActive', { x, y, z, stack });
                        window._lastCameraOverrideAttempt = { method: 'position.set', args: [x,y,z], mode: 'fixedViewsActive', time: Date.now(), stack };
                        return this;
                    }
                    if (currentCameraView === 'manual') {
                        // Don't allow external scripts to override manual view
                        const stack = _captureStack();
                        console.warn('[CameraGuard] Blocked position.set while manual', { x, y, z, stack });
                        window._lastCameraOverrideAttempt = { method: 'position.set', args: [x,y,z], mode: 'manual', time: Date.now(), stack };
                        return this;
                    }
                    return _origPosSet(x, y, z);
                };

                camera.position.copy = function(v) {
                    if (window._allowCameraWrite) return _origPosCopy(v);
                    if (typeof fixedViewsActive !== 'undefined' && fixedViewsActive) {
                        const stack = _captureStack();
                        console.warn('[CameraGuard] Blocked position.copy while fixedViewsActive', { v, stack });
                        window._lastCameraOverrideAttempt = { method: 'position.copy', args: [v], mode: 'fixedViewsActive', time: Date.now(), stack };
                        return this;
                    }
                    if (currentCameraView === 'manual') {
                        const stack = _captureStack();
                        console.warn('[CameraGuard] Blocked position.copy while manual', { v, stack });
                        window._lastCameraOverrideAttempt = { method: 'position.copy', args: [v], mode: 'manual', time: Date.now(), stack };
                        return this;
                    }
                    return _origPosCopy(v);
                };

                camera.lookAt = function() {
                    if (window._allowCameraWrite) return _origLookAt.apply(camera, arguments);
                    if (typeof fixedViewsActive !== 'undefined' && fixedViewsActive) {
                        const stack = _captureStack();
                        console.warn('[CameraGuard] Blocked lookAt while fixedViewsActive', { args: arguments, stack });
                        window._lastCameraOverrideAttempt = { method: 'lookAt', args: Array.from(arguments), mode: 'fixedViewsActive', time: Date.now(), stack };
                        return;
                    }
                    if (currentCameraView === 'manual') {
                        const stack = _captureStack();
                        console.warn('[CameraGuard] Blocked lookAt while manual', { args: arguments, stack });
                        window._lastCameraOverrideAttempt = { method: 'lookAt', args: Array.from(arguments), mode: 'manual', time: Date.now(), stack };
                        return;
                    }
                    return _origLookAt.apply(camera, arguments);
                };
            } catch (e) {
                console.warn('[CameraGuard] failed to wrap camera methods', e);
            }
        })();

        // Ensure default camera mode on load is automatic ('chase') and
        // fixed board view is off. Use force to bypass any guards during init.
        try {
            boardViewMode = 0;
            fixedViewsActive = false;
            currentCameraView = 'chase';
            // UI: ensure board-view button is not marked active
            const bv = document.getElementById('board-view-btn');
            if (bv) bv.classList.remove('active');
            // Apply automatic chase view immediately
            if (typeof setCameraViewMode === 'function') setCameraViewMode('chase', { force: true });
        } catch (e) {}
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.enableRotate = true;
        controls.minDistance = 200;
        controls.maxDistance = 1200;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI / 2.1;
        
        // Setup camera interaction tracking
        setupCameraInteractionTracking();

        // Lighting
        setupLighting();

        // Board group â€” render above backdrop layers
        boardGroup = new THREE.Group();
        boardGroup.name = 'boardGroup';
        boardGroup.renderOrder = 1;
        scene.add(boardGroup);

        // Peg group â€” render above board and backdrop
        pegGroup = new THREE.Group();
        pegGroup.renderOrder = 2;
        scene.add(pegGroup);

        // Expose 3D globals for external modules (tooltips, tutorial)
        window.scene = scene;
        window.camera = camera;
        window.controls = controls;
        window.boardGroup = boardGroup;
        window.getNormalizedHoleType = getNormalizedHoleType;
        window.renderer = renderer;

        // Build hexagon and borders only
        createHexagonBoard();
        createRainbowBorder();
        
        // Draw schema lines and create hole registry
        console.log('ğŸ“ About to call drawSchemaLines...');
        drawSchemaLines();
        console.log('ğŸ“ drawSchemaLines completed, holeRegistry.size =', holeRegistry.size);
        
        // Create pegs and place in start positions
        createPegsAndPlace();

        // Detect VR and apply appropriate theme
        detectVRMode().then(vrDetected => {
            isVRMode = vrDetected;
            
            if (vrDetected) {
                // Auto-switch to VR Immersive theme
                currentThemeName = 'vr_immersive';
                console.log('[VR Detection] ğŸ® Activating VR Immersive theme');
                
                // Add VR button for entering VR mode
                addVRButton();
            }
            
            // Apply theme
            if (window.FastTrackThemes) {
                FastTrackThemes.apply(currentThemeName, scene, THREE);
                // Freeze backdrop motion by default in production so background does not drift over the board.
                if (typeof FastTrackThemes.setMotionScale === 'function') {
                    FastTrackThemes.setMotionScale(0);
                }
            }
        });
        
        // Log substrate status
        if (typeof FastTrackSubstrates !== 'undefined') {
            console.log('ğŸ² FastTrack Substrates loaded:', {
                Rules: FastTrackSubstrates.Rules.rules.size + ' rules',
                Board: 'Board topology defined',
                Card: Object.keys(FastTrackSubstrates.Card.cards).length + ' cards',
                Events: 'Event system active'
            });
        }
        
        // Events
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);
        
        // Initialize settings UI
        const autoMoveToggle = document.getElementById('auto-move-toggle');
        if (autoMoveToggle) {
            autoMoveToggle.checked = GAME_CONFIG.autoMoveForHumans;
            const label = document.getElementById('auto-move-label');
            if (label) label.textContent = GAME_CONFIG.autoMoveForHumans ? 'ON' : 'OFF';
        }

        // Initialize victory ceremony with scene references
        if (window.VictoryCeremony) {
            VictoryCeremony.init(scene, camera, renderer);
        }
        
        // Start animation
        animate();
        
        // Mark board as ready for multiplayer integration
        if (holeRegistry && holeRegistry.size > 0) {
            window.boardReady = true;
            console.log('âœ… boardReady set in init()');
        }
        
        console.log('âœ… init() completed, holeRegistry.size =', holeRegistry.size);
        } catch (e) {
            console.error('âŒ init() error:', e);
        }
    }

    // ============================================================
    // LIGHTING - Enhanced for shiny materials
    // ============================================================
    
    function setupLighting() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(200, 500, 200);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-200, 300, -200);
        scene.add(fillLight);
        
        // Rim light for highlights
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
        rimLight.position.set(0, 100, -400);
        scene.add(rimLight);
        
        // Point light above center for bullseye glow
        const centerLight = new THREE.PointLight(0xffffff, 0.5, 200);
        centerLight.position.set(0, 100, 0);
        scene.add(centerLight);
    }

    // ============================================================
    // HEXAGON BOARD
    // ============================================================
    
    function createHexagonBoard() {
        const shape = new THREE.Shape();
        
        // Create hexagon vertices
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) - Math.PI / 6;
            const x = Math.cos(angle) * BOARD_RADIUS;
            const y = Math.sin(angle) * BOARD_RADIUS;
            if (i === 0) {
                shape.moveTo(x, y);
            } else {
                shape.lineTo(x, y);
            }
        }
        shape.closePath();

        const extrudeSettings = {
            depth: BOARD_THICKNESS,
            bevelEnabled: true,
            bevelThickness: 3,
            bevelSize: 3,
            bevelSegments: 5
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(-Math.PI / 2);
        geometry.translate(0, -BOARD_THICKNESS / 2, 0);

        // Wood-like material with subtle shine
        const material = new THREE.MeshStandardMaterial({
            color: 0xd4a574,
            roughness: 0.5,
            metalness: 0.2
        });

        const board = new THREE.Mesh(geometry, material);
        board.receiveShadow = true;
        boardGroup.add(board);
        
        // Store reference for theme updates
        boardMesh = board;
    }

    // ============================================================
    // RAINBOW BORDER - 6 colored edge segments (no overlap)
    // ============================================================
    
    function createRainbowBorder() {
        // Clear existing border segments
        borderSegments = [];
        
        // Border uses golden ratio constants BORDER_WIDTH and BORDER_HEIGHT
        for (let i = 0; i < 6; i++) {
            const angle1 = (i * Math.PI / 3) - Math.PI / 6;
            const angle2 = ((i + 1) * Math.PI / 3) - Math.PI / 6;
            
            const x1 = Math.cos(angle1) * BOARD_RADIUS;
            const z1 = Math.sin(angle1) * BOARD_RADIUS;
            const x2 = Math.cos(angle2) * BOARD_RADIUS;
            const z2 = Math.sin(angle2) * BOARD_RADIUS;
            
            // Calculate exact edge length - no extra overlap
            const length = Math.sqrt((x2 - x1)**2 + (z2 - z1)**2);
            const midX = (x1 + x2) / 2;
            const midZ = (z1 + z2) / 2;
            const edgeAngle = Math.atan2(z2 - z1, x2 - x1);
            
            // Use exact length, no overlap (removed the +12)
            const geometry = new THREE.BoxGeometry(length, BORDER_HEIGHT, BORDER_WIDTH);
            const material = createShinyMaterial(RAINBOW_COLORS[i], true);
            
            const segment = new THREE.Mesh(geometry, material);
            segment.position.set(midX, 5, midZ);  // Raised to avoid z-fighting with board
            segment.rotation.y = -edgeAngle;
            segment.userData.playerIndex = i;  // Store player index for theme updates
            boardGroup.add(segment);
            borderSegments.push(segment);  // Store reference
        }
    }

    // ============================================================
    // DRAW GAME ELEMENTS - Holes, pentagons, and bullseye
    // ============================================================
    
    function drawSchemaLines() {
        // Uses global LINE_HEIGHT constant (golden ratio Level 2)
        
        // Key radius calculations
        const innerRadius = BOARD_RADIUS / 3;
        const outerRadius = BOARD_RADIUS * Math.cos(Math.PI / 6);  // R * cos(30Â°) â‰ˆ 260
        const innerHexRadius = innerRadius / Math.cos(Math.PI / 6);  // ~115.5
        const wedgeFactor = 0.85;  // How much narrower at outer edge
        
        // FAST TRACK HOLES - one at each inner hexagon corner (where pie lines meet)
        const HOLE_RADIUS = 6;
        const PENTAGON_SIZE = 18;  // Pentagon outer size
        
        for (let i = 0; i < 6; i++) {
            // Hexagon corner angle - each pentagon points to a corner of the main hexagon
            const cornerAngle = (i * Math.PI / 3) - Math.PI / 6;
            
            // Pentagon shape surrounding the hole (color matches border to the right)
            // Flat edge faces center, point faces outward toward hexagon corner
            const pentShape = new THREE.Shape();
            for (let p = 0; p < 5; p++) {
                // Pentagon with point at top (in local coordinates)
                const pentAngle = (p * 2 * Math.PI / 5) - Math.PI / 2;
                const px = Math.cos(pentAngle) * PENTAGON_SIZE;
                const pz = Math.sin(pentAngle) * PENTAGON_SIZE;
                if (p === 0) pentShape.moveTo(px, pz);
                else pentShape.lineTo(px, pz);
            }
            pentShape.closePath();
            
            // Cut hole in center
            const holePath = new THREE.Path();
            for (let h = 0; h < 32; h++) {
                const hAngle = (h * 2 * Math.PI / 32);
                const hx = Math.cos(hAngle) * HOLE_RADIUS;
                const hz = Math.sin(hAngle) * HOLE_RADIUS;
                if (h === 0) holePath.moveTo(hx, hz);
                else holePath.lineTo(hx, hz);
            }
            holePath.closePath();
            pentShape.holes.push(holePath);
            
            // Position pentagon so flat base is on inner circle
            const baseDistance = PENTAGON_SIZE * Math.cos(Math.PI / 5);  // ~14.5
            const pentCenterRadius = innerRadius + baseDistance;
            const pentX = Math.cos(cornerAngle) * pentCenterRadius;
            const pentZ = Math.sin(cornerAngle) * pentCenterRadius;
            
            // Create pentagon mesh with shiny material
            const pentGeo = new THREE.ShapeGeometry(pentShape);
            const pentMat = createShinyMaterial(RAINBOW_COLORS[i], true);
            const pentagon = new THREE.Mesh(pentGeo, pentMat);
            pentagon.rotation.x = -Math.PI / 2;
            // Rotate so point faces outward along the corner angle
            // Shape is drawn with point at +Y (local), after rotation.x it points to -Z
            // We need to rotate around Y to align with cornerAngle
            pentagon.rotation.z = -cornerAngle + Math.PI / 2;
            pentagon.position.set(pentX, LINE_HEIGHT, pentZ);
            boardGroup.add(pentagon);
            coloredMarkers.push({ mesh: pentagon, playerIndex: i });
            
            // Create hole (cylinder) at pentagon center
            const holeGeo = new THREE.CylinderGeometry(HOLE_RADIUS, HOLE_RADIUS, 5, 16);
            const holeMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.8
            });
            const holeMesh = new THREE.Mesh(holeGeo, holeMat);
            holeMesh.position.set(pentX, LINE_HEIGHT - 2, pentZ);
            boardGroup.add(holeMesh);
            
            // Register fast track hole in manifold substrate
            const ftHole = createHole(`ft-${i}`, 'fasttrack', i, pentX, LINE_HEIGHT - 2, pentZ, 'pentagon', {
                isFastTrack: true,
                isFastTrackEntry: true,  // Each ft-{i} is entry point for player i
                isFastTrackExit: true    // Also exit point when landing on own ft-{i}
            });
            ftHole.mesh = holeMesh;
        }
        
        // CENTER BULLSEYE - target with all player colors (using global golden ratio constants)
        const bullseyeY = LINE_HEIGHT;
        
        // Draw rings from outside in (so inner rings are on top)
        for (let r = 5; r >= 0; r--) {
            const outerR = CENTER_HOLE_RADIUS + RING_WIDTH * (r + 1);
            const innerR = CENTER_HOLE_RADIUS + RING_WIDTH * r;
            
            // Create ring shape
            const ringShape = new THREE.Shape();
            for (let a = 0; a <= 64; a++) {
                const angle = (a / 64) * Math.PI * 2;
                const x = Math.cos(angle) * outerR;
                const z = Math.sin(angle) * outerR;
                if (a === 0) ringShape.moveTo(x, z);
                else ringShape.lineTo(x, z);
            }
            ringShape.closePath();
            
            // Cut inner hole
            const innerHole = new THREE.Path();
            for (let a = 0; a <= 64; a++) {
                const angle = (a / 64) * Math.PI * 2;
                const x = Math.cos(angle) * innerR;
                const z = Math.sin(angle) * innerR;
                if (a === 0) innerHole.moveTo(x, z);
                else innerHole.lineTo(x, z);
            }
            innerHole.closePath();
            ringShape.holes.push(innerHole);
            
            const ringGeo = new THREE.ShapeGeometry(ringShape);
            const ringMat = createShinyMaterial(RAINBOW_COLORS[r], false);
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = bullseyeY;
            boardGroup.add(ring);
            coloredMarkers.push({ mesh: ring, playerIndex: r });
        }
        
        // Center hole
        const centerHoleGeo = new THREE.CylinderGeometry(CENTER_HOLE_RADIUS, CENTER_HOLE_RADIUS, 5, 32);
        const centerHoleMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.8
        });
        const centerHoleMesh = new THREE.Mesh(centerHoleGeo, centerHoleMat);
        centerHoleMesh.position.set(0, bullseyeY - 2, 0);
        boardGroup.add(centerHoleMesh);
        
        // CIRCLE between bullseye and pentagons - with branding text
        const bullseyeOuterRadius = CENTER_HOLE_RADIUS + RING_WIDTH * 6;  // Golden proportioned
        const dividerRadius = (bullseyeOuterRadius + innerRadius) / 2;  // Midpoint between bullseye and inner radius
        
        // BRANDING RING with curved gradient text on divider circle
        createBrandingRing(dividerRadius, bullseyeY + 1);
        
        // Register center hole in manifold substrate
        const centerHoleObj = createHole('center', 'center', -1, 0, bullseyeY - 2, 0, 'bullseye', {
            isBullseye: true
        });
        centerHoleObj.mesh = centerHoleMesh;
        centerHoleObj.radius = CENTER_HOLE_RADIUS;
        
        // WEDGE TRACK HOLES - 5 holes along outer edge of each wedge (near colored borders)
        // Spacing must match the side holes
        const TRACK_HOLE_RADIUS = 6;
        
        for (let i = 0; i < 6; i++) {
            // Fast track hole positions
            const cornerAngle1 = (i * Math.PI / 3) - Math.PI / 6;
            const cornerAngle2 = ((i + 1) * Math.PI / 3) - Math.PI / 6;
            const ftX1 = Math.cos(cornerAngle1) * innerHexRadius;
            const ftZ1 = Math.sin(cornerAngle1) * innerHexRadius;
            const ftX2 = Math.cos(cornerAngle2) * innerHexRadius;
            const ftZ2 = Math.sin(cornerAngle2) * innerHexRadius;
            
            // Outer edge setup
            const angle1 = (i * Math.PI / 3) - Math.PI / 6;
            const angle2 = ((i + 1) * Math.PI / 3) - Math.PI / 6;
            const midAngle = (angle1 + angle2) / 2;
            const halfSpan = (angle2 - angle1) / 2;
            const outerAngle1 = midAngle - (halfSpan * wedgeFactor);
            const outerAngle2 = midAngle + (halfSpan * wedgeFactor);
            
            const ox1 = Math.cos(outerAngle1) * outerRadius;
            const oz1 = Math.sin(outerAngle1) * outerRadius;
            const ox2 = Math.cos(outerAngle2) * outerRadius;
            const oz2 = Math.sin(outerAngle2) * outerRadius;
            
            // Calculate side hole spacing (from fast track to first outer position)
            // The first outer hole will be at a point that makes the spacing uniform
            const dist1 = Math.sqrt((ox1 - ftX1)**2 + (oz1 - ftZ1)**2);
            const sideSpacing = dist1 / 5;  // 4 holes = 5 segments
            
            // Calculate the outer row - 5 holes with same spacing
            const outerLength = Math.sqrt((ox2 - ox1)**2 + (oz2 - oz1)**2);
            const totalOuterSpan = sideSpacing * 4;  // 5 holes = 4 gaps
            const outerOffset = (outerLength - totalOuterSpan) / 2;  // Center the holes
            
            // Unit vector along outer edge
            const outerDirX = (ox2 - ox1) / outerLength;
            const outerDirZ = (oz2 - oz1) / outerLength;
            
            // Starting point (offset from ox1)
            const startX = ox1 + outerDirX * outerOffset;
            const startZ = oz1 + outerDirZ * outerOffset;
            
            // Place 5 holes with uniform spacing (outer track)
            for (let h = 0; h < 5; h++) {
                const holeX = startX + outerDirX * (h * sideSpacing);
                const holeZ = startZ + outerDirZ * (h * sideSpacing);
                
                const trackHoleGeo = new THREE.CylinderGeometry(TRACK_HOLE_RADIUS, TRACK_HOLE_RADIUS, 5, 16);
                const trackHoleMat = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.8
                });
                const trackHoleMesh = new THREE.Mesh(trackHoleGeo, trackHoleMat);
                trackHoleMesh.position.set(holeX, LINE_HEIGHT - 2, holeZ);
                boardGroup.add(trackHoleMesh);
                
                // Register outer track hole (h=4 is home/winner hole)
                const holeType = (h === 4) ? 'home' : 'outer';
                const holeId = (h === 4) ? `home-${i}` : `outer-${i}-${h}`;
                
                // Build properties based on hole position
                const holeProps = { isOuterTrack: true };
                if (h === 2) {
                    holeProps.isSafeZoneEntry = true;  // Safe zone pivot point
                }
                if (h === 4) {
                    holeProps.isHoldingExit = true;    // Entry point from holding pen
                }
                
                const outerHole = createHole(holeId, holeType, i, holeX, LINE_HEIGHT - 2, holeZ, (h === 4) ? 'diamond' : null, holeProps);
                outerHole.mesh = trackHoleMesh;
            }
            
            // Store positions for side holes
            const outerHole1X = startX;
            const outerHole1Z = startZ;
            const outerHole5X = startX + outerDirX * (4 * sideSpacing);
            const outerHole5Z = startZ + outerDirZ * (4 * sideSpacing);
            
            // HOME/WINNER HOLE - diamond shape around rightmost hole (hole 5)
            // Diamond marker at home hole (using global DIAMOND_SIZE)
            const diamondShape = new THREE.Shape();
            diamondShape.moveTo(0, DIAMOND_SIZE);     // Top
            diamondShape.lineTo(DIAMOND_SIZE, 0);     // Right
            diamondShape.lineTo(0, -DIAMOND_SIZE);    // Bottom
            diamondShape.lineTo(-DIAMOND_SIZE, 0);    // Left
            diamondShape.closePath();
            
            // Cut hole in center of diamond
            const diamondHolePath = new THREE.Path();
            for (let dh = 0; dh < 32; dh++) {
                const dhAngle = (dh * 2 * Math.PI / 32);
                const dhx = Math.cos(dhAngle) * TRACK_HOLE_RADIUS;
                const dhz = Math.sin(dhAngle) * TRACK_HOLE_RADIUS;
                if (dh === 0) diamondHolePath.moveTo(dhx, dhz);
                else diamondHolePath.lineTo(dhx, dhz);
            }
            diamondHolePath.closePath();
            diamondShape.holes.push(diamondHolePath);
            
            const diamondGeo = new THREE.ShapeGeometry(diamondShape);
            const diamondMat = createShinyMaterial(RAINBOW_COLORS[i], true);
            const diamond = new THREE.Mesh(diamondGeo, diamondMat);
            diamond.rotation.x = -Math.PI / 2;
            diamond.position.set(outerHole5X, LINE_HEIGHT, outerHole5Z);
            boardGroup.add(diamond);
            coloredMarkers.push({ mesh: diamond, playerIndex: i });
            
            // Draw 4 holes from fast track hole i to first outer hole (left side)
            for (let h = 1; h <= 4; h++) {
                const t = h / 5;
                const holeX = ftX1 + (outerHole1X - ftX1) * t;
                const holeZ = ftZ1 + (outerHole1Z - ftZ1) * t;
                
                const connHoleGeo = new THREE.CylinderGeometry(TRACK_HOLE_RADIUS, TRACK_HOLE_RADIUS, 5, 16);
                const connHoleMat = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.8
                });
                const connHoleMesh = new THREE.Mesh(connHoleGeo, connHoleMat);
                connHoleMesh.position.set(holeX, LINE_HEIGHT - 2, holeZ);
                boardGroup.add(connHoleMesh);
                
                // Register side-left hole (h=4 is FastTrack entry point - approaches from left)
                const sideLeftProps = { isOuterTrack: true };
                if (h === 4) {
                    sideLeftProps.isFastTrackEntry = true;  // Can enter FastTrack from here
                }
                const sideLeftHole = createHole(`side-left-${i}-${h}`, 'side-left', i, holeX, LINE_HEIGHT - 2, holeZ, null, sideLeftProps);
                sideLeftHole.mesh = connHoleMesh;
            }
            
            // Draw 4 holes from NEXT fast track hole to last outer hole (right side)
            for (let h = 1; h <= 4; h++) {
                const t = h / 5;
                const holeX = ftX2 + (outerHole5X - ftX2) * t;
                const holeZ = ftZ2 + (outerHole5Z - ftZ2) * t;
                
                const connHoleGeo = new THREE.CylinderGeometry(TRACK_HOLE_RADIUS, TRACK_HOLE_RADIUS, 5, 16);
                const connHoleMat = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.8
                });
                const connHoleMesh = new THREE.Mesh(connHoleGeo, connHoleMat);
                connHoleMesh.position.set(holeX, LINE_HEIGHT - 2, holeZ);
                boardGroup.add(connHoleMesh);
                
                // Register side-right hole
                const sideRightHole = createHole(`side-right-${i}-${h}`, 'side-right', i, holeX, LINE_HEIGHT - 2, holeZ, null, { isOuterTrack: true });
                sideRightHole.mesh = connHoleMesh;
            }
            
            // SAFE ZONE HOLES - 4 holes aligned with wedge center, matching side hole positions
            // Center of the 5 outer holes (middle hole = hole 3 of 5, index 2)
            const centerOuterX = startX + outerDirX * (2 * sideSpacing);
            const centerOuterZ = startZ + outerDirZ * (2 * sideSpacing);
            
            // Target point at inner hexagon along wedge midline (same as how side holes work)
            const wedgeMidAngle = (cornerAngle1 + cornerAngle2) / 2;
            const innerTargetX = Math.cos(wedgeMidAngle) * innerHexRadius;
            const innerTargetZ = Math.sin(wedgeMidAngle) * innerHexRadius;
            
            // Calculate first and last safe hole positions for the enclosure
            const safeHole1X = centerOuterX + (innerTargetX - centerOuterX) * (1/5);
            const safeHole1Z = centerOuterZ + (innerTargetZ - centerOuterZ) * (1/5);
            const safeHole4X = centerOuterX + (innerTargetX - centerOuterX) * (4/5);
            const safeHole4Z = centerOuterZ + (innerTargetZ - centerOuterZ) * (4/5);
            
            // Position at center of safe zone holes
            const safeCenterX = (safeHole1X + safeHole4X) / 2;
            const safeCenterZ = (safeHole1Z + safeHole4Z) / 2;
            
            // Create rounded rectangle (stadium/pill shape) around safe zone holes
            const safeZoneLength = Math.sqrt((safeHole4X - safeHole1X)**2 + (safeHole4Z - safeHole1Z)**2);
            const safeZoneWidth = TRACK_HOLE_RADIUS * 3;
            const cornerRadius = safeZoneWidth / 2;  // Full round ends (stadium shape)
            
            // Create rounded rectangle shape
            const halfLength = (safeZoneLength + safeZoneWidth) / 2;
            const halfWidth = safeZoneWidth / 2;
            const safeShape = new THREE.Shape();
            
            // Draw rounded rectangle (left to right, counter-clockwise)
            safeShape.moveTo(-halfLength + cornerRadius, -halfWidth);
            safeShape.lineTo(halfLength - cornerRadius, -halfWidth);
            safeShape.quadraticCurveTo(halfLength, -halfWidth, halfLength, -halfWidth + cornerRadius);
            safeShape.lineTo(halfLength, halfWidth - cornerRadius);
            safeShape.quadraticCurveTo(halfLength, halfWidth, halfLength - cornerRadius, halfWidth);
            safeShape.lineTo(-halfLength + cornerRadius, halfWidth);
            safeShape.quadraticCurveTo(-halfLength, halfWidth, -halfLength, halfWidth - cornerRadius);
            safeShape.lineTo(-halfLength, -halfWidth + cornerRadius);
            safeShape.quadraticCurveTo(-halfLength, -halfWidth, -halfLength + cornerRadius, -halfWidth);
            
            const safePlaneGeo = new THREE.ShapeGeometry(safeShape);
            const safePlaneMat = new THREE.MeshBasicMaterial({
                color: COLORS[i],
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            const safePlaneMesh = new THREE.Mesh(safePlaneGeo, safePlaneMat);
            safePlaneMesh.rotation.x = -Math.PI / 2;
            safePlaneMesh.rotation.z = -wedgeMidAngle;  // Align radially with wedge
            safePlaneMesh.position.set(safeCenterX, LINE_HEIGHT - 0.5, safeCenterZ);  // Raised to prevent flickering
            boardGroup.add(safePlaneMesh);
            safeZonePlanes.push({ mesh: safePlaneMesh, playerIndex: i });
            
            // Place 4 holes using same t = h/5 interpolation as side holes
            for (let h = 1; h <= 4; h++) {
                const t = h / 5;
                const holeX = centerOuterX + (innerTargetX - centerOuterX) * t;
                const holeZ = centerOuterZ + (innerTargetZ - centerOuterZ) * t;
                
                const safeHoleGeo = new THREE.CylinderGeometry(TRACK_HOLE_RADIUS, TRACK_HOLE_RADIUS, 5, 16);
                const safeHoleMat = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.8
                });
                const safeHoleMesh = new THREE.Mesh(safeHoleGeo, safeHoleMat);
                safeHoleMesh.position.set(holeX, LINE_HEIGHT - 2, holeZ);
                boardGroup.add(safeHoleMesh);
                
                // Register safe zone hole
                const safeHole = createHole(`safe-${i}-${h}`, 'safezone', i, holeX, LINE_HEIGHT - 2, holeZ, null, { isSafeZone: true });
                safeHole.mesh = safeHoleMesh;
            }
            
            // WINNER HOLE - at the end of safe zone (5th position, innermost)
            const winnerT = 5 / 5;  // At innermost position
            const winnerX = centerOuterX + (innerTargetX - centerOuterX) * winnerT;
            const winnerZ = centerOuterZ + (innerTargetZ - centerOuterZ) * winnerT;
            
            // Create star-shaped marker for winner hole
            const starShape = new THREE.Shape();
            const starPoints = 5;
            const outerR = TRACK_HOLE_RADIUS * 2;
            const innerR = TRACK_HOLE_RADIUS * 0.8;
            for (let s = 0; s < starPoints * 2; s++) {
                const r = s % 2 === 0 ? outerR : innerR;
                const angle = (s * Math.PI) / starPoints - Math.PI / 2;
                const sx = Math.cos(angle) * r;
                const sz = Math.sin(angle) * r;
                if (s === 0) starShape.moveTo(sx, sz);
                else starShape.lineTo(sx, sz);
            }
            starShape.closePath();
            
            const starGeo = new THREE.ShapeGeometry(starShape);
            const starMat = new THREE.MeshBasicMaterial({
                color: 0xffd700, // Gold
                side: THREE.DoubleSide
            });
            const starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.rotation.x = -Math.PI / 2;
            starMesh.position.set(winnerX, LINE_HEIGHT + 0.5, winnerZ);
            boardGroup.add(starMesh);
            
            // Register winner hole (star serves as visual marker, no cylinder needed)
            const winnerHole = createHole(`winner-${i}`, 'winner', i, winnerX, LINE_HEIGHT - 2, winnerZ, 'star', { isWinnerHole: true, isSafeZone: true });
            winnerHole.mesh = starMesh; // Use star as the hole mesh for highlighting
        }
        
        // ============================================================
        // GOLDEN CROWN â€” Glowing crown above home hole when all 4 safe zone holes filled
        // ============================================================
        const goldenCrowns = [];  // Array of { mesh, pointLight, playerIndex }
        
        for (let i = 0; i < 6; i++) {
            // Get home hole position from registry
            const homeHole = holeRegistry.get(`home-${i}`);
            if (!homeHole) continue;
            
            const hx = homeHole.position.x;
            const hz = homeHole.position.z;
            const crownY = LINE_HEIGHT + 12; // Float above the home hole
            
            // Build a crown shape using a ring with 5 triangular points
            const crownGroup = new THREE.Group();
            
            // Crown base ring
            const ringGeo = new THREE.TorusGeometry(TRACK_HOLE_RADIUS * 1.6, 0.8, 8, 24);
            const crownMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,        // Gold
                emissive: 0xffa500,      // Warm orange glow
                emissiveIntensity: 0.6,
                metalness: 0.9,
                roughness: 0.15,
                transparent: true,
                opacity: 0.95
            });
            const ring = new THREE.Mesh(ringGeo, crownMat);
            ring.rotation.x = Math.PI / 2;
            crownGroup.add(ring);
            
            // Crown points (5 triangular prongs)
            for (let p = 0; p < 5; p++) {
                const angle = (p / 5) * Math.PI * 2;
                const px = Math.cos(angle) * TRACK_HOLE_RADIUS * 1.6;
                const pz = Math.sin(angle) * TRACK_HOLE_RADIUS * 1.6;
                
                const pointGeo = new THREE.ConeGeometry(1.2, 4, 4);
                const pointMesh = new THREE.Mesh(pointGeo, crownMat);
                pointMesh.position.set(px, 2, pz);
                crownGroup.add(pointMesh);
            }
            
            // Gem on top of each point (small sphere)
            for (let p = 0; p < 5; p++) {
                const angle = (p / 5) * Math.PI * 2;
                const gx = Math.cos(angle) * TRACK_HOLE_RADIUS * 1.6;
                const gz = Math.sin(angle) * TRACK_HOLE_RADIUS * 1.6;
                
                const gemGeo = new THREE.SphereGeometry(0.6, 8, 8);
                const gemMat = new THREE.MeshStandardMaterial({
                    color: RAINBOW_COLORS[i],  // Player's color
                    emissive: RAINBOW_COLORS[i],
                    emissiveIntensity: 0.8,
                    metalness: 0.7,
                    roughness: 0.2
                });
                const gem = new THREE.Mesh(gemGeo, gemMat);
                gem.position.set(gx, 4.2, gz);
                crownGroup.add(gem);
            }
            
            // Point light for golden glow effect
            const crownLight = new THREE.PointLight(0xffd700, 0, 40);
            crownLight.position.set(0, 2, 0);
            crownGroup.add(crownLight);
            
            crownGroup.position.set(hx, crownY, hz);
            crownGroup.visible = false;  // Hidden until 4 safe zone pegs
            boardGroup.add(crownGroup);
            
            goldenCrowns.push({
                mesh: crownGroup,
                pointLight: crownLight,
                material: crownMat,
                playerIndex: i,
                active: false
            });
        }
        
        // Export crowns for access from animate loop and update functions
        window._goldenCrowns = goldenCrowns;
        
        // Check and toggle crown visibility for a player
        window.updateGoldenCrown = function(playerIndex, safeZoneCount) {
            const crown = goldenCrowns[playerIndex];
            if (!crown) return;
            
            if (safeZoneCount >= 4 && !crown.active) {
                crown.mesh.visible = true;
                crown.active = true;
                crown.pointLight.intensity = 2;
                console.log(`ğŸ‘‘ Golden crown ACTIVATED for player ${playerIndex}!`);
            } else if (safeZoneCount < 4 && crown.active) {
                crown.mesh.visible = false;
                crown.active = false;
                crown.pointLight.intensity = 0;
                console.log(`ğŸ‘‘ Golden crown deactivated for player ${playerIndex}`);
            }
        };
        
        // HOLDING AREA - 4 holes (2x2) in a colored circle (using global HOLDING constants)
        for (let i = 0; i < 6; i++) {
            // Position holding area in the corner region, to the right of the player's wedge
            // Place it between the two pie lines, closer to the outer edge
            const angle1 = (i * Math.PI / 3) - Math.PI / 6;
            const angle2 = ((i + 1) * Math.PI / 3) - Math.PI / 6;
            
            // Position at about 80% of the way toward corner, biased to the right side
            const holdingAngle = angle2 - (angle2 - angle1) * 0.08;  // More to the right
            const holdingRadius = BOARD_RADIUS * 0.82;  // Closer to hexagon edge
            
            const holdX = Math.cos(holdingAngle) * holdingRadius;
            const holdZ = Math.sin(holdingAngle) * holdingRadius;
            
            // Create colored circle with shiny material - smaller size
            const smallerCircleRadius = HOLDING_CIRCLE_RADIUS * 0.7;  // 70% of original
            const circleGeo = new THREE.CircleGeometry(smallerCircleRadius, 32);
            const circleMat = createShinyMaterial(RAINBOW_COLORS[i], false);
            const holdingCircle = new THREE.Mesh(circleGeo, circleMat);
            holdingCircle.rotation.x = -Math.PI / 2;
            holdingCircle.position.set(holdX, LINE_HEIGHT, holdZ);
            boardGroup.add(holdingCircle);
            coloredMarkers.push({ mesh: holdingCircle, playerIndex: i });
            
            // Create 4 holes in 2x2 grid - rotated to align with hexagon
            const cosA = Math.cos(holdingAngle);
            const sinA = Math.sin(holdingAngle);
            const offsets = [
                [-HOLDING_HOLE_SPACING/2, -HOLDING_HOLE_SPACING/2],
                [HOLDING_HOLE_SPACING/2, -HOLDING_HOLE_SPACING/2],
                [-HOLDING_HOLE_SPACING/2, HOLDING_HOLE_SPACING/2],
                [HOLDING_HOLE_SPACING/2, HOLDING_HOLE_SPACING/2]
            ];
            
            let holdIdx = 0;
            for (const [localX, localZ] of offsets) {
                // Rotate offset to align with radial direction
                const rotatedX = localX * cosA - localZ * sinA;
                const rotatedZ = localX * sinA + localZ * cosA;
                
                const holeGeo = new THREE.CylinderGeometry(TRACK_HOLE_RADIUS, TRACK_HOLE_RADIUS, 5, 16);
                const holeMat = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.8
                });
                const holeMesh = new THREE.Mesh(holeGeo, holeMat);
                const holeX = holdX + rotatedX;
                const holeZ = holdZ + rotatedZ;
                holeMesh.position.set(holeX, LINE_HEIGHT - 2, holeZ);
                boardGroup.add(holeMesh);
                
                // Register holding area hole
                const holdHole = createHole(`hold-${i}-${holdIdx}`, 'holding', i, holeX, LINE_HEIGHT - 2, holeZ, null, { isHolding: true });
                holdHole.mesh = holeMesh;
                holdIdx++;
            }
        }
        
        // Log hole registry summary
        console.log(`Hole Registry created: ${holeRegistry.size} holes`);
        const typeCounts = {};
        holeRegistry.forEach(h => {
            typeCounts[h.type] = (typeCounts[h.type] || 0) + 1;
        });
        console.log('Hole types:', typeCounts);
    }
    
    // ============================================================
    // CREATE PEGS AND PLACE IN START POSITIONS
    // ============================================================
    
    function clearAllPegs() {
        // Remove all pegs from scene and registry
        pegRegistry.forEach((peg, id) => {
            if (peg.mesh) {
                // Remove from scene (where pegs are actually added)
                scene.remove(peg.mesh);
                // Dispose of geometry and materials to free memory
                if (peg.bodyMesh) {
                    peg.bodyMesh.geometry.dispose();
                    peg.bodyMesh.material.dispose();
                }
                if (peg.discMesh) {
                    peg.discMesh.geometry.dispose();
                    peg.discMesh.material.dispose();
                }
            }
            // Clear hole occupancy
            const hole = holeRegistry.get(peg.currentHole);
            if (hole) {
                hole.occupied = false;
                hole.occupiedBy = null;
            }
        });
        pegRegistry.clear();
        console.log('[clearAllPegs] All pegs cleared from scene and registry');
    }
    
    // Map player index to balanced board position
    // For 3 players: use positions 0, 2, 4 (every other slot)
    // For 4 players: use positions 0, 1, 3, 4 (skip 2 and 5)
    // For 2 players: use positions 0, 3 (opposite sides)
    // For 5/6 players: use all positions
    function getBalancedBoardPosition(playerIdx, playerCount) {
        if (playerCount === 2) {
            return [0, 3][playerIdx];  // Opposite sides
        } else if (playerCount === 3) {
            return [0, 2, 4][playerIdx];  // Every other position
        } else if (playerCount === 4) {
            return [0, 1, 3, 4][playerIdx];  // Skip 2 and 5
        } else {
            return playerIdx;  // 5 or 6 players use all positions
        }
    }
    
    function createPegsAndPlace(playerCount) {
        // Use passed count or global activePlayerCount
        const count = playerCount || activePlayerCount;
        
        // Clear existing pegs first
        clearAllPegs();
        
        // For each active player, create 5 pegs:
        // - 4 in holding area
        // - 1 on home/winner hole (starts in play)
        for (let playerIdx = 0; playerIdx < count; playerIdx++) {
            // Get the balanced board position for this player
            const boardPos = getBalancedBoardPosition(playerIdx, count);
            
            // Place 4 pegs in holding area (matching 2x2 grid)
            for (let pegIdx = 0; pegIdx < 4; pegIdx++) {
                const holeId = `hold-${boardPos}-${pegIdx}`;
                const pegId = `peg-${playerIdx}-${pegIdx}`;
                createPeg(pegId, playerIdx, holeId, boardPos);  // Pass boardPos for color
            }
            
            // Place 5th peg on home/winner hole (starts in play)
            const homeHoleId = `home-${boardPos}`;
            const homePegId = `peg-${playerIdx}-4`;
            createPeg(homePegId, playerIdx, homeHoleId, boardPos);  // Pass boardPos for color
        }
        
        console.log(`Peg Registry created: ${pegRegistry.size} pegs`);
        
        // Update stats display
        const statsDiv = document.getElementById('stats');
        if (statsDiv) {
            statsDiv.innerHTML = `Holes: ${holeRegistry.size} | Pegs: ${pegRegistry.size}`;
        }
    }

    // ============================================================
    // CAMERA VIEWS
    // ============================================================
    
    function setCameraView(viewName) {
        const views = {
            'top': { pos: [0, 700, 0], target: [0, 0, 0] },
            'angle': { pos: [0, 500, 400], target: [0, 0, 0] },
            'side': { pos: [500, 100, 0], target: [0, 0, 0] }
        };
        
        const view = views[viewName];
        if (!view) return;
        
        camera.position.set(view.pos[0], view.pos[1], view.pos[2]);
        camera.lookAt(view.target[0], view.target[1], view.target[2]);
        controls.target.set(view.target[0], view.target[1], view.target[2]);
    }
    
    // ============================================================
    // SMOOTH CAMERA TRANSITIONS
    // ============================================================
    
    let cameraTransition = null;
    let userOverrideCamera = false;
    let userIsInteracting = false;  // true while mouse/touch is down on canvas
    let userInteractionTimeout = null;  // smooth-return delay timer
    let cameraMode = 'cinematic'; // 'cinematic' = auto-follow, 'manual' = user control
    let activePegTracking = null; // Ref to peg being tracked for smooth follow
    // Pointer tracking to determine deliberate pan/rotate vs click
    let _pointerStart = null;
    let _pointerMoved = false;
    const POINTER_MOVE_THRESHOLD = 8; // pixels
    
    // Saved camera state for smooth return after user releases mouse
    let savedCameraTarget = null;
    
    // ============================================================
    // LEADING PEG TRACKING
    // Camera follows the leading peg (furthest along track) unless
    // a special event occurs (FastTrack, bullseye, safe zone, etc.)
    // ============================================================
    
    // Track position priority for determining leading peg
    // Higher number = further along track
    function getPegTrackProgress(peg) {
        if (!peg || !peg.holeId) return -100;
        const holeId = peg.holeId;
        
        // Winning = furthest possible
        if (holeId.includes('winner')) return 1000;
        
        // Safe zone positions (progressively closer to win)
        if (holeId.startsWith('safe-')) {
            const safeNum = parseInt(holeId.split('-').pop()) || 0;
            return 500 + safeNum * 10; // safe-0 = 500, safe-1 = 510, etc.
        }
        
        // Bullseye = very close to winning
        if (holeId === 'center') return 450;
        
        // FastTrack holes = advantageous position
        if (holeId.startsWith('ft-')) {
            const ftNum = parseInt(holeId.replace('ft-', '')) || 0;
            return 300 + ftNum * 5;
        }
        
        // Outer track - most common positions
        if (holeId.startsWith('outer-')) {
            const parts = holeId.split('-');
            const section = parseInt(parts[1]) || 0;
            const hole = parseInt(parts[2]) || 0;
            return 100 + section * 10 + hole;
        }
        
        // Side positions
        if (holeId.startsWith('side-')) {
            const parts = holeId.split('-');
            const section = parseInt(parts[2]) || 0;
            const hole = parseInt(parts[3]) || 0;
            return 50 + section * 10 + hole;
        }
        
        // Home position
        if (holeId.startsWith('home-')) return 10;
        
        // Holding = not yet on track
        if (holeId.startsWith('hold-')) return 0;
        
        return 1; // Default
    }
    
    // Find the leading peg (furthest along track) for a player
    function getLeadingPeg(playerIndex) {
        const player = gameState?.players?.[playerIndex];
        if (!player || !player.peg || player.peg.length === 0) return null;
        
        let leadingPeg = null;
        let maxProgress = -100;
        
        for (const peg of player.peg) {
            const progress = getPegTrackProgress(peg);
            if (progress > maxProgress) {
                maxProgress = progress;
                leadingPeg = peg;
            }
        }
        
        return leadingPeg;
    }
    
    // Check if a move destination is a special event that should override leading peg tracking
    function isSpecialEventMove(move) {
        if (!move || !move.toHoleId) return false;
        const dest = move.toHoleId;
        
        // FastTrack entry or traversal
        if (dest.startsWith('ft-') || move.isFastTrackEntry) return true;
        
        // Bullseye/center
        if (dest === 'center') return true;
        
        // Safe zone entry
        if (dest.startsWith('safe-')) return true;
        
        // Escaping holding area (entering the board)
        if (move.fromHoleId && move.fromHoleId.startsWith('hold-')) return true;
        
        // Winning move
        if (dest.includes('winner')) return true;
        
        return false;
    }
    
    // Pan camera to a special event destination
    function panToSpecialEvent(move, onComplete = null) {
        // Never override manual mode or active user interaction
        if (userOverrideCamera || userIsInteracting || currentCameraView === 'manual') {
            if (onComplete) onComplete();
            return;
        }
        
        const destHole = holeRegistry.get(move.toHoleId);
        if (!destHole) {
            if (onComplete) onComplete();
            return;
        }
        
        const destX = destHole.position ? destHole.position.x : destHole.x;
        const destZ = destHole.position ? destHole.position.z : destHole.z;
        
        // Dramatic camera angle for special events
        let camHeight = 350;
        let camOffset = 150;
        let duration = 1500;
        
        // Tighter focus for bullseye
        if (move.toHoleId === 'center') {
            camHeight = 250;
            camOffset = 100;
            duration = 2000;
        }
        // Winner celebration view
        else if (move.toHoleId.includes('winner')) {
            camHeight = 300;
            camOffset = 120;
            duration = 2500;
        }
        
        smoothCameraTransition(
            { x: destX * 0.5, y: camHeight, z: destZ * 0.5 + camOffset },
            { x: destX, y: 0, z: destZ },
            duration,
            onComplete
        );
    }
    
    // ============================================================
    // CAMERA VIEW SYSTEM - Multiple Adjustable Camera Modes
    // ============================================================
    
    let currentCameraView = 'smooth'; // 'smooth' (default), 'board', 'ground', 'chase', 'orbit', 'manual'
    let orbitAngle = 0;
    let orbitAnimationId = null;
    let chaseTargetPeg = null;
    
    // Camera speed factor: 1.0 = normal, lower = slower/smoother, higher = faster
    // Default 0.6 for buttery smooth movement
    let cameraSpeedFactor = 0.6;
    
    function setCameraSpeed(value) {
        cameraSpeedFactor = parseFloat(value);
        const label = document.getElementById('camera-speed-value');
        if (label) {
            if (cameraSpeedFactor <= 0.3) label.textContent = 'Ultra Smooth';
            else if (cameraSpeedFactor <= 0.5) label.textContent = 'Very Smooth';
            else if (cameraSpeedFactor <= 0.7) label.textContent = 'Smooth';
            else if (cameraSpeedFactor <= 1.0) label.textContent = 'Normal';
            else if (cameraSpeedFactor <= 1.4) label.textContent = 'Fast';
            else label.textContent = 'Very Fast';
        }
        console.log(`[Camera] Speed set to ${cameraSpeedFactor.toFixed(1)}`);
    }
    window.setCameraSpeed = setCameraSpeed;
    
    // Camera view presets
    const CAMERA_VIEWS = {
        smooth: {
            name: 'Smooth Focus',
            icon: 'ğŸ¥',
            description: 'Smoothly follows gameplay action (default)',
            height: 280,
            distance: 480,
            followPeg: true,
            autoOrbit: false,
            smoothFollow: true  // Gentle tracking of active peg
        },
        board: {
            name: 'Board View',
            icon: 'ğŸ¯',
            description: 'Classic 30Â° angled view of the board',
            height: 320,
            distance: 554,
            followPeg: false,
            autoOrbit: false
        },
        ground: {
            name: 'Ground Level',
            icon: 'ğŸƒ',
            description: 'Low angle following the action',
            height: 40,
            distance: 120,
            followPeg: true,
            autoOrbit: false
        },
        chase: {
            name: 'Chase Cam',
            icon: 'ğŸ¬',
            description: 'Behind-the-peg cinematic view',
            height: 60,
            distance: 80,
            followPeg: true,
            autoOrbit: false,
            behindPeg: true
        },
        orbit: {
            name: 'Orbit',
            icon: 'ğŸŒ€',
            description: 'Slowly orbiting the board',
            height: 350,
            distance: 450,
            followPeg: false,
            autoOrbit: true
        },
        manual: {
            name: 'Manual',
            icon: 'ğŸ®',
            description: 'Full manual camera control',
            height: null,
            distance: null,
            followPeg: false,
            autoOrbit: false
        },
        pegeye: {
            name: "Peg's Eye",
            icon: 'ğŸ‘ï¸',
            description: 'First-person view from any peg â€” click a peg, then pan 360Â°',
            height: null,
            distance: null,
            followPeg: false,
            autoOrbit: false,
            pegEye: true
        }
    };

    // ============================================================
    // PEG'S EYE VIEW â€” First-person camera from any peg
    // ============================================================
    let pegEyeActive = false;
    let pegEyeTargetPeg = null;      // pegRegistry entry
    let pegEyeYaw = 0;               // horizontal rotation (radians)
    let pegEyePitch = 0;             // vertical tilt (radians)
    let pegEyeDragging = false;
    let pegEyeLastX = 0;
    let pegEyeLastY = 0;
    let pegEyeSelectMode = false;    // waiting for user to click a peg

    function enterPegEyeMode() {
        pegEyeSelectMode = true;
        pegEyeActive = false;
        pegEyeTargetPeg = null;
        pegEyeYaw = 0;
        pegEyePitch = 0;
        // Show selection prompt
        _showPegEyePrompt('ğŸ‘ï¸ Click any peg to see its point of view');
        _showPegEyeBackButton();
        // Highlight all pegs to show they're clickable
        pegRegistry.forEach(peg => {
            if (peg.bodyMesh) {
                peg._origEmissiveIntensity = peg.bodyMesh.material.emissiveIntensity;
                peg.bodyMesh.material.emissiveIntensity = 1.2;
            }
        });
        console.log("[Peg's Eye] Select mode â€” click any peg");
    }

    function _pegEyeOnClick(event) {
        if (!pegEyeSelectMode) return;
        // Raycast to find clicked peg
        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );
        const rc = new THREE.Raycaster();
        rc.setFromCamera(mouse, camera);
        const hits = rc.intersectObjects(scene.children, true);
        for (const hit of hits) {
            for (const [pegId, peg] of pegRegistry) {
                if (peg.bodyMesh === hit.object || peg.discMesh === hit.object || peg.mesh === hit.object) {
                    // Found a peg â€” activate peg eye on it
                    _activatePegEye(peg);
                    return;
                }
            }
        }
    }

    function _activatePegEye(peg) {
        pegEyeSelectMode = false;
        pegEyeActive = true;
        pegEyeTargetPeg = peg;
        pegEyeYaw = 0;
        pegEyePitch = 0.1; // slight upward look
        // Restore peg highlights
        pegRegistry.forEach(p => {
            if (p.bodyMesh && p._origEmissiveIntensity !== undefined) {
                p.bodyMesh.material.emissiveIntensity = p._origEmissiveIntensity;
            }
        });
        // Disable orbit controls while in peg eye (we handle mouse ourselves)
        if (controls) controls.enabled = false;
        userOverrideCamera = true;

        // Position camera at peg
        _updatePegEyeCamera();
        _showPegEyePrompt("ğŸ‘ï¸ " + (peg.id || 'Peg') + " â€” drag to pan 360Â°");

        console.log("[Peg's Eye] Activated on", peg.id);
    }

    function _updatePegEyeCamera() {
        if (!pegEyeActive || !pegEyeTargetPeg) return;
        const pos = pegEyeTargetPeg.mesh.position;
        // Camera sits at peg top height (eye level)
        const eyeHeight = pos.y + 25; // top of peg + a little above
        camera.position.set(pos.x, eyeHeight, pos.z);
        // Look direction from yaw/pitch
        const lookDist = 100;
        const lookX = pos.x + Math.sin(pegEyeYaw) * Math.cos(pegEyePitch) * lookDist;
        const lookY = eyeHeight + Math.sin(pegEyePitch) * lookDist;
        const lookZ = pos.z + Math.cos(pegEyeYaw) * Math.cos(pegEyePitch) * lookDist;
        camera.lookAt(lookX, lookY, lookZ);
        if (controls) {
            controls.target.set(lookX, lookY, lookZ);
        }
    }

    function _pegEyePointerDown(e) {
        if (!pegEyeActive) return;
        pegEyeDragging = true;
        pegEyeLastX = e.clientX;
        pegEyeLastY = e.clientY;
    }
    function _pegEyePointerMove(e) {
        if (!pegEyeActive || !pegEyeDragging) return;
        const dx = e.clientX - pegEyeLastX;
        const dy = e.clientY - pegEyeLastY;
        pegEyeLastX = e.clientX;
        pegEyeLastY = e.clientY;
        // Sensitivity
        pegEyeYaw -= dx * 0.005;
        pegEyePitch = Math.max(-0.8, Math.min(0.8, pegEyePitch + dy * 0.003));
        _updatePegEyeCamera();
    }
    function _pegEyePointerUp() {
        pegEyeDragging = false;
    }

    function exitPegEyeMode() {
        pegEyeSelectMode = false;
        pegEyeActive = false;
        pegEyeTargetPeg = null;
        pegEyeDragging = false;
        // Restore peg highlights
        pegRegistry.forEach(p => {
            if (p.bodyMesh && p._origEmissiveIntensity !== undefined) {
                p.bodyMesh.material.emissiveIntensity = p._origEmissiveIntensity;
                delete p._origEmissiveIntensity;
            }
        });
        // Re-enable orbit controls
        if (controls) controls.enabled = true;
        userOverrideCamera = false;
        // Hide prompts and back button
        _hidePegEyePrompt();
        _hidePegEyeBackButton();
        // Return to board view
        setCameraViewMode('board');
        console.log("[Peg's Eye] Exited, returned to board view");
    }

    // UI helpers for Peg's Eye
    function _showPegEyePrompt(text) {
        let el = document.getElementById('pegeye-prompt');
        if (!el) {
            el = document.createElement('div');
            el.id = 'pegeye-prompt';
            el.style.cssText = 'position:fixed;top:70px;left:50%;transform:translateX(-50%);z-index:20010;' +
                'background:linear-gradient(135deg,rgba(52,152,219,0.9),rgba(155,89,182,0.85));color:#fff;' +
                'padding:12px 28px;border-radius:30px;font-family:Orbitron,Rajdhani,sans-serif;font-size:1em;' +
                'font-weight:600;letter-spacing:0.5px;pointer-events:none;box-shadow:0 4px 20px rgba(0,0,0,0.4);' +
                'border:1px solid rgba(255,255,255,0.15);backdrop-filter:blur(8px);transition:opacity 0.3s;';
            document.body.appendChild(el);
        }
        el.textContent = text;
        el.style.opacity = '1';
    }
    function _hidePegEyePrompt() {
        const el = document.getElementById('pegeye-prompt');
        if (el) el.style.opacity = '0';
    }

    function _showPegEyeBackButton() {
        let btn = document.getElementById('pegeye-back-btn');
        if (!btn) {
            btn = document.createElement('button');
            btn.id = 'pegeye-back-btn';
            btn.style.cssText = 'position:fixed;bottom:30px;left:50%;transform:translateX(-50%);z-index:20010;' +
                'background:linear-gradient(135deg,rgba(231,76,60,0.9),rgba(192,57,43,0.9));color:#fff;' +
                'padding:14px 32px;border-radius:30px;font-family:Orbitron,Rajdhani,sans-serif;font-size:1.05em;' +
                'font-weight:700;letter-spacing:1px;cursor:pointer;border:2px solid rgba(255,255,255,0.2);' +
                'box-shadow:0 4px 25px rgba(231,76,60,0.4);transition:transform 0.2s,box-shadow 0.2s;';
            btn.textContent = 'ğŸ¯ Back to Board';
            btn.addEventListener('mouseenter', function() { this.style.transform = 'translateX(-50%) scale(1.06)'; });
            btn.addEventListener('mouseleave', function() { this.style.transform = 'translateX(-50%) scale(1)'; });
            btn.addEventListener('click', exitPegEyeMode);
            document.body.appendChild(btn);
        }
        btn.style.display = 'block';
    }
    function _hidePegEyeBackButton() {
        const btn = document.getElementById('pegeye-back-btn');
        if (btn) btn.style.display = 'none';
    }

    // Small informational popup for Fixed Views state
    function showFixedViewInfo(text, duration = 2400) {
        let el = document.getElementById('fixed-views-info');
        if (!el) {
            el = document.createElement('div');
            el.id = 'fixed-views-info';
            el.style.cssText = 'position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:20020;' +
                'background:rgba(0,0,0,0.85);color:#fff;padding:10px 18px;border-radius:12px;' +
                'font-family:Inter,Arial,sans-serif;font-size:14px;font-weight:600;pointer-events:none;' +
                'box-shadow:0 6px 30px rgba(0,0,0,0.45);transition:opacity 0.25s ease;opacity:0;';
            document.body.appendChild(el);
        }
        el.textContent = text;
        el.style.opacity = '1';
        if (el._hideTimeout) clearTimeout(el._hideTimeout);
        el._hideTimeout = setTimeout(() => { el.style.opacity = '0'; }, duration);
    }

    // Wire mouse events for peg eye (added once, checked inside handlers)
    document.addEventListener('click', _pegEyeOnClick);
    document.addEventListener('pointerdown', _pegEyePointerDown);
    document.addEventListener('pointermove', _pegEyePointerMove);
    document.addEventListener('pointerup', _pegEyePointerUp);

    // Expose globally
    window.enterPegEyeMode = enterPegEyeMode;
    window.exitPegEyeMode = exitPegEyeMode;
    
    // Cycle through camera modes (for quick toggle button)
    function cycleCameraMode() {
        const modes = ['smooth', 'board', 'chase', 'orbit', 'manual'];
        const currentIndex = modes.indexOf(currentCameraView);
        const nextIndex = (currentIndex + 1) % modes.length;
        const nextMode = modes[nextIndex];
        
        console.log(`[Camera] Cycling from ${currentCameraView} to ${nextMode}`);
        setCameraViewMode(nextMode);
    }
    window.cycleCameraMode = cycleCameraMode;
    
    // Toggle camera panel visibility (for settings menu)
    function toggleCameraPanel() {
        const panel = document.getElementById('camera-view-panel');
        if (panel) {
            panel.classList.toggle('visible');
        }
    }
    window.toggleCameraPanel = toggleCameraPanel;
    
    // Set camera view mode
    function setCameraViewMode(viewName, opts) {
        opts = opts || {};
        if (!CAMERA_VIEWS[viewName]) return;

        // If board fixed views are active (straight or angled), completely ignore
        // any attempts to change camera mode. This guarantees strict separation
        // between fixed straight / fixed angled and automatic modes.
        if (typeof boardViewMode !== 'undefined' && boardViewMode > 0) {
            try {
                const stack = (new Error().stack || '').split('\n').slice(2, 8).map(s => s.trim()).join('\n');
                console.warn('[Camera] Board fixed view active (mode', boardViewMode, ') â€” ignoring change to', viewName, { stack });
                window._lastCameraOverrideCaller = { time: Date.now(), caller: viewName, mode: 'boardFixed', boardViewMode, stack };
            } catch (e) {
                console.log('[Camera] Board fixed view active â€” ignoring change to', viewName);
            }
            return;
        }

        // If fixedViewsActive is true for other reasons, ignore changes unless forced
        if (typeof fixedViewsActive !== 'undefined' && fixedViewsActive && !opts.force) {
            console.log('[Camera] Fixed views active â€” ignoring change to', viewName);
            return;
        }
        
        // Stop any existing orbit animation
        if (orbitAnimationId) {
            cancelAnimationFrame(orbitAnimationId);
            orbitAnimationId = null;
        }
        
        currentCameraView = viewName;
        const view = CAMERA_VIEWS[viewName];
        
        // Update UI
        document.querySelectorAll('.camera-view-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === viewName);
        });
        
        // Update toggle button icon
        const btn = document.getElementById('camera-toggle-btn');
        if (btn) {
            btn.textContent = view.icon;
            btn.title = `Camera: ${view.name}`;
            btn.classList.toggle('cinematic', viewName !== 'manual');
        }
        
        // Hide panel after selection
        const panel = document.getElementById('camera-view-panel');
        if (panel) panel.classList.remove('visible');
        
        // Apply view settings
        if (viewName === 'manual') {
            userOverrideCamera = true;
            cameraMode = 'manual';
            // In manual mode, disable all cinematic transitions
            if (cameraTransition) {
                cancelAnimationFrame(cameraTransition.animId);
                const pendingCallback = cameraTransition.onComplete;
                cameraTransition = null;
                if (pendingCallback) pendingCallback();
            }
            return;
        }
        
        userOverrideCamera = false;
        cameraMode = view.followPeg ? 'cinematic' : 'cinematic';
        
        // Get target position (active peg or board center)
        let targetX = 0, targetZ = 0;
        const activePeg = getActivePegPosition();
        if (activePeg && view.followPeg) {
            targetX = activePeg.x;
            targetZ = activePeg.z;
        }
        
        if (view.autoOrbit) {
            // Start orbit animation
            startOrbitAnimation();
        } else if (view.followPeg && view.behindPeg) {
            // Chase cam - position behind the peg
            positionChaseCam(targetX, targetZ, view.height, view.distance);
        } else if (view.followPeg) {
            // Ground level - low angle facing the peg
            positionGroundCam(targetX, targetZ, view.height, view.distance);
        } else {
            // Board view - standard elevated view
            smoothCameraTransition(
                { x: 0, y: view.height, z: view.distance },
                { x: 0, y: 0, z: 0 },
                1000
            );
        }
    }
    window.setCameraViewMode = setCameraViewMode;

    // Fixed Views Mode - Toggle between straight down and angled preset views
    // These are persistent until the user toggles them off.
    // 0 = off (automatic), 1 = straight down, 2 = angled
    let boardViewMode = 0;
    let fibonacciBackdrop = null;
    // When fixedViewsActive is true, automatic camera changes are suppressed
    // until the user explicitly disables fixed views.
    let fixedViewsActive = false;

    function setBoardViewMode() {
        const btn = document.getElementById('board-view-btn');

        // Cycle through: off -> straight down -> angled -> off
        boardViewMode = (boardViewMode + 1) % 3;

        if (boardViewMode === 0) {
            // Exit board view mode - return to normal view
            if (btn) {
                btn.classList.remove('active');
                try {
                    btn.style.pointerEvents = '';
                    btn.style.zIndex = '';
                    btn.removeAttribute('data-fixed-views');
                } catch (e) {}
            }

            // Hide lava lamp backdrop
            if (fibonacciBackdrop) {
                fibonacciBackdrop.hide();
            }

            // Re-enable controls (keep them enabled for mouse manipulation)
            if (controls) {
                controls.enabled = true;
                controls.enableRotate = true;
                controls.enableZoom = true;
                controls.enablePan = true;
            }
            userOverrideCamera = false;
            fixedViewsActive = false;

            // Inform user
            showFixedViewInfo('Automatic View â€” automatic camera enabled');

            // Return to automatic camera (force to bypass fixed-views guard)
            setCameraViewMode('chase', { force: true });
            console.log('[Fixed Views] Exited - returned to automatic camera');
        } else {
            // Enter board view mode (straight down or angled)
            if (btn) {
                btn.classList.add('active');
                // Ensure the fixed-views button stays clickable even when other
                // overlays are shown (demo/promo). Bring to front and allow pointer events.
                try {
                    btn.style.pointerEvents = 'auto';
                    btn.style.zIndex = '100001';
                    btn.setAttribute('data-fixed-views', 'true');
                } catch (e) {}
            }

            // Create and show lava lamp backdrop if not exists
            if (!fibonacciBackdrop && window.FibonacciBackdrop) {
                fibonacciBackdrop = new window.FibonacciBackdrop(scene);
                fibonacciBackdrop.create();
            }
            if (fibonacciBackdrop) {
                fibonacciBackdrop.show();
            }

            // Keep controls enabled so user can manipulate with mouse
            if (controls) {
                controls.enabled = true;
                controls.enableRotate = true;
                controls.enableZoom = true;
                controls.enablePan = true;
            }

            // Apply camera placement first while allowing internal writes,
            // then enable fixed view mode so external scripts cannot override.
            try {
                window._allowCameraWrite = true;
            } catch (e) {}

            if (camera && controls) {
                if (boardViewMode === 1) {
                    // Straight down view
                    camera.position.set(0, 700, 0);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    console.log('[Fixed Views] Mode 1: Straight Down - mouse controls enabled');
                    showFixedViewInfo('Straight Down View (Fixed)');
                    currentCameraView = 'fixed-straight';
                } else if (boardViewMode === 2) {
                    // Angled view (45 degrees)
                    const distance = 700;
                    const angle = Math.PI / 4; // 45 degrees
                    camera.position.set(
                        distance * Math.sin(angle),
                        distance * Math.cos(angle),
                        distance * Math.sin(angle)
                    );
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    console.log('[Fixed Views] Mode 2: Angled View - mouse controls enabled');
                    showFixedViewInfo('Angled View (Fixed)');
                    currentCameraView = 'fixed-angled';
                }
            }

            try {
                window._allowCameraWrite = false;
            } catch (e) {}

            // Now mark as fixed so external writes are blocked
            userOverrideCamera = true;
            fixedViewsActive = true;
        }
    }
    window.setBoardViewMode = setBoardViewMode;

    // Get active peg position (current player's leading peg)
    function getActivePegPosition() {
        if (!gameState) return null;
        
        const leadingPeg = getLeadingPeg(gameState.currentPlayerIndex);
        if (!leadingPeg || !leadingPeg.holeId) return null;
        
        const hole = holeRegistry.get(leadingPeg.holeId);
        if (!hole) return null;
        
        return {
            x: hole.position ? hole.position.x : hole.x,
            z: hole.position ? hole.position.z : hole.z,
            pegId: leadingPeg.id
        };
    }
    
    // Position camera for ground level view
    function positionGroundCam(targetX, targetZ, height, distance) {
        // Calculate direction from center to target
        const dx = targetX || 0.01;
        const dz = targetZ || 0.01;
        const mag = Math.sqrt(dx * dx + dz * dz);
        const dirX = dx / mag;
        const dirZ = dz / mag;
        
        // Position camera slightly behind and to the side of target
        const camX = targetX - dirX * distance;
        const camZ = targetZ - dirZ * distance;
        
        smoothCameraTransition(
            { x: camX, y: height, z: camZ },
            { x: targetX, y: 10, z: targetZ },
            800
        );
    }
    
    // Position camera for chase cam (behind peg)
    function positionChaseCam(targetX, targetZ, height, distance) {
        // Get peg's movement direction from last move or use direction from center
        const dx = targetX || 0.01;
        const dz = targetZ || 0.01;
        const mag = Math.sqrt(dx * dx + dz * dz);
        const dirX = dx / mag;
        const dirZ = dz / mag;
        
        // Position camera behind the peg (opposite direction of travel)
        const camX = targetX - dirX * distance;
        const camZ = targetZ - dirZ * distance;
        
        smoothCameraTransition(
            { x: camX, y: height, z: camZ },
            { x: targetX + dirX * 50, y: 5, z: targetZ + dirZ * 50 },
            600
        );
    }
    
    // Auto-orbit animation
    function startOrbitAnimation() {
        const view = CAMERA_VIEWS.orbit;
        const radius = view.distance;
        const height = view.height;
        const speed = 0.0005 * cameraSpeedFactor; // radians per frame, scaled by speed
        
            function animateOrbit() {
            // Stop orbit if user takes over or manual/fixed board views are active
            if (userIsInteracting || currentCameraView === 'manual') return;
            if ((typeof boardViewMode !== 'undefined' && boardViewMode > 0) || (typeof fixedViewsActive !== 'undefined' && fixedViewsActive)) return;
            
            orbitAngle += speed;
            
            const x = Math.sin(orbitAngle) * radius;
            const z = Math.cos(orbitAngle) * radius;
            
            camera.position.set(x, height, z);
            controls.target.set(0, 0, 0);
            camera.lookAt(0, 0, 0);
            
            if (currentCameraView === 'orbit') {
                orbitAnimationId = requestAnimationFrame(animateOrbit);
            }
        }
        
        animateOrbit();
    }
    
    // Flag: true while a peg move animation is actively running
    let _pegMoveInProgress = false;
    
    // Update camera during peg movement (called from animatePegMove)
    function updateCameraForPegMove(pegX, pegZ) {
        if (pegEyeActive || pegEyeSelectMode) {
            // In peg's eye mode, update eye position if our peg moved
            if (pegEyeActive) _updatePegEyeCamera();
            return;
        }
        if (userOverrideCamera || userIsInteracting || currentCameraView === 'manual') return;
        if ((typeof boardViewMode !== 'undefined' && boardViewMode > 0) || (typeof fixedViewsActive !== 'undefined' && fixedViewsActive)) return;
        
        const view = CAMERA_VIEWS[currentCameraView];
        if (!view) return;
        
        // During active peg movement, ALWAYS follow the peg regardless of view mode
        if (_pegMoveInProgress || view.followPeg) {
            // Lerp factor scaled by speed: lower cameraSpeedFactor = smoother/slower follow
            const baseLerp = view.behindPeg ? 0.025 : (view.smoothFollow ? 0.02 : 0.035);
            const lerp = baseLerp * cameraSpeedFactor;
            
            if (view.smoothFollow) {
                // Smooth focus - elevated angle that gently tracks gameplay
                // Keep camera at fixed elevated position, just pan the target
                const targetLerp = 0.025 * cameraSpeedFactor;
                controls.target.x += (pegX - controls.target.x) * targetLerp;
                controls.target.z += (pegZ - controls.target.z) * targetLerp;
                
                // Maintain elevated camera position relative to target
                const camX = controls.target.x;
                const camZ = controls.target.z + view.distance;
                
                camera.position.x += (camX - camera.position.x) * lerp;
                camera.position.y += (view.height - camera.position.y) * lerp;
                camera.position.z += (camZ - camera.position.z) * lerp;
                
                camera.lookAt(controls.target);
            } else if (view.behindPeg) {
                // Chase cam - smooth follow behind peg
                const dx = pegX || 0.01;
                const dz = pegZ || 0.01;
                const mag = Math.sqrt(dx * dx + dz * dz);
                const dirX = dx / mag;
                const dirZ = dz / mag;
                
                const camX = pegX - dirX * view.distance;
                const camZ = pegZ - dirZ * view.distance;
                
                camera.position.x += (camX - camera.position.x) * lerp;
                camera.position.y += (view.height - camera.position.y) * lerp;
                camera.position.z += (camZ - camera.position.z) * lerp;
                
                controls.target.x += (pegX - controls.target.x) * lerp;
                controls.target.y += (10 - controls.target.y) * lerp;
                controls.target.z += (pegZ - controls.target.z) * lerp;
                camera.lookAt(controls.target);
            } else {
                // Ground level - low angle tracking
                const dx = pegX || 0.01;
                const dz = pegZ || 0.01;
                const mag = Math.sqrt(dx * dx + dz * dz);
                const dirX = dx / mag;
                const dirZ = dz / mag;
                
                const camX = pegX - dirX * view.distance;
                const camZ = pegZ - dirZ * view.distance;
                
                camera.position.x += (camX - camera.position.x) * lerp;
                camera.position.y += (view.height - camera.position.y) * lerp;
                camera.position.z += (camZ - camera.position.z) * lerp;
                
                controls.target.x += (pegX - controls.target.x) * lerp;
                controls.target.y += (10 - controls.target.y) * lerp;
                controls.target.z += (pegZ - controls.target.z) * lerp;
                camera.lookAt(controls.target);
            }
        } else {
            // Board/orbit view â€” smoothly pan camera target to follow peg
            // Keep camera position, just shift where it looks
            const lerp = 0.025 * cameraSpeedFactor;
            controls.target.x += (pegX - controls.target.x) * lerp;
            controls.target.z += (pegZ - controls.target.z) * lerp;
            camera.lookAt(controls.target);
        }
    }
    window.updateCameraForPegMove = updateCameraForPegMove;
    
    // Legacy toggle function (for compatibility)
    function toggleCameraMode() {
        toggleCameraPanel();
    }
    
    // Track user interaction with camera
    // While user is actively manipulating (mouse/touch down), ALL cinematic
    // movement is blocked. After release, there's a grace period then a
    // smooth transition back to the current camera mode's position.
    function setupCameraInteractionTracking() {
        if (!controls || !renderer) return;
        // Pointer down: mark interaction start and record start position
        renderer.domElement.addEventListener('pointerdown', (e) => {
            userIsInteracting = true;
            userOverrideCamera = true;
            _pointerMoved = false;
            try { _pointerStart = { x: e.clientX, y: e.clientY }; } catch (ex) { _pointerStart = null; }
            // Cancel any pending smooth-return timer
            if (userInteractionTimeout) {
                clearTimeout(userInteractionTimeout);
                userInteractionTimeout = null;
            }
            // Cancel any active cinematic transition but preserve game callbacks
            if (cameraTransition) {
                cancelAnimationFrame(cameraTransition.animId);
                const pendingCallback = cameraTransition.onComplete;
                cameraTransition = null;
                // Fire the callback so game logic (deck enable, AI turn) is never blocked
                if (pendingCallback) pendingCallback();
            }
        });

        // Track pointer movement while interacting to detect deliberate pans/rotates
        renderer.domElement.addEventListener('pointermove', (e) => {
            // If pointer is not down we don't treat as drag here
            if (!_pointerStart) return;
            const cx = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            const cy = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
            const dx = cx - _pointerStart.x;
            const dy = cy - _pointerStart.y;
            if (!_pointerMoved && Math.sqrt(dx * dx + dy * dy) > POINTER_MOVE_THRESHOLD) {
                _pointerMoved = true;
                // Immediately treat deliberate drag as manual control
                userOverrideCamera = true;
                currentCameraView = 'manual';
                cameraMode = 'manual';
                // Cancel any cinematic transition
                if (cameraTransition) {
                    cancelAnimationFrame(cameraTransition.animId);
                    const cb = cameraTransition.onComplete;
                    cameraTransition = null;
                    if (cb) cb();
                }
                showFixedViewInfo('Manual camera enabled â€” automatic camera disabled');
            }
        }, { passive: true });

        // Wheel (zoom) should also switch to manual immediately
        renderer.domElement.addEventListener('wheel', (e) => {
            userOverrideCamera = true;
            currentCameraView = 'manual';
            cameraMode = 'manual';
            showFixedViewInfo('Manual camera (wheel) â€” automatic camera disabled');
        }, { passive: true });

        // Touch gestures: if multiple touches or significant movement, treat as manual
        renderer.domElement.addEventListener('touchmove', (e) => {
            if (e.touches && e.touches.length > 1) {
                userOverrideCamera = true;
                currentCameraView = 'manual';
                cameraMode = 'manual';
                showFixedViewInfo('Manual camera (touch) â€” automatic camera disabled');
            }
        }, { passive: true });

        renderer.domElement.addEventListener('pointerup', onUserCameraRelease);
        renderer.domElement.addEventListener('pointerleave', onUserCameraRelease);
        renderer.domElement.addEventListener('pointercancel', onUserCameraRelease);
    }
    
    function onUserCameraRelease() {
        if (!userIsInteracting) return;
        userIsInteracting = false;

        // If the user deliberately moved/dragged the camera, interpret as
        // explicit manual control and do NOT auto-return â€” switch to manual mode.
        if (_pointerMoved) {
            userOverrideCamera = true;
            currentCameraView = 'manual';
            cameraMode = 'manual';
            _pointerStart = null;
            _pointerMoved = false;
            showFixedViewInfo('Manual camera enabled â€” automatic camera disabled');
            return; // stay where the user left it
        }

        // In manual mode, stay where the user left the camera forever
        if (currentCameraView === 'manual') {
            return; // No smooth return â€” full user control
        }

        // For other modes, wait 1.5s grace period then smoothly return
        if (userInteractionTimeout) clearTimeout(userInteractionTimeout);
        userInteractionTimeout = setTimeout(() => {
            userOverrideCamera = false;
            userInteractionTimeout = null;
            // Smoothly return to current view mode's default position
            returnToViewDefault();
        }, 1500);
    }
    
    // Smoothly transition back to the current camera view's default position
    function returnToViewDefault() {
        // If user is interacting, in manual mode, or fixed board views are active, do nothing
        if (userIsInteracting || currentCameraView === 'manual') return;
        if ((typeof boardViewMode !== 'undefined' && boardViewMode > 0) || (typeof fixedViewsActive !== 'undefined' && fixedViewsActive)) return;
        
        const view = CAMERA_VIEWS[currentCameraView];
        if (!view) return;
        
        if (view.autoOrbit) {
            // Just restart orbit from current angle
            orbitAngle = Math.atan2(camera.position.x, camera.position.z);
            startOrbitAnimation();
        } else if (view.followPeg) {
            const activePeg = getActivePegPosition();
            if (activePeg) {
                if (view.behindPeg) {
                    positionChaseCam(activePeg.x, activePeg.z, view.height, view.distance);
                } else {
                    positionGroundCam(activePeg.x, activePeg.z, view.height, view.distance);
                }
            }
        } else {
            // Board view â€” return to 30Â° default
            smoothCameraTransition(
                { x: 0, y: view.height || 320, z: view.distance || 554 },
                { x: 0, y: 0, z: 0 },
                1500
            );
        }
    }
    
    function smoothCameraTransition(targetPos, targetLookAt, duration = 2500, onComplete = null, opts) {
        opts = opts || {};
        // Never interrupt manual mode or active user interaction
        if (currentCameraView === 'manual' || userIsInteracting) {
            if (onComplete) onComplete();
            return;
        }

        // If fixed views are active, suppress automatic transitions unless forced
        if (typeof fixedViewsActive !== 'undefined' && fixedViewsActive && !opts.force) {
            if (onComplete) onComplete();
            console.log('[Camera] Fixed views active â€” suppressed smoothCameraTransition');
            return;
        }
        
        // Cancel any existing transition (fire its callback so game logic isn't blocked)
        if (cameraTransition) {
            cancelAnimationFrame(cameraTransition.animId);
            const pendingCallback = cameraTransition.onComplete;
            cameraTransition = null;
            if (pendingCallback) pendingCallback();
        }
        
        // Apply speed factor: lower factor = longer duration = smoother
        const scaledDuration = duration / cameraSpeedFactor;
        
        const startPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const endPos = new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z);
        const endTarget = new THREE.Vector3(targetLookAt.x, targetLookAt.y, targetLookAt.z);
        const startTime = Date.now();
        
        function animateCamera() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / scaledDuration, 1);
            
            // Smooth ease-in-out using sine curve for ultra-smooth motion
            const t = -(Math.cos(Math.PI * progress) - 1) / 2;
            
            camera.position.lerpVectors(startPos, endPos, t);
            controls.target.lerpVectors(startTarget, endTarget, t);
            camera.lookAt(controls.target);
            
            if (progress < 1) {
                cameraTransition.animId = requestAnimationFrame(animateCamera);
            } else {
                cameraTransition = null;
                if (onComplete) onComplete();
            }
        }
        
        cameraTransition = { animId: requestAnimationFrame(animateCamera), onComplete: onComplete };
    }
    
    function focusOnPlayerPeg(playerIndex, onComplete = null) {
        // Never override manual mode, active interaction, or while player is choosing a flashing hole
        if (userOverrideCamera || userIsInteracting || currentCameraView === 'manual' || highlightsActive) {
            if (onComplete) onComplete();
            return;
        }
        
        const player = gameState?.players?.[playerIndex];
        if (!player || !player.peg) {
            if (onComplete) onComplete();
            return;
        }
        
        // --- Camera focus PRIORITY ORDER ---
        // 1. Bullseye/center peg (highest priority)
        // 2. Fast track peg
        // 3. Leading peg on the board
        // 4. Home hole ONLY if ALL pegs are in holding (no board pegs to focus on)
        
        let focusPeg = null;
        let focusOnHome = false;
        
        const isHolding = p => p.holeType === 'holding' || (p.holeId && p.holeId.startsWith('hold-'));
        const allInHolding = player.peg.every(isHolding);
        
        // Priority 1: Check for a peg in the bullseye (center)
        const bullseyePeg = player.peg.find(p => p.holeId === 'center' || p.inBullseye);
        if (bullseyePeg) {
            focusPeg = bullseyePeg;
        }
        
        // Priority 2: Check for a peg on the fast track
        if (!focusPeg) {
            const ftPeg = player.peg.find(p => p.onFasttrack || (p.holeId && p.holeId.startsWith('ft-')));
            if (ftPeg) {
                focusPeg = ftPeg;
            }
        }
        
        // Priority 3: Leading peg on the board
        if (!focusPeg) {
            const leadingPeg = getLeadingPeg(playerIndex);
            if (leadingPeg && !isHolding(leadingPeg)) {
                focusPeg = leadingPeg;
            }
        }
        
        // Priority 4: Home hole ONLY when ALL pegs are in holding
        if (!focusPeg && allInHolding) {
            focusOnHome = true;
        }
        
        // --- Determine camera closeness based on peg spread ---
        // Collect world positions of all non-holding pegs to measure spread
        let pegPositions = [];
        for (const p of player.peg) {
            if (p.holeType === 'holding' || (p.holeId && p.holeId.startsWith('hold-'))) continue;
            const po = pegRegistry.get(p.id);
            if (po && po.mesh) pegPositions.push(po.mesh.position);
        }
        
        // Measure max distance between any two pegs
        let maxSpread = 0;
        for (let i = 0; i < pegPositions.length; i++) {
            for (let j = i + 1; j < pegPositions.length; j++) {
                const dx = pegPositions[i].x - pegPositions[j].x;
                const dz = pegPositions[i].z - pegPositions[j].z;
                maxSpread = Math.max(maxSpread, Math.sqrt(dx * dx + dz * dz));
            }
        }
        
        // Close-up when pegs are clustered, pull back when spread far apart
        // Spread < 100 â†’ tight closeup, spread > 350 â†’ wide view
        const spreadFactor = Math.min(1, Math.max(0, (maxSpread - 100) / 250));
        const camHeight = 200 + spreadFactor * 250;     // 200 (close) â†’ 450 (far)
        const camPull   = 0.65 - spreadFactor * 0.35;   // 0.65 (close) â†’ 0.3 (far)
        const camOffset = 80 + spreadFactor * 150;       // 80 (close) â†’ 230 (far)
        
        // Focus on the home hole
        if (focusOnHome) {
            const boardPos = player.boardPosition;
            const homeHole = holeRegistry.get(`home-${boardPos}`);
            if (homeHole && homeHole.position) {
                smoothCameraTransition(
                    { x: homeHole.position.x * camPull, y: camHeight, z: homeHole.position.z * camPull + camOffset },
                    { x: homeHole.position.x, y: 0, z: homeHole.position.z },
                    2500,
                    onComplete
                );
            } else if (onComplete) {
                onComplete();
            }
            return;
        }
        
        // Focus on the priority peg
        if (focusPeg) {
            const pegObj = pegRegistry.get(focusPeg.id);
            if (!pegObj || !pegObj.mesh) {
                if (onComplete) onComplete();
                return;
            }
            
            const pegPos = pegObj.mesh.position;
            
            smoothCameraTransition(
                { x: pegPos.x * camPull, y: camHeight, z: pegPos.z * camPull + camOffset },
                { x: pegPos.x, y: 0, z: pegPos.z },
                2500,
                onComplete
            );
            return;
        }
        
        if (onComplete) onComplete();
    }
    
    // Move camera TOWARD the destination choices so the player can see them up close.
    // If choices are spread far apart, pull back just enough to frame them all.
    function focusOnChoices(moves) {
        if (userOverrideCamera || userIsInteracting || currentCameraView === 'manual') return;
        if (!moves || moves.length === 0) return;
        
        // Gather world positions of all destination holes
        const positions = [];
        for (const m of moves) {
            const hole = holeRegistry.get(m.toHoleId);
            if (!hole) continue;
            const hx = hole.position ? hole.position.x : hole.x;
            const hz = hole.position ? hole.position.z : hole.z;
            if (hx !== undefined && hz !== undefined) positions.push({ x: hx, z: hz });
        }
        if (positions.length === 0) return;
        
        // Compute bounding box center and diagonal extent
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        for (const p of positions) {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.z < minZ) minZ = p.z;
            if (p.z > maxZ) maxZ = p.z;
        }
        const cx = (minX + maxX) / 2;
        const cz = (minZ + maxZ) / 2;
        const spread = Math.sqrt((maxX - minX) ** 2 + (maxZ - minZ) ** 2);
        
        // Adaptive height/distance: tight closeup for clustered choices, wider for spread
        // spread < 50 â†’ very close, spread > 300 â†’ moderately pulled back
        const t = Math.min(1, Math.max(0, (spread - 50) / 250));
        const camH   = 180 + t * 200;     // 180 (close) â†’ 380 (wide)
        const camPull = 0.7 - t * 0.4;    // 0.7 (close) â†’ 0.3 (wide)
        const camOff  = 60 + t * 120;     // 60 (close) â†’ 180 (wide)
        
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
            // Mobile: if spread is huge, do top-down; otherwise get close
            if (spread > 250) {
                smoothCameraTransition(
                    { x: cx * 0.15, y: 550, z: cz * 0.15 + 1 },
                    { x: cx, y: 0, z: cz },
                    2000
                );
                enterDecisionMode();
            } else {
                smoothCameraTransition(
                    { x: cx * camPull, y: camH, z: cz * camPull + camOff },
                    { x: cx, y: 0, z: cz },
                    2000
                );
            }
        } else {
            smoothCameraTransition(
                { x: cx * camPull, y: camH, z: cz * camPull + camOff },
                { x: cx, y: 0, z: cz },
                2500
            );
        }
    }
    
    function panOutForBoardView() {
        // Never override manual mode, active interaction, or while choices are shown
        if (userOverrideCamera || userIsInteracting || currentCameraView === 'manual' || highlightsActive) return;
        
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            // MOBILE: Straight-down top view for full board visibility
            // This allows player to see all options at once and make decisions easily
            smoothCameraTransition(
                { x: 0, y: 650, z: 1 },  // Nearly straight down (tiny z to avoid gimbal lock)
                { x: 0, y: 0, z: 0 },
                2000  // Faster transition for mobile
            );
            // Enter decision mode - hide panels for full board view
            enterDecisionMode();
        } else {
            // DESKTOP: 30Â° angle view of the board â€” clear view of all holes
            smoothCameraTransition(
                { x: 0, y: 320, z: 554 },
                { x: 0, y: 0, z: 0 },
                2500
            );
        }
    }
    
    // Decision mode - hide UI panels on mobile so player sees entire board
    let isDecisionMode = false;
    
    function enterDecisionMode() {
        if (isDecisionMode) return;
        isDecisionMode = true;
        
        const isMobile = window.innerWidth <= 768;
        if (!isMobile) return;
        
        console.log('[Camera] Entering decision mode - hiding panels');
        
        // Hide mobile header
        const mobileHeader = document.getElementById('mobile-header');
        if (mobileHeader) mobileHeader.style.display = 'none';
        
        // Hide floating card
        const floatingCard = document.getElementById('mobile-floating-card');
        if (floatingCard) floatingCard.style.display = 'none';
        
        // Hide mobile action bar (will be shown via showMoves if needed)
        const actionBar = document.getElementById('mobile-action-bar');
        if (actionBar) actionBar.classList.remove('has-moves');
        
        // Hide reaction bar
        const reactionBar = document.getElementById('reaction-bar');
        if (reactionBar) reactionBar.style.display = 'none';
    }
    
    function exitDecisionMode() {
        if (!isDecisionMode) return;
        isDecisionMode = false;
        
        const isMobile = window.innerWidth <= 768;
        if (!isMobile) return;
        
        console.log('[Camera] Exiting decision mode - showing panels');
        
        // Show mobile header (uses flex display)
        const mobileHeader = document.getElementById('mobile-header');
        if (mobileHeader) mobileHeader.style.display = '';  // Restore to CSS default
        
        // Clear inline style on floating card (CSS controls visibility)
        const floatingCard = document.getElementById('mobile-floating-card');
        if (floatingCard) floatingCard.style.display = '';
        
        // Clear inline style on reaction bar
        const reactionBar = document.getElementById('reaction-bar');
        if (reactionBar) reactionBar.style.display = '';
    }
    
    // Export for use by game callbacks
    window.enterDecisionMode = enterDecisionMode;
    window.exitDecisionMode = exitDecisionMode;
    
    function resetCameraOverride() {
        // Only reset override if user is NOT actively interacting
        // and camera is not in manual mode or board view mode
        // Also respect if user has explicitly set a camera mode
        if (userIsInteracting ||
            currentCameraView === 'manual' ||
            boardViewMode > 0 ||
            window.currentCameraMode === 'manual' ||
            window.currentCameraMode === 'board') {
            return;
        }
        userOverrideCamera = false;
    }

    // ============================================================
    // WINDOW RESIZE
    // ============================================================
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ============================================================
    // ANIMATION LOOP
    // ============================================================
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        // Smooth mouse tracking for parallax
        mouseX += (targetMouseX - mouseX) * 0.05;
        mouseY += (targetMouseY - mouseY) * 0.05;

        // Update theme parallax and animations
        if (window.FastTrackThemes) {
            FastTrackThemes.update(mouseX, mouseY);
            FastTrackThemes.updateSpectators(Date.now() * 0.001);
        }

        // Update Fibonacci backdrop animation (Board View mode)
        if (fibonacciBackdrop && fibonacciBackdrop.isActive) {
            fibonacciBackdrop.update(0.016); // ~60fps delta time
        }

        // Animate golden crowns (oscillate + glow pulse)
        if (window._goldenCrowns) {
            const t = Date.now() * 0.001;
            for (const crown of window._goldenCrowns) {
                if (!crown.active) continue;
                // Gentle bobbing (oscillate Y position)
                const baseY = LINE_HEIGHT + 12;
                crown.mesh.position.y = baseY + Math.sin(t * 1.5) * 1.5;
                // Slow rotation
                crown.mesh.rotation.y = t * 0.5;
                // Pulsing glow
                const pulse = 0.5 + 0.5 * Math.sin(t * 2.5);
                crown.pointLight.intensity = 1.5 + pulse * 2;
                crown.material.emissiveIntensity = 0.4 + pulse * 0.6;
            }
        }
        
        renderer.render(scene, camera);
    }
    
    function onMouseMove(event) {
        targetMouseX = (event.clientX / window.innerWidth - 0.5) * 2;
        targetMouseY = (event.clientY / window.innerHeight - 0.5) * 2;
    }
    
    // ============================================================
    // THEME SWITCHER
    // ============================================================
    
    function setTheme(themeName) {
        console.log('[Theme] Switching to:', themeName);

        // â”€â”€ Analytics: Track theme change (skip during demo/promo auto-rotation) â”€â”€
        if (window.FTAnalytics && !window.DemoDirector) {
            FTAnalytics.themeChange(themeName);
        }
        
        if (!window.FastTrackThemes) {
            console.error('[Theme] Theme system not loaded');
            return;
        }
        
        if (!scene) {
            console.error('[Theme] Scene not initialized');
            return;
        }
        
        try {
            currentThemeName = themeName;
            FastTrackThemes.apply(themeName, scene, THREE);
            // Keep backdrop motion frozen when switching themes unless explicitly enabled
            if (typeof FastTrackThemes.setMotionScale === 'function') {
                FastTrackThemes.setMotionScale(0);
            }
            console.log('[Theme] Applied successfully, backdrop layers:', FastTrackThemes.backdropLayers.length);
        } catch (err) {
            console.error('[Theme] Apply error:', err);
        }
        
        // Sync stadium audio theme with visual theme
        const themeMapping = {
            'cosmic': 'SPACE_ACE',
            'colosseum': 'ROMAN_COLISEUM',
            'spaceace': 'SPACE_ACE',
            'undersea': 'UNDERSEA',
            'highcontrast': 'DEFAULT',
            'fibonacci': 'FIBONACCI'
        };
        const stadiumTheme = themeMapping[themeName] || 'DEFAULT';
        if (typeof StadiumController !== 'undefined') {
            StadiumController.setTheme(stadiumTheme);
            const select = document.getElementById('stadiumThemeSelect');
            if (select) select.value = stadiumTheme;
        }
        // Sync game SFX theme
        if (typeof GameSFX !== 'undefined') {
            GameSFX.setTheme(stadiumTheme);
        }
        // Always sync music directly (StadiumController may not be wired)
        if (typeof MusicSubstrate !== 'undefined') {
            MusicSubstrate.setTheme(stadiumTheme);
        }
    }
    
    // ============================================================
    // STADIUM AUDIO CONTROLS
    // ============================================================
    
    function setStadiumTheme(themeName) {
        if (typeof StadiumController !== 'undefined') {
            StadiumController.setTheme(themeName);
        }
        // Sync game SFX theme
        if (typeof GameSFX !== 'undefined') {
            GameSFX.setTheme(themeName);
        }
    }
    
    function toggleStadiumMusic() {
        if (typeof StadiumController !== 'undefined') {
            const enabled = StadiumController.toggleMusic();
            updateStadiumButton('btn-music', enabled);
            if (enabled && StadiumController.systems.music) {
                // Play a brief sound check before starting music
                playSoundCheck('music');
                StadiumController.systems.music.play();
            }
        }
    }
    
    // â”€â”€ Music Toggle (floating button) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let gameMusicPlaying = false;
    let musicAutoStarted = false;  // Track if music already auto-started on first card draw
    
    function toggleGameMusic() {
        const btn = document.getElementById('music-toggle-btn');
        if (gameMusicPlaying) {
            // Turn OFF
            gameMusicPlaying = false;
            if (typeof MusicSubstrate !== 'undefined') {
                MusicSubstrate.stop();
            }
            if (typeof StadiumController !== 'undefined' && StadiumController.systems.music) {
                StadiumController.systems.music.stop?.();
            }
            if (btn) {
                btn.textContent = 'ğŸ”‡';
                btn.title = 'Music: OFF';
                btn.classList.remove('music-on');
            }
            console.log('ğŸµ Music OFF');
        } else {
            // Turn ON
            gameMusicPlaying = true;
            if (typeof MusicSubstrate !== 'undefined') {
                MusicSubstrate.activate();
                if (MusicSubstrate.play) MusicSubstrate.play();
            }
            if (typeof StadiumController !== 'undefined' && StadiumController.systems.music) {
                StadiumController.systems.music.play?.();
            }
            if (btn) {
                btn.textContent = 'ğŸµ';
                btn.title = 'Music: ON';
                btn.classList.add('music-on');
            }
            console.log('ğŸµ Music ON');
        }
    }
    window.toggleGameMusic = toggleGameMusic;
    
    // Auto-start music on first card draw by any player
    function autoStartMusicOnFirstDraw() {
        if (musicAutoStarted || gameMusicPlaying) return;
        musicAutoStarted = true;
        
        console.log('ğŸµ Auto-starting music on first card draw');
        gameMusicPlaying = true;
        
        if (typeof MusicSubstrate !== 'undefined') {
            MusicSubstrate.activate();
            if (MusicSubstrate.play) MusicSubstrate.play();
        }
        if (typeof StadiumController !== 'undefined' && StadiumController.systems.music) {
            StadiumController.systems.music.play?.();
        }
        
        const btn = document.getElementById('music-toggle-btn');
        if (btn) {
            btn.textContent = 'ğŸµ';
            btn.title = 'Music: ON';
            btn.classList.add('music-on');
        }
    }
    
    function toggleStadiumCrowd() {
        if (typeof StadiumController !== 'undefined') {
            const enabled = StadiumController.toggleCrowd();
            updateStadiumButton('btn-crowd', enabled);
            if (enabled && StadiumController.systems.crowd) {
                // Play a brief crowd sound check
                playSoundCheck('crowd');
                StadiumController.systems.crowd.startAmbient();
            }
        }
    }
    
    function toggleStadiumCommentary() {
        if (typeof StadiumController !== 'undefined') {
            const enabled = StadiumController.toggleCommentary();
            updateStadiumButton('btn-commentary', enabled);
            if (enabled) {
                // Play a brief commentary sound check
                playSoundCheck('commentary');
            }
        }
    }
    
    function toggleStadiumSpeech() {
        if (typeof StadiumController !== 'undefined') {
            const enabled = StadiumController.toggleSpeech();
            updateStadiumButton('btn-speech', enabled);
            if (enabled) {
                // Play a brief speech sound check
                playSoundCheck('speech');
            }
        }
    }
    
    // Sound check - plays a brief sample when audio is toggled on
    // Uses MusicSubstrate.ping() to generate sounds from substrate coordinates
    function playSoundCheck(type) {
        console.log(`ğŸ”Š [Sound Check] Starting ${type} sound check...`);
        
        // Use MusicSubstrate ping system if available
        if (typeof MusicSubstrate !== 'undefined') {
            console.log(`ğŸ”Š [Sound Check] MusicSubstrate available`);
            
            // Ensure substrate is activated
            const activated = MusicSubstrate.activate();
            console.log(`ğŸ”Š [Sound Check] Activated: ${activated}, Context state: ${MusicSubstrate.audioContext?.state}`);
            
            if (type === 'music') {
                // Ping a musical arpeggio across the substrate
                console.log(`ğŸ”Š [Sound Check] Calling pingSoundCheck()`);
                MusicSubstrate.pingSoundCheck();
            } else if (type === 'crowd') {
                // Ping multiple random points for crowd-like texture
                console.log(`ğŸ”Š [Sound Check] Calling pingChord() for crowd`);
                const crowdPings = [
                    { x: Math.random() * 100, y: Math.random() * 30 },
                    { x: Math.random() * 100, y: Math.random() * 30 },
                    { x: Math.random() * 100, y: Math.random() * 30 },
                    { x: Math.random() * 100, y: Math.random() * 30 },
                    { x: Math.random() * 100, y: Math.random() * 30 }
                ];
                MusicSubstrate.pingChord(crowdPings, { duration: 0.6, volume: 0.15 });
            } else if (type === 'commentary' || type === 'speech') {
                // Use speech synthesis for commentary
                if ('speechSynthesis' in window) {
                    console.log(`ğŸ”Š [Sound Check] Using speech synthesis`);
                    const utterance = new SpeechSynthesisUtterance('Sound check!');
                    utterance.rate = 1.2;
                    utterance.pitch = type === 'commentary' ? 0.9 : 1.0;
                    utterance.volume = 0.8;
                    window.speechSynthesis.speak(utterance);
                } else {
                    // Fallback: ping a single attention tone
                    console.log(`ğŸ”Š [Sound Check] Fallback ping for ${type}`);
                    MusicSubstrate.ping(50, 70, { duration: 0.3, volume: 0.2 });
                }
            }
            return;
        }
        
        // Fallback if MusicSubstrate not available - use raw Web Audio
        let ctx = null;
        try {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Cannot create audio context for sound check:', e);
            return;
        }
        
        // Resume context if suspended
        if (ctx.state === 'suspended') {
            ctx.resume().then(() => {
                playSoundCheckFallback(ctx, type);
            }).catch(e => console.warn('Failed to resume audio context:', e));
        } else {
            playSoundCheckFallback(ctx, type);
        }
    }
    
    // Fallback sound check without MusicSubstrate
    function playSoundCheckFallback(ctx, type) {
        const now = ctx.currentTime;
        
        if (type === 'music') {
            const notes = [261.63, 329.63, 392.00, 523.25];
            notes.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0, now + i * 0.15);
                gain.gain.linearRampToValueAtTime(0.2, now + i * 0.15 + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.25);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now + i * 0.15);
                osc.stop(now + i * 0.15 + 0.3);
            });
        } else if (type === 'crowd') {
            const bufferSize = ctx.sampleRate * 0.8;
            const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 800;
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            noise.start(now);
            noise.stop(now + 0.8);
        } else if (type === 'commentary' || type === 'speech') {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('Sound check!');
                utterance.rate = 1.2;
                utterance.volume = 0.8;
                window.speechSynthesis.speak(utterance);
            }
        }
        
        setTimeout(() => {
            if (ctx && ctx.state !== 'closed') ctx.close().catch(() => {});
        }, 2000);
    }
    
    function updateStadiumButton(btnId, enabled) {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.style.opacity = enabled ? '1' : '0.4';
            btn.style.borderColor = enabled ? '#4CAF50' : '#555';
        }
    }
    
    // ============================================================
    // MOVE HINT MODE CONTROLS
    // ============================================================
    
    function setHintMode(mode) {
        GAME_CONFIG.hintMode = mode;
        console.log('[Hints] Mode set to:', mode);
        
        // Update button visuals
        const modes = ['blink', 'dropdown', 'voice', 'all', 'none'];
        modes.forEach(m => {
            const btn = document.getElementById(`btn-hint-${m}`);
            if (btn) {
                if (m === mode) {
                    btn.style.background = '#4a4a6e';
                    btn.style.borderColor = '#888';
                } else {
                    btn.style.background = '#2a2a3e';
                    btn.style.borderColor = '#555';
                }
            }
        });
        
        // ALWAYS show highlights (blinking holes) UNLESS 'none' mode is selected
        // Blinking destination holes is the PRIMARY visual feedback for all modes
        // Other modes (dropdown, voice) are OPTIONAL overlays on top of blinking
        GAME_CONFIG.showHighlights = (mode !== 'none');
        
        // Announce mode change if voice mode selected
        if ((mode === 'voice' || mode === 'all') && 'speechSynthesis' in window) {
            const modeNames = {
                'blink': 'Visual hints mode - holes will blink',
                'dropdown': 'Dropdown list mode with blinking holes',
                'voice': 'Voice hints with blinking holes',
                'all': 'All hints enabled',
                'none': 'Hints disabled - expert mode'
            };
            const utterance = new SpeechSynthesisUtterance(modeNames[mode] || 'Hint mode changed');
            utterance.rate = 1.1;
            utterance.volume = 0.7;
            window.speechSynthesis.speak(utterance);
        }
    }
    
    // Toggle move suggestion popups on/off
    function toggleSuggestions() {
        GAME_CONFIG.suggestionsDisabled = !GAME_CONFIG.suggestionsDisabled;
        const btn = document.getElementById('suggestions-toggle');
        if (btn) {
            if (GAME_CONFIG.suggestionsDisabled) {
                btn.textContent = 'ğŸ’¡ Suggestions OFF';
                btn.style.color = '#888';
                btn.style.borderColor = '#555';
            } else {
                btn.textContent = 'ğŸ’¡ Suggestions ON';
                btn.style.color = '#ffd700';
                btn.style.borderColor = '#ffd700';
            }
        }
        // If a suggestion modal is currently visible, close it
        hideMoveChoiceModal();
        if (window.moveSelectionModal) {
            window.moveSelectionModal.hide();
        }
        console.log('[Suggestions]', GAME_CONFIG.suggestionsDisabled ? 'DISABLED' : 'ENABLED');
    }
    window.toggleSuggestions = toggleSuggestions;
    
    // Generate descriptive move label
    function getMoveDescription(move, includeToken = false) {
        const fromHole = holeRegistry.get(move.fromHoleId);
        const toHole = holeRegistry.get(move.toHoleId);
        
        // Get peg label prefix if including token identity
        let prefix = '';
        if (includeToken && move.pegId) {
            const peg = pegRegistry.get(move.pegId);
            if (peg) {
                prefix = `${getPegLabel(move.pegId, peg.colorIndex)}: `;
            }
        }
        
        // Use move's own description if provided
        if (move.description) return prefix + move.description;
        
        // Check for cut target first - most exciting move!
        const cutTarget = findCutTargetAtHole(move.toHoleId);
        if (cutTarget) {
            return `${prefix}âš”ï¸ Capture ${cutTarget.player.name}`;
        }
        
        // Entry from holding
        if (move.type === 'enter' || fromHole?.type === 'holding') {
            return `${prefix}ğŸš€ Enter the board`;
        }
        
        // Bullseye moves
        if (toHole?.type === 'bullseye' || move.toHoleId === 'center') {
            return `${prefix}ğŸ¯ Enter Bullseye`;
        }
        if (fromHole?.type === 'bullseye' || move.fromHoleId === 'center') {
            return `${prefix}ğŸ¯ Exit Bullseye`;
        }
        
        // FastTrack moves
        if (move.isFastTrack || move.enteringFastTrack) {
            return `${prefix}âš¡ Traverse Fast Track`;
        }
        if (move.exitingFastTrack) {
            return `${prefix}ğŸšª Exit Fast Track`;
        }
        if (toHole?.type === 'fasttrack' && fromHole?.type !== 'fasttrack') {
            return `${prefix}âš¡ Enter Fast Track`;
        }
        if (fromHole?.type === 'fasttrack' && toHole?.type !== 'fasttrack') {
            return `${prefix}ğŸšª Leave Fast Track at this point`;
        }
        
        // Safe zone moves
        if (toHole?.type === 'safezone' || toHole?.type === 'safe') {
            return `${prefix}ğŸ›¡ï¸ Enter Safe Zone`;
        }
        if (fromHole?.type === 'safezone' && toHole?.type === 'safezone') {
            return `${prefix}ğŸ§¹ Tidy Up Safe Zone`;
        }
        
        // Winner move
        if (toHole?.type === 'home' && (move.isWinner || move.completesCircuit)) {
            return `${prefix}ğŸ† Winner!`;
        }
        
        // Backward move (4 card)
        if (move.direction === 'backward' || move.steps < 0) {
            return `${prefix}â¬…ï¸ Go Back 4`;
        }
        
        // Decline options
        if (move.declineFastTrack) {
            return `${prefix}ğŸš« Decline Fast Track`;
        }
        if (move.declineBullseye) {
            return `${prefix}ğŸš« Decline Bullseye`;
        }
        
        // Default
        return `${prefix}Move ${move.steps || '?'} spaces`;
    }
    
    // Speak legal moves using voice synthesis
    function speakLegalMoves(moves) {
        if (!('speechSynthesis' in window)) return;
        if (GAME_CONFIG.hintMode !== 'voice' && GAME_CONFIG.hintMode !== 'all') return;
        
        if (moves.length === 0) {
            const utterance = new SpeechSynthesisUtterance('No legal moves available');
            utterance.rate = 1.2;
            window.speechSynthesis.speak(utterance);
            return;
        }
        
        // Build move descriptions
        const moveDescriptions = moves.slice(0, 5).map((move, i) => {
            return getMoveDescription(move);
        });
        
        const text = moves.length === 1 
            ? `One move available: ${moveDescriptions[0]}`
            : `${moves.length} moves available. ${moveDescriptions.join('. ')}`;
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.3;
        utterance.volume = 0.8;
        window.speechSynthesis.speak(utterance);
    }
    
    // Show dropdown suggestion list for moves
    function showMoveDropdown(moves) {
        if (GAME_CONFIG.hintMode !== 'dropdown' && GAME_CONFIG.hintMode !== 'all') return;
        
        // Remove existing dropdown
        const existing = document.getElementById('move-suggestion-dropdown');
        if (existing) existing.remove();
        
        if (moves.length === 0) return;
        
        const dropdown = document.createElement('div');
        dropdown.id = 'move-suggestion-dropdown';
        dropdown.style.cssText = `
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(30, 30, 50, 0.95);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 10px;
            z-index: 9000;
            max-height: 300px;
            overflow-y: auto;
            min-width: 200px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        `;
        
        const title = document.createElement('div');
        title.style.cssText = 'color: #ffd700; font-weight: bold; margin-bottom: 8px; font-size: 14px;';
        title.textContent = `ğŸ“‹ ${moves.length} Legal Moves`;
        dropdown.appendChild(title);
        
        // Check if moves involve multiple different pegs
        const uniquePegIds = new Set(moves.map(m => m.pegId).filter(Boolean));
        const multipleTokens = uniquePegIds.size > 1;
        
        // Show number labels on pegs when multiple can move
        if (multipleTokens) {
            showPegNumbers([...uniquePegIds]);
        }
        
        moves.forEach((move, i) => {
            const toHole = holeRegistry.get(move.toHoleId);
            const option = document.createElement('div');
            option.style.cssText = `
                padding: 8px 12px;
                margin: 4px 0;
                background: #3a3a5a;
                border-radius: 6px;
                cursor: pointer;
                color: #fff;
                font-size: 13px;
                transition: background 0.2s;
            `;
            
            // Use descriptive label with token ID when multiple pegs can move
            const label = getMoveDescription(move, multipleTokens);
            
            option.textContent = label;
            option.title = multipleTokens && move.pegId ? getPegLabel(move.pegId, pegRegistry.get(move.pegId)?.colorIndex || 0) : '';
            option.onmouseover = () => option.style.background = '#5a5a7a';
            option.onmouseout = () => option.style.background = '#3a3a5a';
            option.onclick = () => {
                dropdown.remove();
                hidePegNumbers();
                executeMoveDirectly(move);
            };
            
            dropdown.appendChild(option);
        });
        
        // Close button
        const closeBtn = document.createElement('div');
        closeBtn.style.cssText = 'text-align: center; color: #888; font-size: 11px; margin-top: 8px; cursor: pointer;';
        closeBtn.textContent = '(click move or tap board)';
        closeBtn.onclick = () => {
            dropdown.remove();
            hidePegNumbers();
        };
        dropdown.appendChild(closeBtn);
        
        document.body.appendChild(dropdown);
    }
    
    // Hide move dropdown
    function hideMoveDropdown() {
        const dropdown = document.getElementById('move-suggestion-dropdown');
        if (dropdown) dropdown.remove();
    }
    
    // Expose to window
    window.setHintMode = setHintMode;
    
    // ============================================================
    // SETTINGS PANEL TOGGLE (Legacy - removed, using GameUIMinimal menu)
    // ============================================================
    
    window.toggleSettingsPanel = function() {
        // Legacy stub â€” settings are now in GameUIMinimal hamburger menu
        if (window.GameUIMinimal) {
            window.GameUIMinimal.toggleMenu();
        }
    };
    
    // ============================================================
    // MOVE MODE TOGGLE (Auto vs Manual)
    // ============================================================
    
    function setMoveMode(mode) {
        const isAuto = (mode === 'auto');
        GAME_CONFIG.autoMoveForHumans = isAuto;
        console.log('[MoveMode] Set to:', mode, 'autoMoveForHumans:', isAuto);
        
        // Update button visuals
        const autoBtn = document.getElementById('btn-move-auto');
        const manualBtn = document.getElementById('btn-move-manual');
        
        if (autoBtn) {
            autoBtn.style.background = isAuto ? '#4a4a6e' : '#2a2a3e';
            autoBtn.style.borderColor = isAuto ? '#888' : '#555';
        }
        if (manualBtn) {
            manualBtn.style.background = isAuto ? '#2a2a3e' : '#4a4a6e';
            manualBtn.style.borderColor = isAuto ? '#555' : '#888';
        }
        
        // Also sync the pause menu toggle
        const pauseToggle = document.getElementById('auto-move-toggle');
        const pauseLabel = document.getElementById('auto-move-label');
        if (pauseToggle) pauseToggle.checked = isAuto;
        if (pauseLabel) pauseLabel.textContent = isAuto ? 'ON' : 'OFF';
    }
    
    // Expose to window
    window.setMoveMode = setMoveMode;
    
    // ============================================================
    // PLAYER REACTIONS (Desktop)
    // ============================================================
    
    function sendDesktopReaction(emoji, reactionName) {
        console.log('[Reactions] Sending:', reactionName, emoji);
        
        // Play reaction sound effect
        if (window.MusicSubstrate && window.MusicSubstrate.playReactionSound) {
            window.MusicSubstrate.playReactionSound(reactionName);
        }
        
        // Create floating animation
        showFloatingReactionDesktop(emoji);
        
        // Broadcast to other players if multiplayer
        if (window.gameStateBroadcaster) {
            window.gameStateBroadcaster.broadcastReaction({
                emoji: emoji,
                name: reactionName,
                playerId: window.gameState?.currentPlayerId || 'local',
                timestamp: Date.now()
            });
        }
    }
    
    function showFloatingReactionDesktop(emoji) {
        const el = document.createElement('div');
        el.textContent = emoji;
        
        // Random position across the screen
        const startX = 50 + Math.random() * (window.innerWidth - 200);
        const startY = window.innerHeight * 0.6 + Math.random() * (window.innerHeight * 0.3);
        
        el.style.cssText = `
            position: fixed;
            left: ${startX}px;
            top: ${startY}px;
            font-size: 120px;
            pointer-events: none;
            z-index: 10002;
            text-shadow: 0 8px 30px rgba(0,0,0,0.6);
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));
            will-change: transform, opacity;
        `;
        
        document.body.appendChild(el);
        
        // JavaScript-driven animation (immune to CSS conflicts)
        const duration = 3000;
        const startTime = performance.now();
        
        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Easing function
            const eased = 1 - Math.pow(1 - progress, 3);
            
            // Float up 350px
            const translateY = -350 * eased;
            
            // Scale from 1 to 2.5
            const scale = 1 + (1.5 * eased);
            
            // Wobble rotation
            const wobble = Math.sin(progress * Math.PI * 4) * 8 * (1 - progress);
            
            // Fade out in last 30%
            const opacity = progress > 0.7 ? 1 - ((progress - 0.7) / 0.3) : 1;
            
            el.style.transform = `translateY(${translateY}px) scale(${scale}) rotate(${wobble}deg)`;
            el.style.opacity = opacity;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                el.remove();
            }
        }
        
        requestAnimationFrame(animate);
    }
    
    // Make it globally available
    window.sendDesktopReaction = sendDesktopReaction;

    /**
     * AI Chat Bubble â€” bots express personality with floating text messages!
     * Shows a styled chat bubble with the bot's message, floating up and fading out.
     * This makes bots feel alive and friendly â€” they're not just silent algorithms.
     * @param {string} message - The chat message text (with emoji)
     * @param {string} [botName] - Optional bot name for attribution
     * @param {Object} [options] - Optional styling overrides
     */
    function aiSendChatBubble(message, botName, options = {}) {
        if (!AI_REACTIONS.enabled) return;

        const el = document.createElement('div');
        const displayMsg = botName ? `${botName}: ${message}` : message;
        el.textContent = displayMsg;
        
        // Position: random horizontal, bottom third of screen
        const startX = 80 + Math.random() * (window.innerWidth - 400);
        const startY = window.innerHeight * 0.55 + Math.random() * (window.innerHeight * 0.2);
        
        const bgColor = options.bg || 'rgba(30, 30, 60, 0.92)';
        const borderColor = options.border || 'rgba(100, 180, 255, 0.5)';
        const textColor = options.color || '#fff';
        
        el.style.cssText = `
            position: fixed;
            left: ${startX}px;
            top: ${startY}px;
            font-size: 18px;
            font-weight: 600;
            color: ${textColor};
            background: ${bgColor};
            border: 1px solid ${borderColor};
            border-radius: 16px;
            padding: 10px 18px;
            pointer-events: none;
            z-index: 10003;
            max-width: 320px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4), 0 0 15px rgba(100,180,255,0.15);
            will-change: transform, opacity;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            letter-spacing: 0.3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        `;
        
        document.body.appendChild(el);
        
        // Float up and fade out animation
        const duration = 4000;
        const startTime = performance.now();
        
        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);
            
            const translateY = -200 * eased;
            const opacity = progress > 0.65 ? 1 - ((progress - 0.65) / 0.35) : 1;
            const scale = progress < 0.1 ? 0.8 + 0.2 * (progress / 0.1) : 1;
            
            el.style.transform = `translateY(${translateY}px) scale(${scale})`;
            el.style.opacity = opacity;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                el.remove();
            }
        }
        
        requestAnimationFrame(animate);
    }
    
    // Make globally available
    window.aiSendChatBubble = aiSendChatBubble;
    
    // ============================================================
    // DRAGGABLE REACTION BAR
    // ============================================================
    
    (function initDraggableReactions() {
        const bar = document.getElementById('floating-reactions');
        if (!bar) return;
        
        let isDragging = false;
        let startX, startY, startLeft, startTop;
        let hasBeenDragged = false;
        
        function onMouseDown(e) {
            // Only drag if clicking on handle or bar background
            if (e.target.classList.contains('reaction-btn-desktop')) return;
            
            isDragging = true;
            bar.classList.add('dragging');
            
            const rect = bar.getBoundingClientRect();
            startX = e.clientX || e.touches?.[0]?.clientX;
            startY = e.clientY || e.touches?.[0]?.clientY;
            startLeft = rect.left;
            startTop = rect.top;
            
            // Remove the centering transform once user starts dragging
            if (!hasBeenDragged) {
                bar.style.transform = 'none';
                bar.style.left = startLeft + 'px';
                bar.style.top = startTop + 'px';
                hasBeenDragged = true;
            }
            
            e.preventDefault();
        }
        
        function onMouseMove(e) {
            if (!isDragging) return;
            
            const clientX = e.clientX || e.touches?.[0]?.clientX;
            const clientY = e.clientY || e.touches?.[0]?.clientY;
            
            const dx = clientX - startX;
            const dy = clientY - startY;
            
            const newLeft = Math.max(0, Math.min(window.innerWidth - bar.offsetWidth, startLeft + dx));
            const newTop = Math.max(0, Math.min(window.innerHeight - bar.offsetHeight, startTop + dy));
            
            bar.style.left = newLeft + 'px';
            bar.style.top = newTop + 'px';
            bar.style.right = 'auto';
            bar.style.bottom = 'auto';
        }
        
        function onMouseUp() {
            isDragging = false;
            bar.classList.remove('dragging');
        }
        
        // Mouse events
        bar.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        
        // Touch events
        bar.addEventListener('touchstart', onMouseDown, { passive: false });
        document.addEventListener('touchmove', onMouseMove, { passive: true });
        document.addEventListener('touchend', onMouseUp);
    })();
    
    // ============================================================
    // APPLY BOARD THEME - Update board, border, and peg colors
    // ============================================================
    
    function applyBoardTheme(palette) {
        if (!palette) return;
        
        currentBoardPalette = palette;
        console.log('Applying board palette:', palette);
        
        // Update board material
        if (boardMesh && boardMesh.material) {
            boardMesh.material.color.setHex(palette.boardColor);
            if (palette.boardRoughness !== undefined) {
                boardMesh.material.roughness = palette.boardRoughness;
            }
            if (palette.boardMetalness !== undefined) {
                boardMesh.material.metalness = palette.boardMetalness;
            }
            boardMesh.material.needsUpdate = true;
        }
        
        // Update border segments with new player colors
        borderSegments.forEach((segment, i) => {
            if (segment && segment.material && palette.playerColors && palette.playerColors[i]) {
                const newColor = palette.playerColors[i];
                segment.material.color.setHex(newColor);
                segment.material.emissive.setHex(newColor);
                segment.material.needsUpdate = true;
            }
        });
        
        // Update existing pegs with new colors (use colorIndex to match board areas)
        pegRegistry.forEach((peg, id) => {
            const colorIndex = peg.colorIndex !== undefined ? peg.colorIndex : peg.playerIndex;
            if (palette.playerColors && palette.playerColors[colorIndex]) {
                const newColor = palette.playerColors[colorIndex];
                
                // Update body mesh
                if (peg.bodyMesh && peg.bodyMesh.material) {
                    peg.bodyMesh.material.color.setHex(newColor);
                    peg.bodyMesh.material.emissive.setHex(newColor);
                    peg.bodyMesh.material.needsUpdate = true;
                }
                
                // Update disc mesh
                if (peg.discMesh && peg.discMesh.material) {
                    peg.discMesh.material.color.setHex(newColor);
                    peg.discMesh.material.emissive.setHex(newColor);
                    peg.discMesh.material.needsUpdate = true;
                }
                
                // Update stored color
                peg.color = newColor;
            }
        });
        
        // Update colored board markers (pentagons, diamonds, circles, bullseye rings)
        coloredMarkers.forEach(({ mesh, playerIndex }) => {
            if (palette.playerColors && palette.playerColors[playerIndex] && mesh.material) {
                const newColor = palette.playerColors[playerIndex];
                mesh.material.color.setHex(newColor);
                if (mesh.material.emissive) mesh.material.emissive.setHex(newColor);
                mesh.material.needsUpdate = true;
            }
        });
        
        // Update safe zone plane colors to match theme player colors
        safeZonePlanes.forEach(({ mesh, playerIndex }) => {
            if (palette.playerColors && palette.playerColors[playerIndex] && mesh.material) {
                mesh.material.color.setHex(palette.playerColors[playerIndex]);
                mesh.material.needsUpdate = true;
            }
        });
        
        console.log('Board theme applied successfully');
    }
    
    // Make applyBoardTheme globally accessible for theme system
    window.applyBoardTheme = applyBoardTheme;
    
    // ============================================================
    // TEST REACTION BUTTONS
    // ============================================================
    
    // Helper to get current theme's player color (by board position, not player index)
    // playerIndex is converted to boardPosition to match area colors
    function getThemedPlayerColor(playerIndex) {
        // Convert player index to board position to match area colors
        const boardPos = getBalancedBoardPosition(playerIndex, activePlayerCount);
        if (currentBoardPalette && currentBoardPalette.playerColors) {
            return currentBoardPalette.playerColors[boardPos] || 0xffd700;
        }
        return RAINBOW_COLORS[boardPos] || 0xffd700;
    }
    
    // Get color directly by board position (0-5), no conversion
    function getColorByBoardPosition(boardPos) {
        if (currentBoardPalette && currentBoardPalette.playerColors) {
            return currentBoardPalette.playerColors[boardPos] || 0xffd700;
        }
        return RAINBOW_COLORS[boardPos] || 0xffd700;
    }
    
    // Helper to convert suit name to symbol
    function getSuitSymbol(suitName) {
        const symbols = {
            'hearts': 'â™¥',
            'diamonds': 'â™¦',
            'clubs': 'â™£',
            'spades': 'â™ ',
            'red': 'â˜…',   // for red joker
            'black': 'â˜…'  // for black joker
        };
        return symbols[suitName] || '';
    }

    function testFastTrack() {
        if (!window.FastTrackThemes) return;
        
        // Get current player color from current theme palette
        const playerIndex = gameState?.currentPlayer?.index || 0;
        const playerColor = getThemedPlayerColor(playerIndex);
        const playerName = gameState?.currentPlayer?.name || 'Player 1';
        
        // Trigger the swirling effect
        triggerThemeSwirl();
        
        // Trigger the game event
        FastTrackThemes.triggerGameEvent('fasttrack', { 
            playerColor: playerColor,
            playerName: playerName 
        });
        
        console.log('ğŸš€ TEST: Fast Track triggered!');
    }
    
    function testSendHome() {
        if (!window.FastTrackThemes) return;
        
        const playerIndex = gameState?.currentPlayer?.index || 0;
        const playerColor = getThemedPlayerColor(playerIndex);
        
        FastTrackThemes.triggerGameEvent('sendHome', { 
            playerColor: playerColor 
        });
        
        console.log('ğŸ  TEST: Send Home triggered!');
    }
    
    function testWinner() {
        if (!window.FastTrackThemes) return;
        
        const playerIndex = gameState?.currentPlayer?.index || 0;
        const playerColor = getThemedPlayerColor(playerIndex);
        const playerName = gameState?.currentPlayer?.name || 'Player 1';
        const playerAvatar = gameState?.currentPlayer?.avatar || 'ğŸ‘¤';
        
        // Trigger swirl for winner too
        triggerThemeSwirl();
        
        // Custom winner banner with player avatar and name
        FastTrackThemes.showBanner(`${playerAvatar} ${playerName} WINS!`, '#FFD700', '#4B0082', playerColor);
        FastTrackThemes.triggerCrowdReaction('roaring');
        
        console.log('ğŸ† TEST: Winner triggered!');
    }
    
    function debugUI() {
        console.log('=== DEBUG UI ===');
        console.log('gameState:', gameState);
        console.log('window.playerPanelUI:', window.playerPanelUI);
        
        const panelsContainer = document.getElementById('player-panels');
        console.log('player-panels element:', panelsContainer);
        if (panelsContainer) {
            console.log('player-panels display:', panelsContainer.style.display);
            console.log('player-panels children:', panelsContainer.children.length);
            console.log('player-panels z-index:', window.getComputedStyle(panelsContainer).zIndex);
        }
        
        const startScreen = document.getElementById('start-game-screen');
        console.log('start-game-screen element:', startScreen);
        if (startScreen) {
            console.log('start-game-screen display:', startScreen.style.display);
            console.log('start-game-screen computed display:', window.getComputedStyle(startScreen).display);
        }
        
        // Force create panels if missing
        if (!window.playerPanelUI && typeof window.PlayerPanelUI === 'function') {
            console.log('Creating PlayerPanelUI manually...');
            window.playerPanelUI = new window.PlayerPanelUI();
            setupPlayerPanels(3);
        }
        
        // CardUI removed â€” no-op stub active
        
        console.log('=== END DEBUG ===');
    }
    window.debugUI = debugUI;
    
    // Dramatic swirling effect for major events
    function triggerThemeSwirl() {
        if (!window.FastTrackThemes) return;
        
        const duration = 3000; // 3 seconds of swirl
        const startTime = Date.now();
        
        // Store original rotation speeds
        const originalSpeeds = FastTrackThemes.backdropLayers.map(layer => ({
            rotation: layer.rotationSpeed || 0,
            parallax: layer.parallaxFactor || 0
        }));
        
        // Amplify all rotations dramatically
        FastTrackThemes.backdropLayers.forEach((layer, i) => {
            if (layer.rotationSpeed !== undefined) {
                layer.rotationSpeed = (originalSpeeds[i].rotation || 0.001) * 50;
            }
            if (layer.parallaxFactor !== undefined) {
                layer.parallaxFactor = originalSpeeds[i].parallax * 3;
            }
        });
        
        // Gradually restore
        const restoreSwirl = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easeOut = 1 - Math.pow(1 - progress, 3);
            
            FastTrackThemes.backdropLayers.forEach((layer, i) => {
                if (layer.rotationSpeed !== undefined) {
                    const maxSpeed = (originalSpeeds[i].rotation || 0.001) * 50;
                    layer.rotationSpeed = maxSpeed * (1 - easeOut) + originalSpeeds[i].rotation * easeOut;
                }
                if (layer.parallaxFactor !== undefined) {
                    const maxParallax = originalSpeeds[i].parallax * 3;
                    layer.parallaxFactor = maxParallax * (1 - easeOut) + originalSpeeds[i].parallax * easeOut;
                }
            });
            
            if (progress < 1) {
                requestAnimationFrame(restoreSwirl);
            }
        };
        
        requestAnimationFrame(restoreSwirl);
    }

    // ============================================================
    // START - Using jQuery for reliable initialization
    // ============================================================

    // jQuery's $(function() {...}) waits for DOM to be ready AND all scripts loaded
    // This is more reliable than window.onload or DOMContentLoaded alone
    // Fixes the issue where board doesn't load until hard refresh
    $(function() {
        console.log('ğŸ® jQuery ready - initializing game board...');
        init();
    });

    window.setCameraView = setCameraView;
    window.setCameraViewMode = setCameraViewMode;
    window.setTheme = setTheme;
    window.testFastTrack = testFastTrack;
    window.testSendHome = testSendHome;
    window.testWinner = testWinner;
    window.smoothCameraTransition = smoothCameraTransition;
    window.resetCameraOverride = function() { if (currentCameraView === 'manual') return; userOverrideCamera = false; userIsInteracting = false; highlightsActive = false; };
    </script>
    
    <!-- Rules Substrate (after board is defined) -->
    <script src="rules_substrate.js?v=20260223"></script>

    <!-- Promo Director (loaded only with ?promo=1) -->
    <script>
    (function() {
        const urlP = new URLSearchParams(window.location.search);
        if (urlP.has('promo')) {
            const s = document.createElement('script');
            s.src = 'promo_director.js?v=' + Date.now();
            document.head.appendChild(s);
            console.log('[Promo] Loading Promo Director...');
        }
        if (urlP.has('demo')) {
            const s = document.createElement('script');
            s.src = 'demo_director.js?v=' + Date.now();
            document.head.appendChild(s);
            console.log('[Demo] Loading Demo Director...');
        }
    })();
    </script>
    
    <script>
    // ============================================================
    // GAME INTEGRATION
    // ============================================================
    
    // Expose game state globally for multiplayer integration
    window.gameState = null;
    let gameState = null; // Local reference
    // cardUI stub â€” all methods are no-ops; showMessage delegates to showMsg toast
    const cardUI = new Proxy({}, {
        get(_, prop) {
            if (prop === 'showMessage') return (msg, dur) => showMsg(msg, dur);
            return () => {};
        }
    });
    window.cardUI = cardUI;
    // CardUI constructor stub â€” needed by GameInit.isReady() check
    window.CardUI = function CardUI() { return cardUI; };
    
    // Setter function so GameInit can update the local gameState reference
    window.setGameState = function(gs) {
        gameState = gs;
        window.gameState = gs;
        console.log('[setGameState] Local and window gameState synced:', !!gameState);
    };
    let legalMoves = [];
    let highlightedHoles = [];
    let highlightsActive = false;  // True while flashing destination holes are shown â€” blocks camera yanks
    
    // Expose legalMoves to external modules (ask_mom.js)
    // Uses a getter so window.legalMoves always reflects the local variable
    Object.defineProperty(window, 'legalMoves', {
        get() { return legalMoves; },
        set(v) { legalMoves = v; },
        configurable: true
    });
    
    // Track last winner for "winner goes first" on replay
    let lastWinnerIndex = null;
    let isReplayGame = false;
    
    // AI Player Configuration (must be defined before setupPlayerPanels)
    const AI_CONFIG = {
        enabled: true,
        players: [1, 2],  // AI controls players 1 and 2 (0 is human)
        thinkingDelay: 800,  // ms delay before AI makes move (overridden per-entity by ManifoldAI)
        drawDelay: 500,      // ms delay before AI draws card (overridden per-entity by ManifoldAI)
        useManifold: true    // Use ManifoldAI geometric decision engine
    };
    
    // AI Reaction Configuration - reactions AI can send based on turn outcomes
    // Philosophy: ALL bots love the human players. It's just fun and games!
    // They want the game to be exciting and competitive, but it's all in good spirit.
    const AI_REACTIONS = {
        enabled: true,
        probability: 0.75,  // 75% chance AI reacts to events
        // Reactions for positive outcomes (AI did something good)
        positive: [
            { emoji: 'ğŸ‰', name: 'celebrate' },
            { emoji: 'ğŸ”¥', name: 'fire' },
            { emoji: 'ğŸ’ƒ', name: 'dance' },
            { emoji: 'ğŸ¥³', name: 'party' }
        ],
        // Reactions when AI cuts an opponent â€” playful, not mean!
        cut: [
            { emoji: 'ğŸ˜œ', name: 'playful' },
            { emoji: 'ğŸ˜', name: 'smirk' },
            { emoji: 'ğŸ¤­', name: 'oopsie' },
            { emoji: 'ğŸ’…', name: 'sassy' },
            { emoji: 'ğŸ˜˜', name: 'kiss' }
        ],
        // Reactions for special moves (fasttrack, bullseye)
        special: [
            { emoji: 'ğŸ”¥', name: 'fire' },
            { emoji: 'ğŸ‰', name: 'celebrate' },
            { emoji: 'ğŸ‘', name: 'clap' },
            { emoji: 'âš¡', name: 'lightning' },
            { emoji: 'ğŸš€', name: 'rocket' }
        ],
        // Reactions when AI gets cut (negative) â€” good-spirited
        negative: [
            { emoji: 'ğŸ˜±', name: 'shock' },
            { emoji: 'ğŸ˜¤', name: 'determined' },
            { emoji: 'ğŸ«£', name: 'peekaboo' },
            { emoji: 'ğŸ˜…', name: 'sweat' },
            { emoji: 'ğŸ’ª', name: 'comeback' }
        ],
        // Reactions for close games / frustration â€” competitive but fun
        frustration: [
            { emoji: 'ğŸ˜¤', name: 'determined' },
            { emoji: 'ğŸ˜…', name: 'sweat' },
            { emoji: 'ğŸ¥´', name: 'dizzy' },
            { emoji: 'ğŸ¤¯', name: 'mindblown' }
        ],
        // NEW: Encouragement â€” when human makes a great move, bots cheer!
        encouragement: [
            { emoji: 'ğŸ‘', name: 'clap' },
            { emoji: 'ğŸ”¥', name: 'fire' },
            { emoji: 'ğŸ’ª', name: 'strong' },
            { emoji: 'ğŸ‘€', name: 'watchout' },
            { emoji: 'ğŸ˜®', name: 'wow' },
            { emoji: 'ğŸ«¡', name: 'salute' }
        ],
        // NEW: Sportsmanship â€” when game ends (win or lose)
        sportsmanship: [
            { emoji: 'ğŸ¤', name: 'handshake' },
            { emoji: 'ğŸ‘', name: 'clap' },
            { emoji: 'ğŸ‰', name: 'celebrate' },
            { emoji: 'ğŸ’™', name: 'love' },
            { emoji: 'ğŸ«¶', name: 'heart_hands' }
        ],
        // NEW: Game start â€” friendly welcome
        welcome: [
            { emoji: 'ğŸ‘‹', name: 'wave' },
            { emoji: 'ğŸ¤—', name: 'hug' },
            { emoji: 'ğŸ˜Š', name: 'smile' },
            { emoji: 'ğŸ®', name: 'gamepad' },
            { emoji: 'ğŸ²', name: 'dice' }
        ],
        // NEW: Warpath-specific â€” intense but still fun/playful
        warpathCut: [
            { emoji: 'ğŸ˜ˆ', name: 'revenge' },
            { emoji: 'ğŸ‘¹', name: 'ogre' },
            { emoji: 'ğŸ”¥', name: 'fire' },
            { emoji: 'âš”ï¸', name: 'swords' },
            { emoji: 'ğŸ’€', name: 'dead' },
            { emoji: 'ğŸ˜', name: 'smirk' }
        ]
    };

    // AI Chat Messages â€” bots express personality with words too!
    // Short, fun, friendly messages bots send as floating text bubbles.
    const AI_CHAT_MESSAGES = {
        // When bot cuts the human
        cut: [
            "Sorry, not sorry! ğŸ˜œ",
            "Oops! My bad! ğŸ¤­",
            "Nothing personal! ğŸ’•",
            "It's part of the game! ğŸ˜˜",
            "Had to do it! ğŸ˜…",
            "I still love you tho! ğŸ’™",
            "Gotcha! Good sport? ğŸ¤—",
            "Tag, you're it! ğŸ˜"
        ],
        // When human makes a great move
        encouragement: [
            "Nice move! ğŸ‘",
            "Wow, impressive! ğŸ”¥",
            "You're on fire! âš¡",
            "Watch out for this one! ğŸ‘€",
            "Great play! ğŸ’ª",
            "Ooh, smart move! ğŸ§ ",
            "That was slick! ğŸ˜"
        ],
        // When human cuts a bot
        gotCut: [
            "Nooo! Well played! ğŸ˜…",
            "I'll be back! ğŸ’ª",
            "You got me! Good one! ğŸ‘",
            "Ouch! But respect! ğŸ«¡",
            "Fair play, fair play! ğŸ¤",
            "Revenge will be sweet! ğŸ˜¤",
            "Okay okay, nice one! ğŸ˜‚"
        ],
        // Game start greetings
        welcome: [
            "Let's have fun! ğŸ®",
            "May the best player win! ğŸ†",
            "Good luck everyone! ğŸ€",
            "Let's gooo! ğŸš€",
            "Ready to play! ğŸ²",
            "This is gonna be great! ğŸ˜Š"
        ],
        // When human wins (sportsmanship)
        humanWins: [
            "GG! You earned it! ğŸ†",
            "Well played! Great game! ğŸ‘",
            "You're too good! ğŸ™Œ",
            "Champion! Rematch? ğŸ˜„",
            "Amazing game! You win! ğŸ‰",
            "Respect! Great playing! ğŸ«¡"
        ],
        // When bot wins (humble)
        botWins: [
            "GG! That was close! ğŸ¤",
            "Fun game! Rematch? ğŸ˜Š",
            "Great game everyone! ğŸ‰",
            "That was exciting! ğŸ”¥",
            "Good game! You almost had me! ğŸ’ª"
        ],
        // Warpath-specific cut messages â€” intense but fun
        warpathCut: [
            "COMING FOR YOU! ğŸ˜ˆğŸ”¥",
            "No mercy! Just kidding... kinda! ğŸ‘¹",
            "You knew this was coming! âš”ï¸",
            "Warpath activated! ğŸ’¥",
            "Run! Just kidding, love you! ğŸ˜˜ğŸ’€"
        ],
        // Warpath got cut â€” dramatic but fun
        warpathGotCut: [
            "You dare?! ...respect tho ğŸ’ª",
            "I'LL REMEMBER THIS! ğŸ˜¤ğŸ”¥",
            "The hunter becomes the hunted! ğŸ˜±",
            "Okay that was actually good ğŸ‘",
            "This isn't over! ğŸ˜ˆ"
        ],
        // When bot enters safe zone or scores
        selfCelebrate: [
            "Safe! Finally! ğŸ˜…",
            "Made it! ğŸ‰",
            "One step closer! ğŸ’ª",
            "Catch me if you can! ğŸ˜œ"
        ]
    };
    
    // Game Configuration for Human Players
    const GAME_CONFIG = {
        difficulty: 'easy',       // 'easy', 'normal', 'hard', 'expert', 'warpath'
        autoMoveForHumans: true,  // Auto-execute when only one legal move (no choice needed)
        autoMoveDelay: 500,       // ms delay before auto-executing single move
        showHighlights: true,     // Show legal move highlights
        showMoveAids: true,       // Show move helper popups
        hintMode: 'blink',        // 'blink' = blinking holes, 'dropdown' = suggestion list, 'voice' = audio hints, 'all' = all modes, 'none' = no hints
        // Whether to auto-show the Mom introduction modal at game start.
        // Default: false â€” helpers are off by default; players can open Ask Mom with the Help button.
        showMomIntro: false,
        ftAutoTraverse: false,    // FastTrack auto-traverse: true = auto-move FT pegs around ring, false = manual choice each turn
        suggestionsDisabled: false // When true, move suggestion popups are suppressed â€” player uses blinking holes only
    };
    
    // Difficulty presets - AI strategy scaling
    // Maps to setup page values: easy, normal, hard, expert, warpath
    const DIFFICULTY_PRESETS = {
        easy: {
            autoMoveForHumans: true,
            showHighlights: true,
            showMoveAids: true,
            // AI Strategy Multipliers (higher = more aggressive/smart)
            aiCutPriority: 0.0,           // NEVER targets opponents â€” only cuts when it's the ONLY legal move
            aiBullseyeCutPriority: 0.0,   // Never steals bullseye intentionally
            aiDefensiveAwareness: 0.3,    // Doesn't avoid vulnerable spots well
            aiOffensiveAwareness: 0.0,    // Doesn't set up attacks
            ai4CardStrategy: 0.3,         // Basic backward positioning
            aiFastTrackPriority: 0.7,     // Uses FastTrack but not aggressively
            aiFTLeaveToCut: false,        // NEVER leaves FT to cut
            aiRandomFactor: 0.3,          // Some randomness - makes mistakes
            aiDescription: 'Lenient AI - learning mode'
        },
        normal: {
            autoMoveForHumans: false,
            showHighlights: true,
            showMoveAids: true,
            // Fair but firm â€” cuts when strategic
            aiCutPriority: 1.0,           // Normal cutting - strategic only
            aiBullseyeCutPriority: 1.0,   // Takes bullseye opportunities
            aiDefensiveAwareness: 1.0,    // Avoids vulnerable positions
            aiOffensiveAwareness: 1.0,    // Sets up attack positions
            ai4CardStrategy: 1.0,         // Good backward positioning
            aiFastTrackPriority: 1.0,     // Strategic FastTrack use
            aiFTLeaveToCut: true,         // Will leave FT to cut IF strategically beneficial
            aiRandomFactor: 0.1,          // Slight randomness
            aiDescription: 'Fair but firm AI - cuts when strategic'
        },
        hard: {
            autoMoveForHumans: false,
            showHighlights: true,
            showMoveAids: true,
            // Aggressive â€” targets opponents when opportunity presents
            aiCutPriority: 2.0,           // Aggressively hunts cuts
            aiBullseyeCutPriority: 2.0,   // Prioritizes bullseye theft
            aiDefensiveAwareness: 1.5,    // Avoids vulnerable positions well
            aiOffensiveAwareness: 1.5,    // Sets up attack positions actively
            ai4CardStrategy: 1.5,         // Expert backward positioning
            aiFastTrackPriority: 1.2,     // Optimal FastTrack decisions
            aiFTLeaveToCut: true,         // Will leave FT to cut opponents
            aiRandomFactor: 0.05,         // Minimal randomness
            aiDescription: 'Aggressive AI - targets opponents when possible'
        },
        expert: {
            autoMoveForHumans: false,
            showHighlights: false,
            showMoveAids: false,
            // Ruthless â€” optimal play + aggressive targeting
            aiCutPriority: 3.0,           // Actively hunts all cut opportunities
            aiBullseyeCutPriority: 3.0,   // Prioritizes bullseye theft strongly
            aiDefensiveAwareness: 2.0,    // Never lands in vulnerable spots
            aiOffensiveAwareness: 2.0,    // Always sets up attacks
            ai4CardStrategy: 2.0,         // Expert backward positioning
            aiFastTrackPriority: 1.5,     // Optimal FastTrack decisions
            aiFTLeaveToCut: true,         // Will leave FT to cut opponents
            aiRandomFactor: 0.0,          // No mistakes - pure optimization
            aiDescription: 'Expert AI - ruthless and optimal'
        },
        warpath: {
            autoMoveForHumans: false,
            showHighlights: false,
            showMoveAids: false,
            // WARPATH â€” cutting opponents is the #1 goal, even at own expense
            aiCutPriority: 5.0,           // OBSESSED with cutting â€” main goal
            aiBullseyeCutPriority: 5.0,   // Bullseye theft is top priority
            aiDefensiveAwareness: 0.5,    // Ignores own safety â€” offense only
            aiOffensiveAwareness: 3.0,    // Always positioning to attack
            ai4CardStrategy: 2.0,         // Uses 4-card aggressively
            aiFastTrackPriority: 0.5,     // Will EXIT FT to chase opponents
            aiFTLeaveToCut: true,         // Always leaves FT if cut is available
            aiRandomFactor: 0.0,          // No mistakes - pure aggression
            aiDescription: 'WARPATH AI - hunting you down at all costs'
        }
    };
    
    // Backward compatibility: map old names
    DIFFICULTY_PRESETS.intermediate = DIFFICULTY_PRESETS.normal;
    
    // Apply difficulty settings
    function applyDifficultySettings(difficulty) {
        const preset = DIFFICULTY_PRESETS[difficulty] || DIFFICULTY_PRESETS.easy;
        GAME_CONFIG.difficulty = difficulty;
        GAME_CONFIG.autoMoveForHumans = preset.autoMoveForHumans;
        GAME_CONFIG.showHighlights = preset.showHighlights;
        GAME_CONFIG.showMoveAids = preset.showMoveAids;
        console.log(`ğŸ® Applied difficulty: ${difficulty}`, GAME_CONFIG);
    }
    
    // Select difficulty (called from start screen)
    window.selectDifficulty = function(difficulty) {
        // Update UI
        document.querySelectorAll('.difficulty-option').forEach(el => {
            el.classList.remove('selected');
        });
        const selected = document.querySelector(`.difficulty-option[data-difficulty="${difficulty}"]`);
        if (selected) {
            selected.classList.add('selected');
        }
        // Apply settings
        applyDifficultySettings(difficulty);
    };
    
    // Get current difficulty preset
    function getDifficultyPreset() {
        return DIFFICULTY_PRESETS[GAME_CONFIG.difficulty] || DIFFICULTY_PRESETS.easy;
    }
    
    // ============================================================
    // PRIVATE GAME & LOBBY SYSTEM
    // WebSocket connection to lobby server for private games
    // ============================================================
    
    let lobbyWebSocket = null;
    let currentGameMode = 'solo';
    let privateSessionData = null;
    let isLobbyHost = false;
    let myUsername = 'Player';
    let myUserId = null;
    
    // Player avatars for slots
    const slotAvatars = ['ğŸ¦Š', 'ğŸ¢', 'ğŸ¦„', 'ğŸ»'];
    
    // Lightweight toast message (standalone, no CardUI dependency)
    function showMsg(msg, duration) {
        console.log('[Message]', msg);
        const toast = document.createElement('div');
        
        // Special styling for "No legal moves" message - make it more prominent
        const isNoLegalMoves = msg.toLowerCase().includes('no legal moves');
        const bgColor = isNoLegalMoves ? 'rgba(220, 38, 38, 0.95)' : 'rgba(0,0,0,0.88)';
        const borderColor = isNoLegalMoves ? 'rgba(255, 100, 100, 0.8)' : 'rgba(255,255,255,0.2)';
        const fontSize = isNoLegalMoves ? '22px' : '16px';
        const padding = isNoLegalMoves ? '20px 40px' : '12px 28px';
        const boxShadow = isNoLegalMoves ? '0 0 30px rgba(220, 38, 38, 0.6), 0 4px 20px rgba(0,0,0,0.5)' : 'none';
        
        toast.style.cssText = `
            position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
            background:${bgColor}; color:#fff; padding:${padding};
            border-radius:12px; font-size:${fontSize}; font-weight:700;
            z-index:20000; pointer-events:none; text-align:center;
            border:2px solid ${borderColor};
            box-shadow:${boxShadow};
            animation: toastFade ${duration || 2500}ms ease-in-out forwards;
            font-family: 'Press Start 2P', monospace;
            letter-spacing: 1px;
        `;
        
        // Add icon for no legal moves
        if (isNoLegalMoves) {
            toast.innerHTML = `<div style="font-size:32px; margin-bottom:10px;">ğŸš«</div>${msg}`;
        } else {
            toast.textContent = msg;
        }
        
        // Inject animation if not present
        if (!document.getElementById('toast-anim-css')) {
            const s = document.createElement('style');
            s.id = 'toast-anim-css';
            s.textContent = '@keyframes toastFade{0%{opacity:0;transform:translate(-50%,-50%) scale(0.8)}10%{opacity:1;transform:translate(-50%,-50%) scale(1.05)}15%{transform:translate(-50%,-50%) scale(1)}85%{opacity:1}100%{opacity:0;transform:translate(-50%,-50%) scale(0.9)}}';
            document.head.appendChild(s);
        }
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), duration || 2500);
    }
    
    // Connect to lobby server
    function connectToLobby() {
        if (lobbyWebSocket && lobbyWebSocket.readyState === WebSocket.OPEN) {
            return Promise.resolve();
        }
        
        return new Promise((resolve, reject) => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname;
            const port = host === 'localhost' || host === '127.0.0.1' ? ':8765' : '';
            const wsUrl = `${protocol}//${host}${port}/ws`;
            
            console.log('[Lobby] Connecting to:', wsUrl);
            lobbyWebSocket = new WebSocket(wsUrl);
            
            lobbyWebSocket.onopen = () => {
                console.log('[Lobby] Connected');
                // Auto-login as guest
                myUsername = 'Player' + Math.floor(Math.random() * 9999);
                myUserId = 'guest_' + Date.now();
                lobbyWebSocket.send(JSON.stringify({
                    type: 'guest_login',
                    name: myUsername
                }));
                resolve();
            };
            
            lobbyWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleLobbyMessage(data);
                } catch (e) {
                    console.error('[Lobby] Parse error:', e);
                }
            };
            
            lobbyWebSocket.onclose = () => {
                console.log('[Lobby] Disconnected');
                lobbyWebSocket = null;
            };
            
            lobbyWebSocket.onerror = (err) => {
                console.error('[Lobby] WebSocket error:', err);
                reject(err);
            };
            
            // Timeout
            setTimeout(() => {
                if (lobbyWebSocket && lobbyWebSocket.readyState !== WebSocket.OPEN) {
                    reject(new Error('Connection timeout'));
                }
            }, 5000);
        });
    }
    
    // ğŸŒŠ DIMENSIONAL: Lobby message intent manifold (replaces switch statement)
    const LobbyMessageIntents = {
        connected: (data) => {
            myUserId = data.user?.user_id ?? data.user_id;
            myUsername = data.user?.username ?? data.username;
            console.log('[Lobby] Authenticated as:', myUsername, myUserId);
        },
        welcome: (data) => LobbyMessageIntents.connected(data),
        guest_joined: (data) => LobbyMessageIntents.connected(data),
        auth_success: (data) => LobbyMessageIntents.connected(data),

        session_created: (data) => {
            privateSessionData = data.session;
            isLobbyHost = true;
            showPrivateLobby(data.session, data.share_code, data.share_url);
        },

        session_joined: (data) => {
            privateSessionData = data.session;
            isLobbyHost = data.session.host_id === myUserId;
            showPrivateLobby(data.session, data.session.session_code,
                `https://kensgames.com/fasttrack/join.html?code=${data.session.session_code}`);
        },

        join_request: (data) => {
            isLobbyHost && addPendingRequest(data.player);
            isLobbyHost && addSystemChat(`${data.player.username} is requesting to join...`);
        },

        join_request_cancelled: (data) => {
            removePendingRequest(data.user_id);
            addSystemChat(`${data.username} withdrew their request.`);
        },

        player_joined: (data) => {
            privateSessionData && (privateSessionData.players = data.players ?? privateSessionData.players);
            privateSessionData && updatePlayersWaiting();
            const name = data.player?.username ?? data.username ?? 'Someone';
            privateSessionData && addSystemChat(`${name} joined the game!`);
        },

        player_left: (data) => {
            privateSessionData && (privateSessionData.players = data.players ?? privateSessionData.players);
            privateSessionData && updatePlayersWaiting();
            privateSessionData && addSystemChat(`${data.username} left the game.`);
        },

        player_ready_changed: (data) => {
            privateSessionData && (privateSessionData.players = data.players ?? privateSessionData.players);
            privateSessionData && updatePlayersWaiting();
            privateSessionData && updateMyReadyButton();
            const status = data.ready ? 'âœ… ready' : 'â¬œ not ready';
            privateSessionData && addSystemChat(`${data.username} is now ${status}`);
        },

        player_kicked: (data) => {
            privateSessionData && (privateSessionData.players = data.players ?? privateSessionData.players);
            privateSessionData && updatePlayersWaiting();
            privateSessionData && addSystemChat(`${data.username} was removed by the host.`);
        },

        kicked: (data) => {
            hidePrivateLobby();
            privateSessionData = null;
            isLobbyHost = false;
            const startScreen = document.getElementById('start-game-screen');
            startScreen && (startScreen.style.display = 'flex');
            showMsg(data.reason ?? 'You were removed from the game.', 4000);
        },

        session_settings_updated: (data) => {
            privateSessionData && (privateSessionData.settings = data.settings);
            privateSessionData && (privateSessionData.max_players = data.max_players);
            privateSessionData && data.session && (privateSessionData = data.session);
            privateSessionData && updatePlayersWaiting();
            privateSessionData && updateHostSettingsUI();
            // Apply music setting
            (data.settings.music_enabled === false && typeof MusicSubstrate !== 'undefined') &&
                MusicSubstrate.pause?.();
            privateSessionData && addSystemChat('Host updated game settings.');
        },

        chat: (data) => addChatMessage(data.username, data.message, data.timestamp),

        game_starting: (data) => {
            addSystemChat('Game is starting!');
            ObservationSubstrate.after(() => {
                hidePrivateLobby();
                startMultiplayerGame(data.session ?? privateSessionData);
            }, 1000);
        },
        game_started: (data) => LobbyMessageIntents.game_starting(data),

        late_join_request: (data) => {
            (isLobbyHost || gameSessionSettings.isOrganizer) &&
                addJoinRequest(data.player.user_id, data.player.username, data.player.avatar_id ?? 'ğŸ‘¤');
        },

        late_player_joined: (data) => {
            data.session && (privateSessionData = data.session);
            data.session && (multiplayerSession = data.session);

            (gameState && data.player) && (() => {
                const p = data.player;
                const slot = data.assigned_slot;
                const slotType = data.slot_type;
                const avatarEmojis = { person_smile:'ğŸ˜Š', person_cool:'ğŸ˜', animal_lion:'ğŸ¦', animal_fox:'ğŸ¦Š', space_rocket:'ğŸš€', fantasy_dragon:'ğŸ²', scifi_robot:'ğŸ¤–', sport_soccer:'âš½' };
                const playerColors = ['#ff2020', '#2196ff', '#4caf50', '#ffeb3b', '#ff9800', '#9c27b0'];

                (slotType === 'replace-bot' && gameState.players[slot]) ? (() => {
                    gameState.players[slot].isAI = false;
                    gameState.players[slot].name = p.username;
                    gameState.players[slot].avatar = avatarEmojis[p.avatar_id] ?? 'ğŸ‘¤';
                    gameState.players[slot].userId = p.user_id;
                })() : (() => {
                    const newPlayer = {
                        name: p.username,
                        avatar: avatarEmojis[p.avatar_id] ?? 'ğŸ‘¤',
                        userId: p.user_id,
                        colorHex: playerColors[slot % playerColors.length],
                        isAI: false,
                        pegs: [],
                        pegsInHolding: 4,
                        pegsInSafeZone: 0,
                        pegsInBullseye: 0
                    };
                    (slot < gameState.players.length) ?
                        (gameState.players[slot] = newPlayer) :
                        gameState.players.push(newPlayer);
                    (typeof initializePegsForPlayer === 'function') && initializePegsForPlayer(slot);
                    activePlayerCount = gameState.players.length;
                })();

                window.GameUIMinimal?.setPlayers?.(gameState.players, gameState.currentPlayerIndex);
                showBotAlert(`${p.username} Joined!`, 'A new player has entered the game');
                updateOrganizerPlayerList();
            })();
        },

        game_state_sync: (data) => {
            (data.game_state && typeof applyRemoteGameState === 'function') &&
                applyRemoteGameState(data.game_state);
        },

        error: (data) => {
            showMsg(data.message ?? 'Error occurred', 3000);
            console.error('[Lobby] Error:', data.message);
        }
    };

    // ğŸŒŠ DIMENSIONAL: Invoke intent directly (replaces switch statement)
    function handleLobbyMessage(data) {
        console.log('[Lobby] Received:', data.type, data);
        LobbyMessageIntents[data.type]?.(data);
    }
    
    // Game mode selection
    window.selectGameMode = function(mode) {
        // Solo â†’ redirect to ai_setup.html (dedicated setup wizard)
        if (mode === 'solo') {
            window.location.href = 'ai_setup.html';
            return;
        }
        
        currentGameMode = mode;
        
        // Update UI
        document.querySelectorAll('.game-mode-btn').forEach(el => {
            el.classList.remove('selected');
        });
        const selected = document.querySelector(`.game-mode-btn[data-mode="${mode}"]`);
        if (selected) selected.classList.add('selected');
        
        // Show/hide relevant sections
        const privateSection = document.getElementById('private-game-section');
        const matchmakingStatus = document.getElementById('matchmaking-status');
        
        if (privateSection) privateSection.style.display = mode === 'private' ? 'block' : 'none';
        if (matchmakingStatus) matchmakingStatus.style.display = 'none';
        
        // Update start button
        const startBtn = document.getElementById('start-btn');
        if (startBtn) {
            if (mode === 'quickmatch') {
                startBtn.textContent = 'ğŸ” FIND MATCH';
                startBtn.style.display = 'block';
                startBtn.onclick = () => joinMatchmaking();
            } else if (mode === 'private') {
                startBtn.style.display = 'none';
            }
        }
    };
    
    // Generate a random 6-character game code
    function generateGameCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Avoid confusing chars like 0/O, 1/I/L
        let code = '';
        for (let i = 0; i < 6; i++) {
            code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
    }
    
    // Create private game
    window.createPrivateGame = async function() {
        // Generate code immediately for quickplay/offline mode
        const localCode = generateGameCode();
        
        // Show loading state
        const createBtn = document.querySelector('.private-btn.create');
        if (createBtn) {
            createBtn.disabled = true;
            createBtn.textContent = 'Creating...';
        }
        
        try {
            // Try connecting to server for online multiplayer
            await connectToLobby();
            
            // Read host settings
            const maxPlayersEl = document.getElementById('private-max-players');
            const allowBotsEl = document.getElementById('private-allow-bots');
            const musicEnabledEl = document.getElementById('private-music-enabled');
            const allowLateJoinEl = document.getElementById('private-allow-late-join');
            const maxPlayers = maxPlayersEl ? parseInt(maxPlayersEl.value) : 4;
            const allowBots = allowBotsEl ? allowBotsEl.checked : true;
            const musicEnabled = musicEnabledEl ? musicEnabledEl.checked : true;
            const allowLateJoin = allowLateJoinEl ? allowLateJoinEl.checked : true;
            
            lobbyWebSocket.send(JSON.stringify({
                type: 'create_session',
                private: true,
                max_players: maxPlayers,
                settings: {
                    difficulty: GAME_CONFIG.difficulty,
                    allow_bots: allowBots,
                    music_enabled: musicEnabled,
                    allow_late_join: allowLateJoin
                }
            }));
            
            // Reset button (will be hidden when lobby shows anyway)
            if (createBtn) {
                createBtn.disabled = false;
                createBtn.textContent = 'Create New Game';
            }
            
        } catch (err) {
            console.error('[Private] Server unavailable, using local code:', localCode);
            
            // Reset button
            if (createBtn) {
                createBtn.disabled = false;
                createBtn.textContent = 'Create New Game';
            }
            
            // Show the join URL with locally-generated code
            const joinUrl = `/fasttrack/join.html?code=${localCode}`;
            const fullUrl = window.location.origin + joinUrl;
            
            // Create local session data
            const localSession = {
                session_id: 'local_' + Date.now(),
                session_code: localCode,
                host_id: myUserId || 'local_host',
                players: [{
                    user_id: myUserId || 'local_host',
                    username: myUsername || 'Host',
                    is_host: true
                }],
                max_players: 4,
                isLocal: true
            };
            
            privateSessionData = localSession;
            isLobbyHost = true;
            
            // Show the private lobby with the code
            showPrivateLobby(localSession, localCode, fullUrl);
            
            showMsg('Game created! Share code: ' + localCode, 4000);
        }
    };
    
    // Join private game by code
    window.joinPrivateGame = async function() {
        const codeInput = document.getElementById('join-code-input');
        const code = (codeInput?.value || '').toUpperCase().trim();
        
        if (!code || code.length < 4) {
            cardUI?.showMessage('Please enter a valid code', 2000);
            return;
        }
        
        try {
            await connectToLobby();
            
            lobbyWebSocket.send(JSON.stringify({
                type: 'join_by_code',
                code: code
            }));
            
        } catch (err) {
            console.error('[Private] Failed to join:', err);
            cardUI?.showMessage('Failed to connect to server', 3000);
        }
    };
    
    // Show private lobby interface
    function showPrivateLobby(session, code, url) {
        const lobby = document.getElementById('private-lobby');
        const startScreen = document.getElementById('start-game-screen');
        
        if (startScreen) startScreen.style.display = 'none';
        if (lobby) lobby.classList.add('visible');
        
        // Update code display
        const codeDisplay = document.getElementById('private-share-code');
        if (codeDisplay) codeDisplay.textContent = code || '------';
        
        // Update URL â€” ensure absolute
        let fullUrl = url || `/fasttrack/join.html?code=${code}`;
        if (fullUrl.startsWith('/')) fullUrl = window.location.origin + fullUrl;
        const urlInput = document.getElementById('private-share-url');
        if (urlInput) urlInput.value = fullUrl;
        
        // Show/hide host-only UI
        const hostSettings = document.getElementById('lobby-host-settings');
        const pendingSection = document.getElementById('pending-requests-section');
        if (hostSettings) hostSettings.style.display = isLobbyHost ? 'block' : 'none';
        if (pendingSection) pendingSection.style.display = isLobbyHost ? 'none' : 'none'; // shown when requests arrive
        
        // Update players
        privateSessionData = session;
        updatePlayersWaiting();
        updateMyReadyButton();
        updateHostSettingsUI();
        updateStartButton();
    }
    
    function hidePrivateLobby() {
        const lobby = document.getElementById('private-lobby');
        if (lobby) lobby.classList.remove('visible');
    }
    
    // Update host settings UI to reflect current state
    function updateHostSettingsUI() {
        if (!privateSessionData) return;
        const settings = privateSessionData.settings || {};
        const musicBtn = document.getElementById('toggle-music-all-btn');
        if (musicBtn) {
            const on = settings.music_enabled !== false;
            musicBtn.textContent = on ? 'ğŸµ Music: ON' : 'ğŸ”‡ Music: OFF';
            musicBtn.style.background = on ? '#7c3aed' : '#555';
        }
        const maxCountEl = document.getElementById('max-player-count');
        if (maxCountEl) maxCountEl.textContent = privateSessionData.max_players || 4;
        
        // Hide add AI if bots not allowed
        const addAiBtn = document.getElementById('add-ai-btn');
        if (addAiBtn) {
            addAiBtn.style.display = settings.allow_bots === false ? 'none' : 'inline-block';
        }
    }
    
    // Update players waiting display
    function updatePlayersWaiting() {
        if (!privateSessionData) return;
        
        const players = privateSessionData.players || [];
        const maxPlayers = privateSessionData.max_players || 4;
        const container = document.getElementById('players-waiting');
        if (!container) return;
        
        container.innerHTML = '';
        
        // Render filled slots
        players.forEach((player, idx) => {
            const isMe = player.user_id === myUserId;
            const readyState = player.is_ai ? true : player.ready;
            const readyIcon = readyState ? 'âœ…' : 'â¬œ';
            const readyText = player.is_ai ? 'Bot' : (readyState ? 'Ready' : 'Not Ready');
            const readyColor = readyState ? '#4ade80' : '#f59e0b';
            
            let kickHtml = '';
            if (isLobbyHost && !player.is_host && !player.is_ai) {
                kickHtml = `<button onclick="kickPlayer('${player.user_id}')" style="background:#dc2626;color:#fff;border:none;border-radius:6px;padding:3px 8px;font-size:11px;cursor:pointer;margin-left:auto;">Boot</button>`;
            } else if (isLobbyHost && player.is_ai) {
                kickHtml = `<button onclick="kickPlayer('${player.user_id}')" style="background:#666;color:#fff;border:none;border-radius:6px;padding:3px 8px;font-size:11px;cursor:pointer;margin-left:auto;">Remove</button>`;
            }
            
            const slot = document.createElement('div');
            slot.className = `waiting-player-slot filled ${player.is_host ? 'host' : ''}`;
            slot.innerHTML = `
                <div class="slot-avatar">${player.is_ai ? 'ğŸ¤–' : (slotAvatars[idx] || 'ğŸ‘¤')}</div>
                <div style="flex:1;">
                    <div class="slot-name">${escapeHtml(player.username)}${player.is_host ? ' (Host)' : ''}${isMe ? ' (You)' : ''}</div>
                    <div class="slot-status" style="color:${readyColor};font-size:12px;">${readyIcon} ${readyText}</div>
                </div>
                ${kickHtml}
            `;
            container.appendChild(slot);
        });
        
        // Render empty slots
        for (let i = players.length; i < maxPlayers; i++) {
            const slot = document.createElement('div');
            slot.className = 'waiting-player-slot empty';
            slot.innerHTML = `
                <div class="slot-avatar">â³</div>
                <div style="flex:1;">
                    <div class="slot-name">Waiting...</div>
                    <div class="slot-status" style="font-size:12px;"></div>
                </div>
            `;
            container.appendChild(slot);
        }
        
        // Update player count
        const countEl = document.getElementById('player-count');
        if (countEl) countEl.textContent = players.length;
        const maxCountEl = document.getElementById('max-player-count');
        if (maxCountEl) maxCountEl.textContent = maxPlayers;
        
        updateStartButton();
    }
    
    function updateStartButton() {
        const btn = document.getElementById('start-private-game-btn');
        if (!btn) return;
        
        const players = privateSessionData?.players || [];
        const playerCount = players.length;
        const allReady = players.every(p => p.is_ai || p.ready);
        const canStart = isLobbyHost && playerCount >= 2 && allReady;
        
        btn.disabled = !canStart;
        if (playerCount < 2) {
            btn.textContent = `Start Game (Need ${Math.max(0, 2 - playerCount)} more)`;
        } else if (!allReady) {
            const notReady = players.filter(p => !p.is_ai && !p.ready).map(p => p.username);
            btn.textContent = `Waiting for: ${notReady.join(', ')}`;
        } else if (!isLobbyHost) {
            btn.textContent = 'Waiting for host to start...';
        } else {
            btn.textContent = 'ğŸ® Start Game!';
        }
    }
    
    // Ready toggle
    let myReady = false;
    window.toggleMyReady = function() {
        if (!lobbyWebSocket || !privateSessionData) return;
        lobbyWebSocket.send(JSON.stringify({ type: 'toggle_ready' }));
    };
    
    function updateMyReadyButton() {
        const btn = document.getElementById('my-ready-btn');
        if (!btn || !privateSessionData) return;
        const me = privateSessionData.players?.find(p => p.user_id === myUserId);
        if (!me) return;
        myReady = me.ready;
        if (myReady) {
            btn.textContent = 'âœ… Ready!';
            btn.style.background = 'rgba(74, 222, 128, 0.3)';
            btn.style.borderColor = '#4ade80';
            btn.style.color = '#4ade80';
        } else {
            btn.textContent = 'â¬œ Not Ready';
            btn.style.background = 'rgba(100,100,100,0.3)';
            btn.style.borderColor = '#666';
            btn.style.color = '#aaa';
        }
    }
    
    // Pending request management (host only)
    let pendingPlayers = [];
    
    function addPendingRequest(player) {
        pendingPlayers.push(player);
        renderPendingRequests();
    }
    
    function removePendingRequest(userId) {
        pendingPlayers = pendingPlayers.filter(p => p.user_id !== userId);
        renderPendingRequests();
    }
    
    function renderPendingRequests() {
        const section = document.getElementById('pending-requests-section');
        const list = document.getElementById('pending-requests-list');
        if (!section || !list) return;
        
        if (pendingPlayers.length === 0) {
            section.style.display = 'none';
            return;
        }
        section.style.display = 'block';
        
        list.innerHTML = pendingPlayers.map(p => `
            <div style="display:flex;align-items:center;gap:10px;background:rgba(245,158,11,0.15);border:1px solid rgba(245,158,11,0.4);border-radius:8px;padding:10px 14px;">
                <span style="font-size:24px;">ğŸ‘¤</span>
                <div style="flex:1;">
                    <div style="font-weight:bold;color:#fff;">${escapeHtml(p.username)}</div>
                    <div style="font-size:12px;color:#f59e0b;">Wants to join</div>
                </div>
                <button onclick="approvePlayer('${p.user_id}')" style="background:#22c55e;color:#fff;border:none;border-radius:6px;padding:6px 14px;font-size:13px;font-weight:bold;cursor:pointer;">âœ“ Accept</button>
                <button onclick="rejectPlayer('${p.user_id}')" style="background:#ef4444;color:#fff;border:none;border-radius:6px;padding:6px 14px;font-size:13px;cursor:pointer;">âœ— Deny</button>
            </div>
        `).join('');
    }
    
    window.approvePlayer = function(userId) {
        if (!lobbyWebSocket) return;
        lobbyWebSocket.send(JSON.stringify({ type: 'approve_player', user_id: userId }));
        removePendingRequest(userId);
    };
    
    window.rejectPlayer = function(userId) {
        if (!lobbyWebSocket) return;
        lobbyWebSocket.send(JSON.stringify({ type: 'reject_player', user_id: userId }));
        removePendingRequest(userId);
    };
    
    window.kickPlayer = function(userId) {
        if (!lobbyWebSocket || !isLobbyHost) return;
        lobbyWebSocket.send(JSON.stringify({ type: 'kick_player', user_id: userId }));
    };
    
    // Add AI player (host only)
    window.addAIPlayer = function() {
        if (!lobbyWebSocket || !isLobbyHost) return;
        lobbyWebSocket.send(JSON.stringify({ type: 'add_ai_player', level: 'medium' }));
    };
    
    // Toggle music for all (host only)
    window.toggleMusicForAll = function() {
        if (!lobbyWebSocket || !isLobbyHost || !privateSessionData) return;
        const current = privateSessionData.settings?.music_enabled !== false;
        lobbyWebSocket.send(JSON.stringify({
            type: 'update_session_settings',
            settings: { music_enabled: !current }
        }));
    };
    
    // Copy share URL
    window.copyShareUrl = function() {
        const urlInput = document.getElementById('private-share-url');
        if (!urlInput) return;
        
        navigator.clipboard.writeText(urlInput.value).then(() => {
            const btn = document.getElementById('copy-url-btn');
            if (btn) {
                btn.textContent = 'âœ“ Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'ğŸ“‹ Copy';
                    btn.classList.remove('copied');
                }, 2000);
            }
            cardUI?.showMessage('Link copied!', 1500);
        }).catch(err => {
            console.error('Copy failed:', err);
            // Fallback
            urlInput.select();
            document.execCommand('copy');
            cardUI?.showMessage('Link copied!', 1500);
        });
    };
    
    // Social share functions
    window.shareVia = function(platform) {
        const code = document.getElementById('private-share-code')?.textContent || '';
        const url = document.getElementById('private-share-url')?.value || '';
        const message = `Join my Fast Track game! ğŸ¯\n\nCode: ${code}\n\n${url}`;
        const encodedMsg = encodeURIComponent(message);
        const encodedUrl = encodeURIComponent(url);
        
        let shareUrl = '';
        
        switch (platform) {
            case 'whatsapp':
                shareUrl = `https://wa.me/?text=${encodedMsg}`;
                break;
            case 'telegram':
                shareUrl = `https://t.me/share/url?url=${encodedUrl}&text=${encodeURIComponent(`Join my Fast Track game! Code: ${code}`)}`;
                break;
            case 'messenger':
                shareUrl = `fb-messenger://share/?link=${encodedUrl}`;
                // Fallback for web
                if (!/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                    shareUrl = `https://www.facebook.com/dialog/send?link=${encodedUrl}&app_id=YOUR_APP_ID&redirect_uri=${encodedUrl}`;
                }
                break;
            case 'sms':
                shareUrl = `sms:?body=${encodedMsg}`;
                break;
            case 'email':
                shareUrl = `mailto:?subject=${encodeURIComponent('Join my Fast Track game!')}&body=${encodedMsg}`;
                break;
        }
        
        if (shareUrl) {
            window.open(shareUrl, '_blank');
        }
    };
    
    // Chat functions
    window.sendPrivateChat = function() {
        const input = document.getElementById('private-chat-input');
        const message = (input?.value || '').trim();
        
        if (!message || !lobbyWebSocket) return;
        
        lobbyWebSocket.send(JSON.stringify({
            type: 'chat',
            message: message
        }));
        
        input.value = '';
    };
    
    function addChatMessage(author, message, timestamp) {
        const container = document.getElementById('private-chat-messages');
        if (!container) return;
        
        const time = timestamp ? new Date(timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
        
        const msgEl = document.createElement('div');
        msgEl.className = 'chat-message';
        msgEl.innerHTML = `
            <span class="msg-time">${time}</span>
            <span class="msg-author">${author}:</span>
            <span class="msg-text">${escapeHtml(message)}</span>
        `;
        
        container.appendChild(msgEl);
        container.scrollTop = container.scrollHeight;
    }
    
    function addSystemChat(message) {
        const container = document.getElementById('private-chat-messages');
        if (!container) return;
        
        const msgEl = document.createElement('div');
        msgEl.className = 'chat-message system';
        msgEl.textContent = message;
        
        container.appendChild(msgEl);
        container.scrollTop = container.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Leave private lobby
    window.leavePrivateLobby = function() {
        if (lobbyWebSocket && privateSessionData) {
            lobbyWebSocket.send(JSON.stringify({
                type: 'leave_session'
            }));
        }
        
        hidePrivateLobby();
        privateSessionData = null;
        isLobbyHost = false;
        
        // Show start screen again
        const startScreen = document.getElementById('start-game-screen');
        if (startScreen) startScreen.style.display = 'flex';
        
        // Reset chat
        const chatContainer = document.getElementById('private-chat-messages');
        if (chatContainer) {
            chatContainer.innerHTML = '<div class="chat-message system">Welcome to the private lobby! Chat with your friends here.</div>';
        }
    };
    
    // Start private game (host only)
    window.startPrivateGame = function() {
        if (!isLobbyHost || !lobbyWebSocket || !privateSessionData) return;
        
        lobbyWebSocket.send(JSON.stringify({
            type: 'start_game',
            session_id: privateSessionData.session_id
        }));
    };
    
    // Start multiplayer game with session data
    function startMultiplayerGame(session) {
        console.log('[Multiplayer] Starting game with session:', session);
        
        // Set up players from session
        const players = session.players || [];
        activePlayerCount = Math.max(2, Math.min(4, players.length));
        
        // Start game with multiplayer flag
        isMultiplayerGame = true;
        multiplayerSession = session;
        
        // Initialize session settings for organizer controls
        initSessionSettings({
            isOrganizer: isLobbyHost,
            organizerId: session.host_id,
            isPrivate: session.is_private,
            replaceWithBot: true,
            noBots: !(session.settings?.allow_bots !== false),
            allowLateJoin: session.settings?.allow_late_join !== false
        });
        
        startGameSession();
    }
    
    let isMultiplayerGame = false;
    let multiplayerSession = null;
    
    // =========================================================================
    // GameStateBroadcaster â€” broadcasts game state deltas to all players via WS
    // (Extend existing if loaded from game_state_broadcaster.js)
    // =========================================================================
    const GameStateBroadcaster_MP = {
        _throttleTimer: null,
        _pendingState: null,
        
        /** Send a full game state snapshot to all players (host only) */
        syncFullState() {
            if (!isMultiplayerGame || !isLobbyHost) return;
            if (!lobbyWebSocket || lobbyWebSocket.readyState !== WebSocket.OPEN) return;
            if (!gameState) return;
            
            const snapshot = this._buildSnapshot();
            lobbyWebSocket.send(JSON.stringify({
                type: 'game_state_sync',
                game_state: snapshot
            }));
        },
        
        /** Merge a delta into pending state and broadcast (throttled to ~100ms) */
        updateState(delta) {
            if (!isMultiplayerGame) return;
            if (!isLobbyHost) return; // Only the host broadcasts state
            
            this._pendingState = { ...(this._pendingState || {}), ...delta };
            
            if (!this._throttleTimer) {
                this._throttleTimer = setTimeout(() => {
                    this._flushState();
                    this._throttleTimer = null;
                }, 100);
            }
        },
        
        /** Send a discrete game action (any player can send) */
        sendAction(action) {
            if (!isMultiplayerGame) return;
            if (!lobbyWebSocket || lobbyWebSocket.readyState !== WebSocket.OPEN) return;
            
            lobbyWebSocket.send(JSON.stringify({
                type: 'game_action',
                action: action
            }));
        },
        
        _flushState() {
            if (!this._pendingState) return;
            if (!lobbyWebSocket || lobbyWebSocket.readyState !== WebSocket.OPEN) return;
            
            const snapshot = this._buildSnapshot();
            // Merge any pending delta fields
            Object.assign(snapshot, this._pendingState);
            this._pendingState = null;
            
            lobbyWebSocket.send(JSON.stringify({
                type: 'game_state_sync',
                game_state: snapshot
            }));
        },
        
        _buildSnapshot() {
            if (!gameState) return {};
            return {
                currentPlayerIndex: gameState.currentPlayerIndex,
                players: gameState.players?.map(p => ({
                    name: p.name,
                    avatar: p.avatar,
                    colorHex: p.colorHex,
                    isAI: p.isAI,
                    userId: p.userId,
                    pegsInHolding: p.pegsInHolding,
                    pegsInSafeZone: p.pegsInSafeZone,
                    pegsInBullseye: p.pegsInBullseye
                })),
                timestamp: Date.now()
            };
        }
    };
    // Merge multiplayer broadcaster methods into existing GameStateBroadcaster
    Object.assign(GameStateBroadcaster, GameStateBroadcaster_MP);
    window.GameStateBroadcaster = GameStateBroadcaster;
    
    // Apply remote game state received from host
    function applyRemoteGameState(remoteState) {
        if (!gameState || isLobbyHost) return; // Host doesn't apply remote state
        if (remoteState.currentPlayerIndex !== undefined) {
            gameState.currentPlayerIndex = remoteState.currentPlayerIndex;
        }
        if (remoteState.players && Array.isArray(remoteState.players)) {
            // Merge player metadata (don't overwrite full player objects â€” keep local peg positions)
            remoteState.players.forEach((rp, i) => {
                if (gameState.players[i]) {
                    if (rp.name) gameState.players[i].name = rp.name;
                    if (rp.isAI !== undefined) gameState.players[i].isAI = rp.isAI;
                    if (rp.pegsInHolding !== undefined) gameState.players[i].pegsInHolding = rp.pegsInHolding;
                    if (rp.pegsInSafeZone !== undefined) gameState.players[i].pegsInSafeZone = rp.pegsInSafeZone;
                    if (rp.pegsInBullseye !== undefined) gameState.players[i].pegsInBullseye = rp.pegsInBullseye;
                }
            });
        }
        // Update UI panels
        if (window.GameUIMinimal) {
            window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
        }
        console.log('[Sync] Applied remote game state');
    }
    window.applyRemoteGameState = applyRemoteGameState;
    
    // Quick match / matchmaking
    window.joinMatchmaking = async function() {
        try {
            await connectToLobby();
            
            const matchStatus = document.getElementById('matchmaking-status');
            if (matchStatus) matchStatus.style.display = 'block';
            
            lobbyWebSocket.send(JSON.stringify({
                type: 'join_matchmaking',
                player_count_preference: 4
            }));
            
        } catch (err) {
            console.error('[Match] Failed to join:', err);
            cardUI?.showMessage('Failed to connect to server', 3000);
        }
    };
    
    window.cancelMatchmaking = function() {
        if (lobbyWebSocket) {
            lobbyWebSocket.send(JSON.stringify({
                type: 'leave_matchmaking'
            }));
        }
        
        const matchStatus = document.getElementById('matchmaking-status');
        if (matchStatus) matchStatus.style.display = 'none';
    };
    
    // Tutorial functions
    window.showTutorial = function() {
        const modal = document.getElementById('tutorial-modal');
        if (modal) modal.classList.add('visible');
    };
    
    window.hideTutorial = function() {
        const modal = document.getElementById('tutorial-modal');
        if (modal) modal.classList.remove('visible');
    };
    
    window.scrollToRules = function() {
        const rules = document.getElementById('start-rules');
        if (rules) rules.scrollIntoView({ behavior: 'smooth' });
    };
    
    // ============================================================
    // MOM HELPER SYSTEM
    // Mom is your game guide - helps explain moves and options
    // ============================================================
    
    let momIntroShown = false;
    
    // Show Mom's introduction at game start
    function showMomIntro() {
        // Don't show in Hard mode - no aids!
        if (GAME_CONFIG.difficulty === 'hard') {
            momIntroShown = true;
            return;
        }
        
        const modal = document.getElementById('mom-intro-modal');
        if (modal && !momIntroShown) {
            modal.classList.add('visible');
            momIntroShown = true;
        }
    }
    
    function closeMomIntro() {
        const modal = document.getElementById('mom-intro-modal');
        if (modal) {
            modal.classList.remove('visible');
        }
    }
    window.closeMomIntro = closeMomIntro;
    
    // Open camera panel (delegates to GameUIMinimal)
    function openCameraPanel() {
        if (window.GameUIMinimal) {
            window.GameUIMinimal.toggleMenu();
            window.GameUIMinimal.drillDown('camera');
        }
    }
    window.openCameraPanel = openCameraPanel;

    // Open theme panel (delegates to GameUIMinimal)
    function openThemePanel() {
        if (window.GameUIMinimal) {
            window.GameUIMinimal.toggleMenu();
            window.GameUIMinimal.drillDown('theme');
        }
    }
    window.openThemePanel = openThemePanel;

    // Toggle Mom Daemon (persistent game helper)
    function toggleMomDaemon() {
        if (window.MomDaemon) {
            window.MomDaemon.toggle();
        }
    }
    window.toggleMomDaemon = toggleMomDaemon;
    
    // Show Mom's contextual help based on current game state (legacy - now uses daemon)
    function showMomHelp() {
        // Delegate to AskMomAdvisor if available (enhanced advisor with auto-execute)
        if (window.AskMomAdvisor && typeof window.AskMomAdvisor.showAdvice === 'function') {
            window.AskMomAdvisor.showAdvice();
            return;
        }

        // Fallback to legacy Mom Help
        const panel = document.getElementById('mom-help-panel');
        const messageEl = document.getElementById('mom-message-text');
        const optionsEl = document.getElementById('mom-options');
        
        if (!panel || !messageEl || !optionsEl) return;
        
        // Clear previous options
        optionsEl.innerHTML = '';
        
        // Get context-aware help
        const help = getMomContextHelp();
        
        messageEl.textContent = help.message;
        
        // Add option buttons
        help.options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'mom-option';
            btn.textContent = opt.text;
            btn.onclick = () => {
                if (opt.action) opt.action();
                if (opt.closePanel !== false) hideMomHelp();
            };
            optionsEl.appendChild(btn);
        });
        
        panel.classList.add('visible');
    }
    window.showMomHelp = showMomHelp;
    
    function hideMomHelp() {
        const panel = document.getElementById('mom-help-panel');
        if (panel) {
            panel.classList.remove('visible');
        }
        // Run cleanup synchronously when hide is invoked directly
        try { _postHideMomCleanup(); } catch (e) { /* ignore if not ready */ }
    }
    window.hideMomHelp = hideMomHelp;
    
    // Ensure hiding Mom help unblocks UI and clears any temporary selection state
    function _postHideMomCleanup() {
        try {
            // Clear any visual highlights left by advice
            if (typeof clearHighlights === 'function') clearHighlights();

            // Ensure card/deck UI is enabled for the human player
            if (window.cardUI && typeof window.cardUI.setDeckEnabled === 'function') {
                window.cardUI.setDeckEnabled(true);
            }

            // Hide move selection modal if present
            if (window.moveSelectionModal && typeof window.moveSelectionModal.hide === 'function') {
                window.moveSelectionModal.hide();
            }

            // Clear any pending banner-selection move so game logic isn't left waiting
            if (typeof pendingMoveSelection !== 'undefined' && pendingMoveSelection !== null) {
                pendingMoveSelection = null;
            }
        } catch (e) {
            console.warn('[Mom] cleanup after hide failed', e);
        }
    }

    // Attach global listener to ensure cleanup when panel is closed via outside clicks
    document.addEventListener('click', (e) => {
        const panel = document.getElementById('mom-help-panel');
        if (panel && !panel.classList.contains('visible')) return; // only when visible
        if (panel && panel.classList.contains('visible') && !panel.contains(e.target)) {
            // Let existing handler hide the panel, then run cleanup shortly after
            setTimeout(_postHideMomCleanup, 50);
        }
    });
    
    // Get contextual help based on current game state
    function getMomContextHelp() {
        if (!gameState) {
            return {
                message: "The game hasn't started yet. Click START GAME when you're ready!",
                options: [{ text: "Got it!", action: null }]
            };
        }
        
        const phase = gameState.phase;
        const player = gameState.currentPlayer;
        const isMyTurn = !isAIPlayer(gameState.currentPlayerIndex);
        const card = gameState.currentCard;
        
        // Not your turn
        if (!isMyTurn) {
            return {
                message: "It's not your turn right now. Watch what the AI does - you might learn some good strategies!",
                options: [{ text: "Okay, I'll watch", action: null }]
            };
        }
        
        // Draw phase
        if (phase === 'draw') {
            return {
                message: "It's your turn! Click on the deck to draw a card. The card will tell you how many spaces you can move.",
                options: [
                    { text: "Where's the deck?", action: () => highlightDeck() },
                    { text: "Thanks, Mom!", action: null }
                ]
            };
        }
        
        // Play phase - have legal moves
        if (phase === 'play' && legalMoves && legalMoves.length > 0) {
            const cardInfo = card ? getCardExplanation(card) : '';
            const moveCount = legalMoves.length;
            
            // Check for special situations
            const hasCutMoves = legalMoves.some(m => findCutTargetAtHole(m.toHoleId));
            const hasSafeZoneMoves = legalMoves.some(m => m.toHoleId.includes('safe-'));
            const hasFastTrackMoves = legalMoves.some(m => m.isFastTrackEntry);
            const hasEnterMoves = legalMoves.some(m => m.type === 'enter');
            
            // Get unique peg numbers that can move
            const uniquePegIds = [...new Set(legalMoves.map(m => m.pegId).filter(Boolean))];
            const pegNumbers = uniquePegIds.map(id => `#${getPegNumber(id)}`);
            const multipleTokens = uniquePegIds.length > 1;
            
            let advice = `You drew a ${card?.value || 'card'}. ${cardInfo} `;
            
            // Show which pegs can move when multiple have options
            if (multipleTokens) {
                advice += `Pegs ${pegNumbers.join(', ')} can move. `;
            }
            
            if (hasEnterMoves) {
                advice += "You can bring a new peg onto the board! ";
            }
            if (hasSafeZoneMoves) {
                advice += "You can move into your safe zone - that's great progress! ";
            }
            if (hasFastTrackMoves) {
                advice += "You can enter the FastTrack for a shortcut! ";
            }
            if (hasCutMoves) {
                advice += "You can cut an opponent and send them home! ";
            }
            
            advice += `You have ${moveCount} possible move${moveCount > 1 ? 's' : ''}.`;
            
            const options = [];
            if (GAME_CONFIG.showHighlights) {
                options.push({ text: "Show me the green/red highlights", action: null });
            }
            options.push({ text: "What does this card do?", action: () => showCardHelp(card), closePanel: false });
            options.push({ text: "Thanks, Mom!", action: null });
            
            return { message: advice, options };
        }
        
        // Play phase - no legal moves
        if (phase === 'play' && (!legalMoves || legalMoves.length === 0)) {
            return {
                message: "Oh no! You don't have any legal moves with this card. Your turn will be skipped. It happens sometimes - don't worry!",
                options: [{ text: "That's okay, next time!", action: null }]
            };
        }
        
        // Default
        return {
            message: "I'm here if you need help! Just ask anytime.",
            options: [{ text: "Thanks, Mom!", action: null }]
        };
    }
    
    // Get explanation for a card
    function getCardExplanation(card) {
        if (!card) return '';
        const v = card.value;
        
        if (v === 'A' || v === '1') return "Ace lets you enter a peg from holding OR move 1 space. You get another turn!";
        if (v === '6') return "Six lets you enter a peg from holding OR move 6 spaces. You get another turn!";
        if (v === 'JOKER') return "Joker lets you enter from holding OR move 1 space. You get another turn!";
        if (v === 'J' || v === 'Q' || v === 'K') return "Royal card â€” move 1 space, get another turn, AND can exit the bullseye to your FastTrack corner!";
        if (v === '4') return "Four moves BACKWARDS 4 spaces. You cannot back into FastTrack, bullseye, or safe zone â€” but reaching your safe zone entry backwards DOES complete your circuit!";
        if (v === '7') return "Seven is a WILD CARD - move any single token 1-7 spaces. Can enter safe zone, fast track, and center hole.";
        
        return `Move ${v} spaces clockwise.`;
    }
    
    // Show detailed card help
    function showCardHelp(card) {
        const messageEl = document.getElementById('mom-message-text');
        if (messageEl && card) {
            messageEl.textContent = getCardExplanation(card);
        }
    }
    
    // Highlight the deck for new players
    function highlightDeck() {
        // Flash the deck area if CardUI exists
        if (window.cardUI && typeof window.cardUI.flashDeck === 'function') {
            window.cardUI.flashDeck();
        }
    }
    
    // 7 Card Split Move State - Interactive Mode
    let splitMoveState = {
        active: false,
        phase: 'idle',        // 'idle', 'select_first_peg', 'select_first_dest', 'select_second_peg', 'select_second_dest'
        totalMoves: 7,
        usedMoves: 0,
        remainingMoves: 7,
        firstMovePeg: null,
        selectedPeg: null,    // Currently selected peg waiting for destination click
        selectablePegs: [],   // Pegs that can be clicked in current phase
        aiPlannedSecondMove: null  // AI stores its planned second move here
    };
    
    function resetSplitMoveState() {
        // Clear any peg highlights
        clearSplitPegHighlights();
        
        splitMoveState = {
            active: false,
            phase: 'idle',
            totalMoves: 7,
            usedMoves: 0,
            remainingMoves: 7,
            firstMovePeg: null,
            selectedPeg: null,
            selectablePegs: [],
            aiPlannedSecondMove: null
        };
        
        // Remove split indicator
        const indicator = document.querySelector('.split-move-indicator');
        if (indicator) indicator.remove();
    }
    
    function clearSplitPegHighlights() {
        // Remove visual highlights from pegs
        for (const [pegId, pegData] of pegRegistry) {
            if (pegData.isSplitSelectable) {
                pegData.isSplitSelectable = false;
                // Restore original material if saved
                if (pegData.originalBodyMaterial && pegData.bodyMesh) {
                    pegData.bodyMesh.material = pegData.originalBodyMaterial;
                }
            }
        }
    }
    
    function highlightSelectablePegsForSplit(pegIds) {
        console.log('[Split] highlightSelectablePegsForSplit called with', pegIds.length, 'peg IDs:', pegIds);
        splitMoveState.selectablePegs = pegIds;
        
        let highlightedCount = 0;
        for (const pegId of pegIds) {
            const pegData = pegRegistry.get(pegId);
            console.log(`[Split] Checking pegRegistry for ${pegId}:`, pegData ? 'found' : 'NOT FOUND', 
                        pegData ? `bodyMesh=${!!pegData.bodyMesh}` : '');
            
            if (pegData && pegData.bodyMesh) {
                pegData.isSplitSelectable = true;
                // Save original material and apply glowing highlight
                if (!pegData.originalBodyMaterial) {
                    pegData.originalBodyMaterial = pegData.bodyMesh.material;
                }
                // Create pulsing highlight material
                const highlightMat = pegData.bodyMesh.material.clone();
                highlightMat.emissive = new THREE.Color(0x00ff00);
                highlightMat.emissiveIntensity = 0.5;
                pegData.bodyMesh.material = highlightMat;
                highlightedCount++;
                console.log(`[Split] Peg ${pegId} highlighted GREEN (isSplitSelectable=true)`);
            } else {
                console.error(`[Split] FAILED to highlight peg ${pegId}: pegData=${!!pegData}, bodyMesh=${pegData?.bodyMesh ? 'yes' : 'no'}`);
            }
        }
        console.log(`[Split] Highlighted ${highlightedCount}/${pegIds.length} pegs`);
    }
    
    function showSplitMoveIndicator(message, remaining) {
        // Remove existing
        const existing = document.querySelector('.split-move-indicator');
        if (existing) existing.remove();
        
        const indicator = document.createElement('div');
        indicator.className = 'split-move-indicator';
        // Compact, non-blocking format at top of screen
        indicator.innerHTML = `
            <span>âœ‚ï¸ 7 Split: ${message}</span>
            <span style="color: #ffd700; margin-left: 10px;">${remaining} left</span>
        `;
        document.body.appendChild(indicator);
    }
    
    function hideSplitMoveIndicator() {
        const existing = document.querySelector('.split-move-indicator');
        if (existing) existing.remove();
    }
    
    // Start split move mode when 7 is drawn
    function startSplitMoveMode() {
        const player = gameState.currentPlayer;
        
        console.log('[Split] startSplitMoveMode called for player:', player?.name || player?.index);
        console.log('[Split] Player has', player?.peg?.length || 0, 'pegs in state');
        
        if (!player || !player.peg) {
            console.error('[Split] ERROR: No player or player.peg is undefined!');
            cardUI.showMessage('Error: No player data', 2000);
            setTimeout(() => gameState.skipTurn(), 2000);
            return;
        }
        
        // Find all active pegs (not in holding, not completed, not in bullseye)
        const activePegs = [];
        for (const peg of player.peg) {
            console.log(`[Split] Checking peg ${peg.id}: holeType=${peg.holeType}, holeId=${peg.holeId}, completed=${peg.completedCircuit}, inBullseye=${peg.inBullseye}`);
            
            // Skip holding pegs
            if (peg.holeType === 'holding') {
                console.log(`[Split]   -> Skipped (in holding)`);
                continue;
            }
            
            // Skip completed pegs
            if (peg.completedCircuit) {
                console.log(`[Split]   -> Skipped (completed circuit)`);
                continue;
            }
            
            // Skip bullseye pegs (they can't participate in split moves)
            if (peg.inBullseye || peg.holeType === 'bullseye' || peg.holeId === 'center') {
                console.log(`[Split]   -> Skipped (in bullseye)`);
                continue;
            }
            
            // Must have a valid holeId
            if (!peg.holeId) {
                console.log(`[Split]   -> Skipped (no holeId)`);
                continue;
            }
            
            // Peg is valid for split
            console.log(`[Split]   -> ACTIVE for split`);
            activePegs.push(peg.id);
        }
        
        console.log('[Split] Active pegs for split:', activePegs, '(total:', activePegs.length, ')');
        
        if (activePegs.length === 0) {
            cardUI.showMessage('No active pegs to move!', 2000);
            setTimeout(() => gameState.skipTurn(), 2000);
            return;
        }
        
        // If only ONE active peg - just do a full 7 move, no split needed
        if (activePegs.length === 1) {
            console.log('[Split] Only one active peg - using full 7 move');
            cardUI.showMessage('7 Card: One peg moves all 7 spaces', 2000);
            
            // Calculate moves for this single peg with 7 steps
            const peg = player.peg.find(p => p.id === activePegs[0]);
            if (peg) {
                const possibleMoves = calculateMovesForPegRange(peg, 7, 7);
                if (possibleMoves.length > 0) {
                    legalMoves = possibleMoves;
                    highlightLegalMoves(legalMoves);
                    showPegNumbers(activePegs);
                } else {
                    cardUI.showMessage('Peg blocked - no valid moves!', 2000);
                    setTimeout(() => gameState.skipTurn(), 2000);
                }
            }
            return;
        }
        
        // Enter split mode for 2+ pegs
        splitMoveState.active = true;
        splitMoveState.phase = 'select_first_peg';
        splitMoveState.remainingMoves = 7;
        
        // Clear any existing highlights first
        clearHighlights();
        
        // Highlight selectable pegs and show their numbers
        highlightSelectablePegsForSplit(activePegs);
        showPegNumbers(activePegs);
        
        // Re-add click listener (clearHighlights removes it)
        addHoleClickListeners();
        
        // Build peg list for message
        const pegList = activePegs.map(id => `#${getPegNumber(id)}`).join(', ');
        
        // Show instruction with peg numbers
        showSplitMoveIndicator(`Tap peg (${pegList})`, 7);
        cardUI.showMessage(`7 Card: Tap a peg to start split`, 3000);
    }
    
    // Handle peg click in split mode
    function handleSplitPegClick(pegId) {
        const pegData = pegRegistry.get(pegId);
        if (!pegData) return false;
        
        const player = gameState.currentPlayer;
        const peg = player.peg.find(p => p.id === pegId);
        if (!peg) return false;
        
        if (splitMoveState.phase === 'select_first_peg') {
            // First peg selected - show all possible destinations (1-7 moves)
            // If they use all 7, no second peg needed. If they use 1-6, second peg gets remainder.
            splitMoveState.selectedPeg = pegId;
            splitMoveState.phase = 'select_first_dest';
            
            const pegNum = getPegNumber(pegId);
            
            // Clear peg highlights
            clearSplitPegHighlights();
            hidePegNumbers();
            
            // Calculate ALL possible moves from 1-7 for this peg (player can choose any)
            const possibleMoves = calculateMovesForPegRange(peg, 1, 7);
            
            console.log('[Split] Possible moves for first peg:', possibleMoves.length);
            
            if (possibleMoves.length === 0) {
                // This peg has no valid moves, let user pick another
                cardUI.showMessage(`Peg #${pegNum} has no moves, pick another`, 1500);
                splitMoveState.phase = 'select_first_peg';
                splitMoveState.selectedPeg = null;
                highlightSelectablePegsForSplit(splitMoveState.selectablePegs);
                showPegNumbers(splitMoveState.selectablePegs);
                addHoleClickListeners(); // Re-add click listener
                return true;
            }
            
            // Store moves and highlight them
            legalMoves = possibleMoves;
            highlightLegalMoves(legalMoves);
            showSplitMoveIndicator(`Peg #${pegNum}: Choose steps (1-7)`, 7);
            
            return true;
        }
        
        if (splitMoveState.phase === 'select_second_peg') {
            // Can't select the same peg that moved first
            if (pegId === splitMoveState.firstMovePeg) {
                const pegNum = getPegNumber(pegId);
                cardUI.showMessage(`Peg #${pegNum} already moved, pick another!`, 1000);
                return true;
            }
            
            splitMoveState.selectedPeg = pegId;
            splitMoveState.phase = 'select_second_dest';
            
            const pegNum = getPegNumber(pegId);
            
            // Clear peg highlights
            clearSplitPegHighlights();
            hidePegNumbers();
            
            // Calculate moves for exactly remainingMoves distance
            const possibleMoves = calculateMovesForPegRange(peg, splitMoveState.remainingMoves, splitMoveState.remainingMoves);
            
            if (possibleMoves.length === 0) {
                // This peg can't move the required distance, pick another
                cardUI.showMessage(`Peg #${pegNum} can't move ${splitMoveState.remainingMoves}, pick another`, 1500);
                splitMoveState.phase = 'select_second_peg';
                splitMoveState.selectedPeg = null;
                
                // Re-highlight other pegs
                const otherPegs = splitMoveState.selectablePegs.filter(id => id !== splitMoveState.firstMovePeg);
                highlightSelectablePegsForSplit(otherPegs);
                showPegNumbers(otherPegs);
                addHoleClickListeners(); // Re-add click listener
                return true;
            }
            
            // Highlight moves
            legalMoves = possibleMoves;
            highlightLegalMoves(legalMoves);
            showSplitMoveIndicator(`Peg #${pegNum}: Tap destination`, splitMoveState.remainingMoves);
            
            return true;
        }
        
        return false;
    }
    
    // Calculate possible moves for a peg within a step range
    function calculateMovesForPegRange(peg, minSteps, maxSteps) {
        const moves = [];
        const player = gameState.currentPlayer;
        
        console.log(`[Split] Calculating moves for peg ${peg.id} at ${peg.holeId}, steps ${minSteps}-${maxSteps}`);
        
        for (let steps = minSteps; steps <= maxSteps; steps++) {
            // Create a temporary card with this movement value
            const tempCard = { 
                movement: steps, 
                direction: 'clockwise',
                canSplit: false  // Prevent recursion
            };
            
            // Use game engine to calculate destinations
            let destinations = null;
            
            try {
                if (typeof gameState.calculateDestinationsForPeg === 'function') {
                    destinations = gameState.calculateDestinationsForPeg(peg, steps);
                    console.log(`[Split] calculateDestinationsForPeg for ${steps} steps:`, destinations);
                } else if (typeof gameState.calculateDestinations === 'function') {
                    destinations = gameState.calculateDestinations(peg, tempCard, player);
                    console.log(`[Split] calculateDestinations for ${steps} steps:`, destinations);
                } else {
                    console.warn('[Split] No destination calculation method available!');
                    continue;
                }
            } catch (err) {
                console.error('[Split] Error calculating destinations:', err);
                continue;
            }
            
            if (destinations && destinations.length > 0) {
                for (const dest of destinations) {
                    const holeId = typeof dest === 'string' ? dest : dest.holeId;
                    if (!holeId) continue;
                    
                    // Check opponent blocking â€” can we cut if opponent is there?
                    let canMakeMove = true;
                    if (gameState.players) {
                        for (const opponent of gameState.players) {
                            if (opponent.index === player.index) continue;
                            const opponentPeg = (opponent.peg || []).find(p => p.holeId === holeId);
                            if (opponentPeg) {
                                if (typeof gameState.canReceiveCutPeg === 'function' &&
                                    !gameState.canReceiveCutPeg(opponent)) {
                                    canMakeMove = false;
                                    console.log(`[Split] Blocked move to ${holeId} â€” opponent ${opponent.name} cannot receive cut`);
                                }
                                break;
                            }
                        }
                    }
                    
                    if (canMakeMove) {
                        moves.push({
                            type: 'split',
                            pegId: peg.id,
                            fromHoleId: peg.holeId,
                            toHoleId: holeId,
                            steps: steps,
                            path: (dest && typeof dest === 'object' && dest.path) || [peg.holeId, holeId],
                            isFastTrackEntry: (dest && typeof dest === 'object' && dest.isFastTrackEntry) || false
                        });
                    }
                }
            }
        }
        
        console.log(`[Split] Total moves calculated:`, moves.length, moves);
        return moves;
    }

    // Validate whether a 7-card split is possible:
    // At least 2 different pegs must be able to make moves that sum to exactly 7.
    // Returns { valid: boolean, combinations: [{pegA, pegB, stepsA, stepsB, movesA, movesB}] }
    function canSplitSeven() {
        const player = gameState.currentPlayer;
        if (!player || !player.peg) return { valid: false, combinations: [] };
        
        // Find all active pegs (not holding, not completed, not bullseye)
        const activePegs = player.peg.filter(p =>
            p.holeType !== 'holding' &&
            !p.completedCircuit &&
            !p.inBullseye && p.holeType !== 'bullseye' && p.holeId !== 'center' &&
            p.holeId
        );
        
        console.log(`[Split7] Checking split validity: ${activePegs.length} active pegs`);
        
        if (activePegs.length < 2) {
            console.log('[Split7] Not enough active pegs for split');
            return { valid: false, combinations: [] };
        }
        
        // Cache moves per peg per step count
        const pegMoves = {};
        for (const peg of activePegs) {
            pegMoves[peg.id] = {};
            for (let steps = 1; steps <= 6; steps++) {
                const moves = calculateMovesForPegRange(peg, steps, steps);
                pegMoves[peg.id][steps] = moves;
            }
        }
        
        // Find all valid combinations: pegA moves X, pegB moves 7-X (X=1..6)
        const combinations = [];
        for (let i = 0; i < activePegs.length; i++) {
            for (let j = 0; j < activePegs.length; j++) {
                if (i === j) continue;
                const pegA = activePegs[i];
                const pegB = activePegs[j];
                
                for (let stepsA = 1; stepsA <= 6; stepsA++) {
                    const stepsB = 7 - stepsA;
                    if (stepsB < 1 || stepsB > 6) continue;
                    
                    const movesA = pegMoves[pegA.id][stepsA];
                    const movesB = pegMoves[pegB.id][stepsB];
                    
                    if (movesA.length > 0 && movesB.length > 0) {
                        combinations.push({
                            pegA: pegA.id, pegB: pegB.id,
                            stepsA, stepsB,
                            movesA, movesB
                        });
                    }
                }
            }
        }
        
        console.log(`[Split7] Found ${combinations.length} valid split combinations`);
        return { valid: combinations.length > 0, combinations };
    }
    
    // AI: Auto-execute the best split combination for 7-card
    function aiExecuteSplit() {
        const splitCheck = canSplitSeven();
        if (!splitCheck.valid) {
            console.log('ğŸ¤– [AI Split] No valid split â€” skipping turn');
            gameState.skipTurn();
            return;
        }
        
        // Score each combination using simple heuristics
        let bestCombo = null;
        let bestScore = -Infinity;
        
        for (const combo of splitCheck.combinations) {
            // Pick best move for each peg
            const bestA = combo.movesA[0]; // First move is fine â€” they're all same step count
            const bestB = combo.movesB[0];
            
            let score = 0;
            
            // Prefer cuts
            if (bestA.isCut) score += 50;
            if (bestB.isCut) score += 50;
            
            // Prefer FT entry
            if (bestA.isFastTrackEntry) score += 30;
            if (bestB.isFastTrackEntry) score += 30;
            
            // Prefer center
            if (bestA.toHoleId === 'center') score += 25;
            if (bestB.toHoleId === 'center') score += 25;
            
            // Prefer larger first move (more progress)
            score += combo.stepsA + combo.stepsB; // Always 7, but tiebreaker
            
            // Prefer even splits (3+4, 4+3) over extreme (1+6, 6+1)
            score += 6 - Math.abs(combo.stepsA - combo.stepsB);
            
            if (score > bestScore) {
                bestScore = score;
                bestCombo = combo;
            }
        }
        
        if (!bestCombo) {
            console.error('ğŸ¤– [AI Split] No best combo found despite valid combinations');
            gameState.skipTurn();
            return;
        }
        
        const moveA = bestCombo.movesA[0];
        const moveB = bestCombo.movesB[0];
        
        console.log(`ğŸ¤– [AI Split] Best split: ${moveA.pegId}â†’${moveA.toHoleId} (${bestCombo.stepsA}) + ${moveB.pegId}â†’${moveB.toHoleId} (${bestCombo.stepsB})`);
        
        // Set up split state manually for AI
        splitMoveState.active = true;
        splitMoveState.phase = 'select_first_dest';
        splitMoveState.selectedPeg = moveA.pegId;
        splitMoveState.remainingMoves = 7;
        splitMoveState.aiPlannedSecondMove = moveB;
        legalMoves = [moveA];
        
        // Execute first move
        clearHighlights();
        executeMoveDirectly(moveA);
        
        // After first move animates + executes, the transitionToSecondPegSelection 
        // will fire and auto-select for AI (existing code at line ~9774)
    }

    // Track pending first-turn timers to cancel on reinit
    let pendingFirstTurnTimers = [];
    let gameInitCount = 0;

    function initGame(playerCount = 4) {
        // Cancel any pending first-turn timers from previous init calls
        gameInitCount++;
        const thisInitId = gameInitCount;
        console.log(`[initGame] Starting initialization #${thisInitId} with ${playerCount} players`);
        
        pendingFirstTurnTimers.forEach(timerId => clearTimeout(timerId));
        pendingFirstTurnTimers = [];
        
        // Update active player count and recreate pegs for only active players
        activePlayerCount = playerCount;
        createPegsAndPlace(playerCount);
        
        // Create game state and expose globally for multiplayer
        gameState = new FastrackEngine.GameState(playerCount);
        window.gameState = gameState;
        
        // Determine first player: winner goes first on replay, otherwise random
        let firstPlayerIndex;
        let firstPlayerReason;
        if (isReplayGame && lastWinnerIndex !== null && lastWinnerIndex < playerCount) {
            firstPlayerIndex = lastWinnerIndex;
            firstPlayerReason = 'winner';
        } else {
            firstPlayerIndex = Math.floor(Math.random() * playerCount);
            firstPlayerReason = 'random';
        }
        gameState.currentPlayerIndex = firstPlayerIndex;
        isReplayGame = false; // Reset for next time
        
        // Initialize from board registry
        gameState.initializeFromBoard(pegRegistry);
        
        // Link engine to substrate events (from rules_substrate.js)
        if (FastrackEngine.linkEngineToSubstrate) {
            FastrackEngine.linkEngineToSubstrate(gameState);
        }
        
        // Register substrate event listeners for theme integration
        if (typeof GameEventSubstrate !== 'undefined') {
            GameEventSubstrate.on(GameEventSubstrate.types.FAST_TRACK_USED, (data) => {
                console.log('[Substrate] Fast track used:', data);
                // Analytics: fast track shortcut
                if (window.FTAnalytics) FTAnalytics.fastTrackUsed(data.player?.name || 'Player');
                // Stadium integration
                if (typeof StadiumController !== 'undefined') {
                    StadiumController.fastTrackEntry(data.player?.name || 'Player');
                }
            });
            GameEventSubstrate.on(GameEventSubstrate.types.PEG_CUT, (data) => {
                console.log('[Substrate] Peg cut:', data);
                // Analytics: peg capture
                if (window.FTAnalytics) FTAnalytics.pegCapture(data.cutter?.name || 'Bot', data.victim?.name || 'Peg');
                // Stadium integration - capture event
                if (typeof StadiumController !== 'undefined') {
                    const hunterName = data.cutter?.name || 'Bot';
                    const victimName = data.victim?.name || 'Peg';
                    // Check if epic capture (multiple, or dramatic)
                    const isEpic = Math.random() > 0.7; // 30% epic
                    StadiumController.capture(hunterName, victimName, isEpic);
                }
            });
            GameEventSubstrate.on(GameEventSubstrate.types.GAME_OVER, (data) => {
                console.log('[Substrate] Game over:', data);
                // Stadium integration - victory
                if (typeof StadiumController !== 'undefined') {
                    const winnerName = data.winner?.name || 'Winner';
                    StadiumController.victory(winnerName);
                }
            });
            
            // Additional stadium events
            if (typeof GameEventSubstrate.types.PEG_ENTERED !== 'undefined') {
                GameEventSubstrate.on(GameEventSubstrate.types.PEG_ENTERED, (data) => {
                    console.log('[Substrate] Peg entered:', data);
                });
            }
            
            // Game start event
            if (typeof GameEventSubstrate.types.GAME_START !== 'undefined') {
                GameEventSubstrate.on(GameEventSubstrate.types.GAME_START, (data) => {
                    console.log('[Substrate] Game started:', data);
                    if (typeof StadiumController !== 'undefined') {
                        StadiumController.gameStart();
                    }
                });
            }
            
            // Bullseye entered
            if (typeof GameEventSubstrate.types.BULLSEYE_ENTERED !== 'undefined') {
                GameEventSubstrate.on(GameEventSubstrate.types.BULLSEYE_ENTERED, (data) => {
                    console.log('[Substrate] Bullseye entered:', data);
                    if (typeof StadiumController !== 'undefined') {
                        StadiumController.bullseyeEntry(data.player?.name || 'Player');
                    }
                });
            }
            
            // Safe zone entered
            if (typeof GameEventSubstrate.types.SAFE_ZONE_ENTERED !== 'undefined') {
                GameEventSubstrate.on(GameEventSubstrate.types.SAFE_ZONE_ENTERED, (data) => {
                    console.log('[Substrate] Safe zone entered:', data);
                    if (typeof StadiumController !== 'undefined') {
                        StadiumController.safeZoneEntry(data.player?.name || 'Player');
                    }
                });
            }
            
            // Peg home (finished)
            if (typeof GameEventSubstrate.types.PEG_HOME !== 'undefined') {
                GameEventSubstrate.on(GameEventSubstrate.types.PEG_HOME, (data) => {
                    console.log('[Substrate] Peg home:', data);
                    if (typeof StadiumController !== 'undefined') {
                        StadiumController.pegFinished(data.player?.name || 'Player');
                    }
                    
                    // PRESTIGE: Award points for getting a peg home
                    const playerIndex = data.player?.index ?? gameState?.currentPlayerIndex;
                    if (!isAIPlayer(playerIndex) && window.PrestigeTracker) {
                        PrestigeTracker.award('peg_home');
                    }
                });
            }
        }
        
        // Initialize Stadium Controller with game events
        if (typeof StadiumController !== 'undefined') {
            console.log('ğŸŸï¸ Stadium Controller detected - integrating audio systems');
            
            // Make stadium activation happen on first game interaction
            document.addEventListener('click', function activateStadium() {
                StadiumController.activate();
                document.removeEventListener('click', activateStadium);
            }, { once: true });
        }
        
        // Initialize player panels
        console.log('Initializing player panels...');
        console.log('initPlayerPanels type:', typeof window.initPlayerPanels);
        console.log('PlayerPanelUI type:', typeof window.PlayerPanelUI);
        
        // Clear and prepare container BEFORE creating panels
        const panelsContainer = document.getElementById('player-panels');
        if (panelsContainer) {
            panelsContainer.innerHTML = '';  // Clear any placeholder text
            panelsContainer.style.display = 'flex';
            console.log('Player panels container cleared and set to flex');
        }
        
        // DISABLED: Old panel systems - using PlayerPanelsV2 instead
        /*
        if (typeof window.initPlayerPanels === 'function') {
            window.initPlayerPanels();
        } else {
            console.error('initPlayerPanels not found! Creating manually...');
            if (typeof window.PlayerPanelUI === 'function') {
                window.playerPanelUI = new window.PlayerPanelUI();
            } else {
                console.error('PlayerPanelUI class not found!');
            }
        }
        console.log('playerPanelUI after init:', window.playerPanelUI);
        setupPlayerPanels(playerCount);
        console.log('Player panels setup complete');
        
        // Create Player Cube UI (desktop - replaces panels visually)
        if (typeof window.PlayerCubeUI === 'function') {
            window.playerCubeUI = new window.PlayerCubeUI();
            window.playerCubeUI.setPlayers(gameState.players);
            window.playerCubeUI.setActivePlayer(0);
            console.log('PlayerCubeUI created successfully');
        } else {
            console.error('PlayerCubeUI class not found! Check player_cube.js is loaded.');
        }
        
        // Initialize new player cube with game data
        if (window.updatePlayerCube) {
            console.log('[board_3d] Calling updatePlayerCube with gameState.players:', gameState.players);
            console.log('[board_3d] Player count:', gameState.players.length);
            console.log('[board_3d] Player 0 data:', JSON.stringify(gameState.players[0], (key, val) => key === 'deck' ? '[Deck]' : val));
            const currentCards = gameState.players.map(p => '-');
            window.updatePlayerCube(gameState.players, gameState.currentPlayerIndex, currentCards);
        } else {
            console.error('[board_3d] window.updatePlayerCube is not defined!');
        }
        
        // Initialize NEW player panels system (v1.0)
        if (window.initPlayerPanels) {
            console.log('[board_3d] Initializing new player panels...');
            window.initPlayerPanels(gameState.players, gameState.currentPlayerIndex, 0);
        }
        */
        console.log('[board_3d] Old panel systems disabled - using GameUIMinimal');
        
        // Initialize GameUIMinimal (clean, minimal UI - current player only)
        if (window.GameUIMinimal) {
            console.log('[board_3d] Initializing GameUIMinimal...');
            // Disable old panels
            window.GameUIMinimal.disableOldPanels();
            
            // Set current player
            window.GameUIMinimal.setCurrentPlayer(
                gameState.currentPlayer, 
                gameState.currentPlayerIndex
            );
            window.GameUIMinimal.setDeckCount(gameState.currentPlayer?.deck?.remaining || 54);
            
            // Set all players for menu
            window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
            
            // Connect draw card handler
            window.drawCard = function() {
                console.log('[GameUIMinimal.drawCard] Draw triggered', {
                    currentPlayer: gameState?.currentPlayerIndex,
                    phase: gameState?.phase
                });
                
                if (!gameState) {
                    console.error('[GameUIMinimal.drawCard] gameState not initialized!');
                    return;
                }
                
                if (gameState.phase !== 'draw') {
                    console.log('[GameUIMinimal.drawCard] Not in draw phase:', gameState.phase);
                    return;
                }
                
                handleDrawCard(false);  // false = not called by AI
            };
            
            console.log('[board_3d] GameUIMinimal initialized successfully');
        } else {
            console.error('[board_3d] GameUIMinimal not loaded!');
        }
        
        // Create Mobile UI (light pillars + action bar)
        if (typeof window.MobileUI === 'function') {
            window.mobileUI = new window.MobileUI();
            window.mobileUI.setScene(scene);
            window.mobileUI.onDeckClick = handleDrawCard;
            window.mobileUI.onMoveSelected = (move) => {
                console.log('[MobileUI] Move selected:', move);
                // Hide action bar and card popup immediately
                window.mobileUI.hideMoves();
                window.mobileUI.hideCardPopup();
                
                // Execute the move via hole click
                executeHoleClick(move.toHoleId);
            };
            window.mobileUI.updatePlayerInfo(
                gameState.currentPlayer.name,
                gameState.currentPlayer.avatar || 'ğŸ‘¤',
                gameState.currentPlayer.deck?.remaining || 54,
                gameState.currentPlayer.colorHex
            );
            console.log('MobileUI created');
        }
        
        // CardUI removed â€” using compact GameUIMinimal panel instead
        
        gameState.onCardDrawn = (card) => {
            console.log('[onCardDrawn] Card drawn:', card);
            
            // CRITICAL: Reset split state at every turn boundary to prevent stale state
            // A leftover splitMoveState.active=true will hijack executeMoveDirectly
            resetSplitMoveState();
            
            // Dispatch event for Mom Daemon
            document.dispatchEvent(new CustomEvent('cardDrawn', { detail: { card } }));
            
            // Defensive check - if card is null or invalid, skip turn
            if (!card || (!card.rank && !card.name)) {
                console.error('[onCardDrawn] Invalid card received!', card);
                cardUI.showMessage('Draw error - skipping turn', 2000);
                setTimeout(() => {
                    gameState.skipTurn();
                }, 2000);
                return;
            }
            
            cardUI.showCard(card);
            cardUI.updateDeckCount(gameState.deck.remaining);
            
            // Get player info for banner
            const playerIdx = gameState.currentPlayerIndex;
            const playerName = gameState.players[playerIdx].name || `Player ${playerIdx + 1}`;
            const playerColor = '#' + getThemedPlayerColor(playerIdx).toString(16).padStart(6, '0');
            const cardValue = card.name || card.value || card.movement;
            
            // Update side panel to show drawn card
            if (window.updatePlayerCube) {
                const currentCards = gameState.players.map((p, i) => {
                    if (i === playerIdx) {
                        const suitSym = getSuitSymbol(card.suit);
                        return `${card.rank || card.value || '?'}${suitSym}`;
                    }
                    return '-';
                });
                window.updatePlayerCube(gameState.players, gameState.currentPlayerIndex, currentCards);
            }
            
            // Update NEW player panels with card
            if (window.setPlayerCard) {
                const suitSym = getSuitSymbol(card.suit);
                const cardStr = `${card.rank || card.value || '?'}${suitSym}`;
                window.setPlayerCard(playerIdx, cardStr);
            }
            
            // Update GameUIMinimal with drawn card
            if (window.GameUIMinimal) {
                const suitSym = getSuitSymbol(card.suit);
                window.GameUIMinimal.setDrawnCard({
                    value: card.rank || card.value || '?',
                    suit: suitSym,
                    isRed: card.suit === 'hearts' || card.suit === 'diamonds'
                });
                // Update deck count
                window.GameUIMinimal.setDeckCount(gameState.currentPlayer?.deck?.remaining || 54);
                // Minimize deck after draw to maximize playing area
                if (typeof window.GameUIMinimal.setDeckDrawReady === 'function') {
                    window.GameUIMinimal.setDeckDrawReady(false);
                }
            }
            
            // Mobile: retract panel and show floating card
            if (window.mobileRetractPanel) {
                const suitSymbol = getSuitSymbol(card.suit);
                const cardText = `${card.rank || card.value || '?'}${suitSymbol}`;
                window.mobileRetractPanel(cardText);
            }
            
            // Mobile: show floating card in corner
            const isMobile = window.innerWidth <= 768;
            if (isMobile && window.mobileUI) {
                const suitSymbol = getSuitSymbol(card.suit);
                const cardText = `${card.rank || card.value || '?'}${suitSymbol}`;
                const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
                window.mobileUI.showFloatingCard(cardText, isRed);
            }
            
            // Calculate and highlight legal moves
            legalMoves = gameState.calculateLegalMoves();
            
            // Manual mode uses standard legal moves - no expansion needed
            
            // BoardManifold: validate every move against sealed rules
            if (window.BoardManifold && legalMoves.length > 0) {
                const beforeCount = legalMoves.length;
                legalMoves = BoardManifold.filterLegalMoves(legalMoves, gameState);
                if (legalMoves.length !== beforeCount) {
                    console.log(`[BoardManifold] Filtered ${beforeCount} â†’ ${legalMoves.length} legal moves`);
                }
            }
            // 7 card â€” SPLIT ONLY: must split 7 moves between exactly 2 pegs
            if (card.rank === '7') {
                const splitCheck = canSplitSeven();
                
                if (!splitCheck.valid) {
                    // No valid split â€” treat as no legal moves
                    console.log('[onCardDrawn] 7 Card â€” no valid split possible, skipping turn');
                    legalMoves = [];
                    // Fall through to the legalMoves.length === 0 handler below
                } else {
                    // Valid split exists
                    showCardRulePopup(card, splitCheck.combinations.length);
                    showCardDrawnBanner(playerName, playerColor, '7 - SPLIT âœ‚ï¸', false);
                    
                    if (!isAIPlayer(playerIdx)) {
                        // HUMAN: Interactive split mode
                        console.log(`[onCardDrawn] 7 Card SPLIT for human`);
                        startSplitMoveMode();
                    } else {
                        // AI: Auto-execute best split
                        console.log(`[onCardDrawn] 7 Card SPLIT for AI`);
                        let thinkDelay = AI_CONFIG.thinkingDelay || 1000;
                        if (window.ManifoldAI) {
                            const entity = ManifoldAI.getEntity(playerIdx);
                            if (entity) thinkDelay = entity.thinkingDelay;
                        }
                        setTimeout(() => aiExecuteSplit(), thinkDelay);
                    }
                    return; // Split mode handles everything
                }
            }
            
            if (legalMoves.length === 0) {
                // BoardManifold: assert no legal moves before showing message
                if (window.BoardManifold) {
                    const assertion = BoardManifold.assertNoLegalMoves(legalMoves, gameState);
                    console.log(`[BoardManifold] No legal moves assertion: ${assertion.reason}`);
                }
                hideTurnBanner();
                
                // Track consecutive stuck-in-holding turns ("jail" tracker)
                if (!window._jailTracker) window._jailTracker = {};
                const jt = window._jailTracker;
                if (!jt[playerIdx]) jt[playerIdx] = 0;
                const player = gameState.players[playerIdx];
                const allInHolding = player && player.peg && player.peg.every(p => 
                    p.holeType === 'holding' || p.holeType === 'home'
                );
                if (allInHolding) {
                    jt[playerIdx]++;
                    console.log(`â›“ï¸ Player ${playerIdx} stuck in jail: ${jt[playerIdx]} consecutive turns`);
                } else {
                    jt[playerIdx] = 0;
                }
                const isInJail = allInHolding && jt[playerIdx] >= 4;
                
                if (!isAIPlayer(playerIdx)) {
                    // HUMAN: Show modal popup â€” player clicks OK to skip
                    showNoLegalMovesPopup(card, () => {
                        gameState.skipTurn();
                        cardUI.clearCard();
                        clearHighlights();
                        if (window.mobileUI) window.mobileUI.hideFloatingCard();
                    }, isInJail);
                } else {
                    // AI: auto-skip after brief delay
                    showCardRulePopup(card, 0);
                    cardUI.showMessage(isInJail ? 'â›“ï¸ Still in jail!' : 'No legal moves!', 2000);
                    
                    // ManifoldAI: frustration adaptation shifts entity on surface
                    if (window.ManifoldAI) {
                        ManifoldAI.adaptEntity(playerIdx, 'no_legal_moves');
                    }
                    
                    // AI reacts with frustration
                    if (AI_REACTIONS.enabled) {
                        const reaction = AI_REACTIONS.frustration[Math.floor(Math.random() * AI_REACTIONS.frustration.length)];
                        setTimeout(() => {
                            sendDesktopReaction(reaction.emoji, reaction.name);
                        }, 500);
                    }
                    
                    setTimeout(() => {
                        gameState.skipTurn();
                        cardUI.clearCard();
                        clearHighlights();
                        if (window.mobileUI) window.mobileUI.hideFloatingCard();
                    }, 2000);
                }
            } else {
                // Mobile: show card popup with move value before showing choices
                if (isMobile && window.mobileUI && !isAIPlayer(playerIdx)) {
                    const moveCount = card.movement || card.value || 1;
                    const suitSym = getSuitSymbol(card.suit);
                    const cardDisplay = `${card.rank || card.value || '?'}${suitSym}`;
                    const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
                    
                    window.mobileUI.showCardPopup(cardDisplay, moveCount, isRed, () => {
                        // After popup closes, show move selection if multiple choices
                        if (legalMoves.length > 1) {
                            highlightLegalMoves(legalMoves);
                        } else {
                            // Single move - auto-execute (handled by mobileUI.showMoves)
                            highlightLegalMoves(legalMoves);
                        }
                    });
                    return; // Wait for popup to finish
                }
                
                // Determine if current player is human or AI
                const isAI = isAIPlayer(playerIdx);
                console.log(`ğŸ² [onCardDrawn] Player ${playerIdx} (${playerName}), isAI: ${isAI}, legalMoves: ${legalMoves.length}`);
                
                // Show all legal moves - HUMAN player must click on a destination
                if (!isAI) {
                    console.log(`ğŸ‘¤ [HUMAN] Showing ${legalMoves.length} legal moves for player ${playerIdx}`);
                    showCardRulePopup(card, legalMoves.length);
                    showCardDrawnBanner(playerName, playerColor, cardValue, legalMoves.length > 1);
                    highlightLegalMoves(legalMoves);
                } else {
                    // AI auto-selects after delay - NO highlights shown for AI
                    // Use entity-specific thinking delay from ManifoldAI
                    let thinkDelay = AI_CONFIG.thinkingDelay || 1000;
                    if (window.ManifoldAI) {
                        const entity = ManifoldAI.getEntity(playerIdx);
                        if (entity) thinkDelay = entity.thinkingDelay;
                    }
                    console.log(`ğŸ¤– [AI] Player ${playerIdx} has ${legalMoves.length} legal moves, scheduling selection in ${thinkDelay}ms`);
                    setTimeout(() => {
                        console.log(`ğŸ¤– [AI] Executing aiSelectAndClickMove for player ${gameState.currentPlayerIndex}`);
                        aiSelectAndClickMove();
                    }, thinkDelay);
                }
            }
        };
        
        gameState.onTurnEnd = (player, wasExtraTurn) => {
            console.log('[onTurnEnd] Called!', {
                player: player?.name,
                wasExtraTurn,
                currentPlayerIndex: gameState.currentPlayerIndex,
                phase: gameState.phase
            });

            // â”€â”€ Analytics: count turns â”€â”€
            if (window.FTAnalytics) FTAnalytics.turn();
            
            cardUI.updateCurrentPlayer(player);
            cardUI.updateTurnCount(gameState.turnCount);
            cardUI.setActivePlayer(gameState.currentPlayerIndex); // Update active deck with ? indicator
            cardUI.updateAllDeckCounts(gameState.players); // Update all deck counts
            cardUI.setDeckEnabled(false); // Disable until camera is ready
            hideTurnBanner(); // Hide any previous banner
            
            // Turn timer management
            // NO TIMER when a human only plays AI (solo mode) â€” timer is for multiplayer only
            const nextPlayer = gameState.players[gameState.currentPlayerIndex];
            const hasMultipleHumans = gameState.players.filter(p => !isAIPlayer(p.index)).length > 1;
            if (nextPlayer && !nextPlayer.isAI && gameSessionSettings.turnTimer && hasMultipleHumans) {
                // Start turn timer for human players in multiplayer
                startTurnTimer();
            } else {
                // Stop timer for AI turns or solo play
                stopTurnTimer();
            }
            
            // Exit decision mode - restore mobile UI panels after move is complete
            exitDecisionMode();
            
            // Update player panels
            if (window.playerPanelUI) {
                window.playerPanelUI.setActivePlayer(`player_${gameState.currentPlayerIndex}`);
                updatePlayerPanelStats();
            }
            
            // Update player cube (desktop)
            if (window.playerCubeUI) {
                window.playerCubeUI.setActivePlayer(gameState.currentPlayerIndex);
                // Update deck count for all players
                gameState.players.forEach((p, i) => {
                    window.playerCubeUI.updateDeckCount(i, p.deck?.remaining || 0);
                    window.playerCubeUI.updatePlayerStats(i, {
                        pegsInHolding: p.pegsInHolding,
                        pegsInSafe: p.pegsInSafeZone
                    });
                });
            }
            
            // Update GameUIMinimal (clean minimal UI)
            if (window.GameUIMinimal) {
                window.GameUIMinimal.setCurrentPlayer(
                    gameState.currentPlayer, 
                    gameState.currentPlayerIndex
                );
                window.GameUIMinimal.setDrawnCard(null);
                window.GameUIMinimal.setDeckCount(gameState.currentPlayer?.deck?.remaining || 54);
                window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
            }
            
            // Large deck removed - using scaled player panel instead
            
            // Update new player cube with game data
            if (window.updatePlayerCube) {
                const currentCards = gameState.players.map(p => {
                    const card = p.currentCard;
                    return card ? `${card.value}${card.suit}` : '-';
                });
                window.updatePlayerCube(gameState.players, gameState.currentPlayerIndex, currentCards);
            }
            
            // Mobile: expand panel for next turn
            if (window.mobileExpandPanel) {
                window.mobileExpandPanel();
            }
            
            // Broadcast player info to all players
            if (typeof GameStateBroadcaster !== 'undefined') {
                const playerInfo = gameState.players.map((p, i) => ({
                    index: i,
                    name: p.name,
                    pegsInHolding: p.pegsInHolding,
                    pegsInSafe: p.pegsInSafeZone,
                    deckRemaining: p.deck?.remaining ?? 54,
                    avatar: p.avatar || 'ğŸ‘¤'
                }));
                GameStateBroadcaster.updateState({
                    currentPlayerIndex: gameState.currentPlayerIndex,
                    turnNumber: gameState.turnCount,
                    playerInfo: playerInfo
                });
            }
            
            // MULTIPLAYER: Sync turn end to other players
            if (window.multiplayerClient && typeof multiplayerClient.isConnected === "function" && multiplayerClient.isConnected()) {
                multiplayerClient.sendTurnEnd(gameState.currentPlayerIndex);
            }
            
            // Update mobile UI
            if (window.mobileUI) {
                const currentPlayer = gameState.currentPlayer;
                window.mobileUI.updatePlayerInfo(
                    currentPlayer.name || `Player ${currentPlayer.index + 1}`,
                    'ğŸ‘¤',
                    currentPlayer.deck?.remaining || 0,
                    currentPlayer.colorHex
                );
            }
            
            // Shorter delay for extra turns, normal delay otherwise
            const delay = wasExtraTurn ? 500 : 2000;
            
            // Show "Board ready for [Player]" announcement
            const upcomingPlayerIdx = gameState.currentPlayerIndex;
            const upcomingPlayer = gameState.players[upcomingPlayerIdx];
            const upcomingPlayerName = upcomingPlayer.name || `Player ${upcomingPlayerIdx + 1}`;
            const upcomingPlayerAvatar = upcomingPlayer.avatar || 'ğŸ‘¤';
            const isBot = upcomingPlayer.isAI || upcomingPlayer.isBot || /[ğŸ¤–ğŸ”§âš™ï¸ğŸ®ğŸ’»]/.test(upcomingPlayerName);
            
            // Show transition announcement
            if (wasExtraTurn && !isBot) {
                // Immediately tell the human player they get another draw
                showDrawAgainPopup();
            } else if (!wasExtraTurn) {
                const readyMessage = isBot 
                    ? `ğŸ¤– ${upcomingPlayerAvatar} ${upcomingPlayerName}'s turn` 
                    : `${upcomingPlayerAvatar} Board ready for ${upcomingPlayerName}`;
                if (cardUI) cardUI.showMessage(readyMessage, 1500);
            }
            
            setTimeout(() => {
                const playerIdx = gameState.currentPlayerIndex;
                const player = gameState.players[playerIdx];
                const playerName = player.name || `Player ${playerIdx + 1}`;
                const playerAvatar = player.avatar || 'ğŸ‘¤';
                const playerColor = '#' + getThemedPlayerColor(playerIdx).toString(16).padStart(6, '0');
                
                function afterCameraReady() {
                    // Show turn banner for human players (different message for extra turn)
                    if (!isAIPlayer(playerIdx)) {
                        const message = wasExtraTurn ? 'EXTRA TURN! Draw again!' : 'Please draw a card';
                        showTurnBanner(`${playerAvatar} ${playerName}`, playerColor, message);
                    }
                    
                    // Enable deck only after camera is ready
                    cardUI.setDeckEnabled(true);
                    
                    // Pulse the mobile deck to signal "draw now!"
                    if (window.mobileUI && !isAIPlayer(playerIdx)) {
                        window.mobileUI.setDeckDrawReady(true);
                    }
                    
                    // If AI player, let them take their turn
                    if (isAIPlayer(playerIdx)) {
                        aiTakeTurn();
                    }
                }
                
                if (wasExtraTurn) {
                    // EXTRA TURN â€” same player. Keep camera where the last peg landed.
                    // No refocus needed; just enable drawing immediately.
                    afterCameraReady();
                } else {
                    // NEW PLAYER â€” reset override and focus on their pegs
                    resetCameraOverride();
                    focusOnPlayerPeg(playerIdx, afterCameraReady);
                }
            }, delay); // Use calculated delay (shorter for extra turns)
        };
        
        gameState.onMoveExecuted = (move, cutPeg, entryFlags = {}) => {
            // Reset jail tracker for this player â€” they made a move!
            if (window._jailTracker && gameState.currentPlayerIndex !== undefined) {
                window._jailTracker[gameState.currentPlayerIndex] = 0;
            }
            
            // DEBUG: Log all move execution details
            console.log('ğŸ“ onMoveExecuted called:', {
                moveToHoleId: move.toHoleId,
                isFastTrackEntry: move.isFastTrackEntry,
                entryFlags: entryFlags,
                hasFastTrackThemes: !!window.FastTrackThemes
            });
            
            // Get current player color from current theme palette
            const playerColor = getThemedPlayerColor(gameState.currentPlayer.index);
            const playerName = gameState.currentPlayer.name || `Player ${gameState.currentPlayer.index + 1}`;
            
            // ============================================================
            // SOUND EFFECTS - Play appropriate sounds for game events
            // ============================================================
            if (window.GameSFX) {
                // Always play arrival sound when peg reaches destination
                GameSFX.playArrive();
                
                // Check for special entry events
                if (entryFlags.exitedBullseye) {
                    // Royal exit from bullseye
                    GameSFX.playRoyalExit();
                } else if (entryFlags.enteredFasttrack) {
                    // FastTrack entry - exciting!
                    GameSFX.playFasttrack();
                } else if (entryFlags.enteredBullseye) {
                    // Bullseye entry
                    GameSFX.playBullseye();
                } else if (move.toHoleId && move.toHoleId.startsWith('safe-')) {
                    // Safe zone entry
                    GameSFX.playSafezone();
                }
                
                // Boot/cut opponent
                if (cutPeg) {
                    // Small delay so boot sound follows arrive
                    setTimeout(() => GameSFX.playBoot(), 150);
                }
                
                // Peg entering board from holding
                if (entryFlags.fromHolding) {
                    GameSFX.playPegEntry();
                }
            }
            
            // Check for game events and trigger theme reactions
            if (window.FastTrackThemes) {
                // Exiting bullseye with a royal card - show royal banner (overrides fasttrack)
                if (entryFlags.exitedBullseye) {
                    console.log('ğŸ‘‘ GOT A ROYAL! Exiting bullseye, triggering reaction...');
                    triggerThemeSwirl();
                    FastTrackThemes.triggerGameEvent('royal', { 
                        playerColor: playerColor,
                        playerName: playerName 
                    });
                }
                // Only trigger FastTrack banner when ENTERING (not traversing, not exiting bullseye)
                else if (entryFlags.enteredFasttrack) {
                    console.log('ğŸš€ FAST TRACK ENTRY! Triggering reaction...');
                    // Trigger dramatic swirl effect
                    triggerThemeSwirl();
                    FastTrackThemes.triggerGameEvent('fasttrack', { 
                        playerColor: playerColor,
                        playerName: playerName 
                    });
                    
                    // PRESTIGE: Award points for using FastTrack (bold move!)
                    if (!isAIPlayer(gameState.currentPlayerIndex) && window.PrestigeTracker) {
                        PrestigeTracker.award('fasttrack_use');
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // FASTTRACK AUTO/MANUAL CHOICE â€” Show prompt for human players
                    // Offer the choice: traverse automatically or manually each turn
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (!isAIPlayer(gameState.currentPlayerIndex)) {
                        setTimeout(() => showFTTraversalChoiceDialog(), 2000);
                    }
                }
                
                // Check if sent someone home (cut)
                if (cutPeg) {
                    console.log('ğŸ  SEND HOME! Triggering reaction...');
                    FastTrackThemes.triggerGameEvent('sendHome', { 
                        playerColor: playerColor,
                        victimPlayer: cutPeg.player 
                    });
                    
                    // PRESTIGE: Award points for vanquishing (only for human player)
                    if (!isAIPlayer(gameState.currentPlayerIndex) && window.PrestigeTracker) {
                        PrestigeTracker.award('peg_vanquish');
                    }
                }
                
                // Only trigger Bullseye banner when ENTERING (not already in center)
                if (entryFlags.enteredBullseye) {
                    console.log('ğŸ¯ BULLSEYE ENTRY! Triggering reaction...');
                    triggerThemeSwirl();
                    FastTrackThemes.triggerGameEvent('bullseye', { 
                        playerColor: playerColor,
                        playerName: playerName 
                    });
                    
                    // PRESTIGE: Award points for landing on bullseye
                    if (!isAIPlayer(gameState.currentPlayerIndex) && window.PrestigeTracker) {
                        PrestigeTracker.award('bullseye_land');
                    }
                }
            }
            
            // Update player panel stats
            if (window.playerPanelUI) {
                updatePlayerPanelStats();
                
                // Update golden crowns â€” check all players for safe zone fill
                if (window.updateGoldenCrown && gameState.players) {
                    for (const player of gameState.players) {
                        const safeCount = player.peg ? player.peg.filter(p => p.holeType === 'safezone').length : 0;
                        window.updateGoldenCrown(player.boardPosition, safeCount);
                    }
                }
                
                // Update mood based on action
                if (cutPeg) {
                    // Cutter feels smooth/revenge
                    window.playerPanelUI.setMood(`player_${gameState.currentPlayer.index}`, 'revenge');
                    // Victim feels dismay
                    window.playerPanelUI.setMood(`player_${cutPeg.player.index}`, 'dismay');
                    
                    // Track stats
                    gameState.currentPlayer.tokensSent = (gameState.currentPlayer.tokensSent || 0) + 1;
                    cutPeg.player.timesLost = (cutPeg.player.timesLost || 0) + 1;
                    
                    // Track in side panel
                    if (window.trackSentHome) {
                        window.trackSentHome(gameState.currentPlayer.index);
                    }
                }
            }
            
            // Handle cut animation if there was a cut (move animation already happened)
            if (cutPeg) {
                animateCut(cutPeg, move);
            }
            
            // Note: Extra turn logic is handled by game engine's endTurn() 
            // which fires onTurnEnd callback with wasExtraTurn flag
            
            // Broadcast state after move
            if (typeof GameStateBroadcaster !== 'undefined') {
                GameStateBroadcaster.updateState({
                    currentPlayerIndex: gameState.currentPlayerIndex,
                    turnNumber: gameState.turnCount,
                    turnPhase: gameState.phase,
                    lastMove: move
                });
            }
            
            // MULTIPLAYER: Sync move to other players
            if (window.multiplayerClient && typeof multiplayerClient.isConnected === "function" && multiplayerClient.isConnected()) {
                multiplayerClient.sendPegMove(
                    move.pegId,
                    move.fromHoleId,
                    move.toHoleId,
                    move.steps || 0,
                    cutPeg ? { pegId: cutPeg.id, playerId: cutPeg.player?.index } : null
                );
            }
            
            // AI Reactions - let AI express emotions about turn outcomes
            aiSendReaction(move, cutPeg, entryFlags);
        };
        
        gameState.onGameOver = (winner) => {
            const playerColor = getThemedPlayerColor(winner.index);
            const avatar = winner.avatar || 'ğŸ‘¤';

            // â”€â”€ Analytics: Track game completion â”€â”€
            if (window.FTAnalytics) {
                FTAnalytics.gameEnd(
                    winner.name || 'Player',
                    isAIPlayer(winner.index),
                    gameState.turnCount || 0
                );
            }
            
            // Play victory fanfare sound effect!
            if (window.GameSFX) {
                GameSFX.playVictory();
            }
            
            if (window.FastTrackThemes) {
                FastTrackThemes.triggerGameEvent('win', { 
                    playerColor: playerColor,
                    playerName: winner.name,
                    avatar: avatar
                });
            }
            
            // PRESTIGE: Award points for winning (only for human player)
            if (!isAIPlayer(winner.index) && window.PrestigeTracker) {
                PrestigeTracker.award('game_win');
                PrestigeTracker.syncWithServer();
            }
            
            // MULTIPLAYER: Notify game over
            if (window.multiplayerClient && typeof multiplayerClient.isConnected === "function" && multiplayerClient.isConnected()) {
                multiplayerClient.syncGameState(gameState, true); // final sync
            }
            
            // AI sportsmanship reactions â€” win or lose, bots love the game!
            if (AI_REACTIONS.enabled) {
                const pick = arr => arr[Math.floor(Math.random() * arr.length)];
                const getBotName = (idx) => {
                    const p = gameState.players?.[idx];
                    return p?.name?.replace(/^[^\w\s]+\s*/, '').trim() || 'Bot';
                };
                
                setTimeout(() => {
                    if (isAIPlayer(winner.index)) {
                        // AI won â€” celebrate but with sportsmanship!
                        // First: a couple celebration emojis
                        for (let i = 0; i < 2; i++) {
                            setTimeout(() => {
                                const reaction = pick(AI_REACTIONS.positive);
                                sendDesktopReaction(reaction.emoji, reaction.name);
                            }, i * 400);
                        }
                        // Then: a sportsmanship emoji from another bot
                        setTimeout(() => {
                            const reaction = pick(AI_REACTIONS.sportsmanship);
                            sendDesktopReaction(reaction.emoji, reaction.name);
                        }, 900);
                        // Chat: humble winner message
                        setTimeout(() => {
                            const msg = pick(AI_CHAT_MESSAGES.botWins);
                            aiSendChatBubble(msg, getBotName(winner.index));
                        }, 1200);
                    } else {
                        // Human won â€” bots CHEER and congratulate! They love humans!
                        AI_CONFIG.players.forEach((aiIdx, i) => {
                            setTimeout(() => {
                                const reaction = pick(AI_REACTIONS.sportsmanship);
                                sendDesktopReaction(reaction.emoji, reaction.name);
                            }, i * 350);
                        });
                        // Chat: congratulatory message from a random bot
                        setTimeout(() => {
                            const randomBot = AI_CONFIG.players[Math.floor(Math.random() * AI_CONFIG.players.length)];
                            const msg = pick(AI_CHAT_MESSAGES.humanWins);
                            aiSendChatBubble(msg, getBotName(randomBot));
                        }, 1000);
                        // Second bot chimes in too (if multiple bots)
                        if (AI_CONFIG.players.length > 1) {
                            setTimeout(() => {
                                const secondBot = AI_CONFIG.players[AI_CONFIG.players.length - 1];
                                const msg = pick(AI_CHAT_MESSAGES.humanWins);
                                aiSendChatBubble(msg, getBotName(secondBot));
                            }, 2000);
                        }
                    }
                }, 500);
            }
            
            // Save winner for "winner goes first" on replay
            lastWinnerIndex = winner.index;
            
            // Update player panel for winner
            if (window.playerPanelUI) {
                window.playerPanelUI.setWinner(`player_${winner.index}`);
                window.playerPanelUI.setMood(`player_${winner.index}`, 'celebration');
            }
            
            // â”€â”€ VICTORY CEREMONY CUTSCENE â”€â”€
            // Crown envelops peg â†’ rises â†’ giant peg with crown â†’ bow â†’ applause â†’ confetti â†’ replay
            const homeHole = holeRegistry.get(`home-${winner.boardPosition}`);
            const homePos = homeHole ? new THREE.Vector3(homeHole.position.x, homeHole.position.y, homeHole.position.z) : new THREE.Vector3(0, 0, 0);
            
            if (window.VictoryCeremony) {
                // Stop turn timer during ceremony
                if (typeof stopTurnTimer === 'function') stopTurnTimer();
                
                VictoryCeremony.start(winner, homePos, playerColor, () => {
                    // Ceremony complete â†’ show replay button
                    showPlayAgainButton(winner);
                });
            } else {
                // Fallback: no ceremony, just show message and button
                cardUI.showMessage(`${avatar} ${winner.name} WINS!`, 5000);
                setTimeout(() => {
                    showPlayAgainButton(winner);
                }, 3000);
            }
        };
        
        // Start game
        gameState.start();
        cardUI.updateCurrentPlayer(gameState.currentPlayer);
        cardUI.updateTurnCount(gameState.turnCount);
        cardUI.updateAllDeckCounts(gameState.players); // Update all player deck counts
        
        // Enable deck immediately for first player if human
        if (!isAIPlayer(gameState.currentPlayerIndex)) {
            cardUI.setDeckEnabled(true);
            if (window.mobileUI) {
                window.mobileUI.setDeckDrawReady(true);
            }
        }
        
        // Set active player panel
        if (window.playerPanelUI) {
            window.playerPanelUI.setActivePlayer(`player_${gameState.currentPlayerIndex}`);
        }
        
        // Show first player announcement, then turn banner
        console.log('[initGame] Setting up first turn, firstPlayerIndex:', gameState.currentPlayerIndex, 'initId:', thisInitId);
        const timer1 = setTimeout(() => {
            // Guard: only proceed if this is still the active init
            if (thisInitId !== gameInitCount) {
                console.log('[initGame] First timeout cancelled - newer init exists');
                return;
            }
            
            console.log('[initGame] First timeout fired, showing announcement');
            const playerIdx = gameState.currentPlayerIndex;
            const player = gameState.players[playerIdx];
            const playerName = player.name || `Player ${playerIdx + 1}`;
            const playerAvatar = player.avatar || 'ğŸ‘¤';
            const playerColor = '#' + getThemedPlayerColor(playerIdx).toString(16).padStart(6, '0');
            
            // Show who goes first (with avatar)
            showFirstPlayerAnnouncement(`${playerAvatar} ${playerName}`, playerColor, firstPlayerReason);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BOT WELCOME MESSAGES â€” bots greet at game start!
            // They love the human and want a fun, competitive game.
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (AI_REACTIONS.enabled && AI_CONFIG.enabled && AI_CONFIG.players.length > 0) {
                const pick = arr => arr[Math.floor(Math.random() * arr.length)];
                const getBotName = (idx) => {
                    const p = gameState.players?.[idx];
                    return p?.name?.replace(/^[^\w\s]+\s*/, '').trim() || 'Bot';
                };
                
                // First bot waves hello (emoji)
                setTimeout(() => {
                    if (thisInitId !== gameInitCount) return;
                    const reaction = pick(AI_REACTIONS.welcome);
                    sendDesktopReaction(reaction.emoji, reaction.name);
                }, 800);
                
                // First bot sends welcome chat
                setTimeout(() => {
                    if (thisInitId !== gameInitCount) return;
                    const botIdx = AI_CONFIG.players[0];
                    const msg = pick(AI_CHAT_MESSAGES.welcome);
                    aiSendChatBubble(msg, getBotName(botIdx));
                }, 1500);
                
                // Second bot chimes in (if multiple bots)
                if (AI_CONFIG.players.length > 1) {
                    setTimeout(() => {
                        if (thisInitId !== gameInitCount) return;
                        const reaction = pick(AI_REACTIONS.welcome);
                        sendDesktopReaction(reaction.emoji, reaction.name);
                    }, 2200);
                }
            }
            
            // Show turn banner after announcement fades
            const timer2 = setTimeout(() => {
                // Guard: only proceed if this is still the active init
                if (thisInitId !== gameInitCount) {
                    console.log('[initGame] Second timeout cancelled - newer init exists');
                    return;
                }
                
                console.log('[initGame] Second timeout fired, playerIdx:', playerIdx, 'isAI:', isAIPlayer(playerIdx));
                if (!isAIPlayer(playerIdx)) {
                    console.log('[initGame] Human player - showing turn banner');
                    showTurnBanner(`${playerAvatar} ${playerName}`, playerColor, 'Please draw a card');
                    
                    // Enable deck for human player to draw
                    if (cardUI) {
                        cardUI.setDeckEnabled(true);
                        console.log('[initGame] Deck enabled for human player');
                    }
                    
                    // Pulse the mobile deck to signal "draw now!"
                    if (window.mobileUI) {
                        window.mobileUI.setDeckDrawReady(true);
                    }
                } else {
                    // If AI goes first, let them take their turn
                    console.log('[initGame] AI player - calling aiTakeTurn()');
                    aiTakeTurn();
                }
            }, 3500);
            pendingFirstTurnTimers.push(timer2);
        }, 500);
        pendingFirstTurnTimers.push(timer1);
        
        console.log('Fastrack! game initialized with', playerCount, 'players');
        
        // MULTIPLAYER: Initialize connection if session info present
        initMultiplayerFromSession();
    }
    
    // Initialize multiplayer client from session parameters
    function initMultiplayerFromSession() {
        const params = new URLSearchParams(window.location.search);
        const sessionCode = params.get('session');
        const playerId = params.get('playerId');
        
        if (sessionCode && window.MultiplayerClient) {
            console.log('[Multiplayer] Session detected:', sessionCode);
            
            // Auto-detect WebSocket URL (supports local dev and production SSL)
            const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const wsUrl = isLocal 
                ? `ws://${window.location.hostname}:8765`
                : `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`;
            
            // Create multiplayer client
            window.multiplayerClient = new MultiplayerClient(
                wsUrl,
                sessionCode
            );
            
            // Set up event handlers for remote player actions (check if methods exist)
            if (typeof multiplayerClient.on === 'function') {
                multiplayerClient.on('peg_move', handleRemotePegMove);
                multiplayerClient.on('card_draw', handleRemoteCardDraw);
                multiplayerClient.on('turn_end', handleRemoteTurnEnd);
                multiplayerClient.on('game_state', handleRemoteGameState);
            } else {
                console.warn('[Multiplayer] multiplayerClient.on is not a function - skipping event handlers');
            }
            
            // Connect to lobby server (check if method exists)
            if (typeof multiplayerClient.connect === 'function') {
                multiplayerClient.connect().then(() => {
                console.log('[Multiplayer] Connected to lobby server');
                if (cardUI) {
                    cardUI.showMessage('Connected to multiplayer session!', 2000);
                }
            }).catch(err => {
                console.error('[Multiplayer] Connection failed:', err);
                if (cardUI) {
                    cardUI.showMessage('Could not connect to multiplayer', 2000);
                }
            });
            } else {
                console.warn('[Multiplayer] multiplayerClient.connect is not a function - skipping connection');
            }
        }
    }
    
    // Handle remote peg move from another player
    function handleRemotePegMove(data) {
        console.log('[Multiplayer] Remote peg move:', data);
        // Find the peg and animate the move
        const move = {
            pegId: data.pegId,
            fromHoleId: data.fromHole,
            toHoleId: data.toHole,
            steps: data.steps
        };
        
        // Animate the move without executing locally (already done on server)
        if (typeof animatePegMove === 'function') {
            animatePegMove(move, () => {
                // Handle vanquish if present
                if (data.vanquished && typeof animateCut === 'function') {
                    const cutPeg = { id: data.vanquished.pegId };
                    animateCut(cutPeg);
                }
            });
        }
    }
    
    // Handle remote card draw notification
    function handleRemoteCardDraw(data) {
        console.log('[Multiplayer] Remote card draw:', data);
        // Show visual feedback that opponent drew a card
        if (cardUI && data.playerIndex !== gameState.currentPlayerIndex) {
            cardUI.flashDeck(data.playerIndex);
        }
    }
    
    // Handle remote turn end
    function handleRemoteTurnEnd(data) {
        console.log('[Multiplayer] Remote turn end, next player:', data.nextPlayer);
        // Update current player if needed
        if (gameState && data.nextPlayer !== undefined) {
            gameState.currentPlayerIndex = data.nextPlayer;
            if (cardUI) {
                cardUI.updateCurrentPlayer(gameState.players[data.nextPlayer]);
            }
        }
    }
    
    // Handle full game state sync from host
    function handleRemoteGameState(data) {
        console.log('[Multiplayer] Game state sync received');
        // TODO: Full state sync for reconnection/late join
    }
    
    // Expose initGame to global scope for multiplayer integration
    window.initGame = initGame;
    // Expose aiTakeTurn for demo/promo spectator mode
    window.aiTakeTurn = aiTakeTurn;
    
    // Set up player panels for all players
    function setupPlayerPanels(playerCount) {
        const panelUI = window.playerPanelUI;
        if (!panelUI) {
            console.error('playerPanelUI not found!');
            return;
        }
        
        panelUI.clear();
        
        // Get themed player colors by board position (convert from hex number to CSS string)
        const getThemedColorCSS = (boardPos) => {
            const hexNum = getColorByBoardPosition(boardPos);
            return '#' + hexNum.toString(16).padStart(6, '0');
        };
        // Bot identities â€” derived from ManifoldAI geometric archetypes
        let botNames;
        if (window.BoardManifold) {
            botNames = BoardManifold.pickBots(6);
        } else if (window.ManifoldAI) {
            botNames = window.ManifoldAI.ARCHETYPE_POOL.map(key => {
                const arch = window.ManifoldAI.ARCHETYPES[key];
                return { name: arch.name, icon: arch.emoji };
            });
        } else {
            botNames = [
                { name: 'Turing', icon: 'ğŸ–¥ï¸' },
                { name: 'Ada', icon: 'âŒ¨ï¸' },
                { name: 'Nexus', icon: 'ğŸŒ' },
                { name: 'Cortex', icon: 'ğŸ§ ' },
                { name: 'Qubit', icon: 'âš›ï¸' },
                { name: 'Cipher', icon: 'ğŸ”' }
            ];
        }
        
        for (let i = 0; i < playerCount; i++) {
            // Get balanced board position for this player (for color matching)
            const boardPos = getBalancedBoardPosition(i, playerCount);
            
            // Check if this is an AI player
            const isAI = typeof AI_CONFIG !== 'undefined' && AI_CONFIG.enabled && AI_CONFIG.players.includes(i);
            
            // Try to load saved profile for player 0 (local player)
            let profile = null;
            if (i === 0 && typeof AvatarPersistence !== 'undefined') {
                profile = AvatarPersistence.load();
            }
            
            // Determine display name
            let displayName;
            if (i === 0) {
                displayName = profile?.displayName || 'You';
            } else if (isAI) {
                // Use AI_CONFIG order: players[0]=1, players[1]=2, etc.
                const botIndex = AI_CONFIG.players.indexOf(i);
                const bot = botNames[botIndex >= 0 ? botIndex : 0];
                displayName = `${bot.icon} ${bot.name}`;
            } else {
                displayName = `Player ${i + 1}`;
            }
            
            // Create player data
            const playerData = {
                id: `player_${i}`,
                displayName: displayName,
                avatarId: profile?.avatarId || (typeof AvatarSubstrate !== 'undefined' ? AvatarSubstrate.getRandom().id : null),
                colorHex: getThemedColorCSS(boardPos),  // Use themed colors matching peg/area colors
                guildId: profile?.guildId || null,
                guildName: profile?.guildName || null,
                isAI: isAI,
                isLocal: i === 0,
                stats: profile?.stats || { totalPoints: 0 },
                sessionStats: {
                    tokensInHolding: 4,
                    tokensInSafeZone: 0,
                    tokensSentHomeThisGame: 0,
                    timesSentHomeThisGame: 0
                },
                mood: 'neutral'
            };
            
            panelUI.addPlayer(playerData);
        }
        
        // Add click handlers to panel decks for drawing cards
        for (let i = 0; i < playerCount; i++) {
            const deckEl = document.getElementById(`deck-player_${i}`);
            if (deckEl) {
                deckEl.addEventListener('click', () => {
                    // Only allow drawing from current player's deck
                    if (gameState && gameState.currentPlayerIndex === i && gameState.phase === 'draw') {
                        handleDrawCard();
                    }
                });
            }
        }
    }
    
    // Update player panel stats from game state
    function updatePlayerPanelStats() {
        const panelUI = window.playerPanelUI;
        if (!panelUI || !gameState) return;
        
        gameState.players.forEach((player, index) => {
            const playerId = `player_${index}`;
            
            // Count pegs in different locations
            const holding = player.peg.filter(p => p.holeType === 'holding').length;
            const safeZone = player.peg.filter(p => p.holeType === 'safezone').length;
            
            panelUI.updatePanel(playerId, {
                sessionStats: {
                    tokensInHolding: holding,
                    tokensInSafeZone: safeZone,
                    tokensSentHomeThisGame: player.tokensSent || 0,
                    timesSentHomeThisGame: player.timesLost || 0
                }
            });
            
            // Update deck count
            if (player.deck) {
                panelUI.updateDeckCount(playerId, player.deck.cards.length);
            }
        });
    }
    
    function handleDrawCard(calledByAI = false) {
        console.log('[handleDrawCard] Called, calledByAI:', calledByAI, 'phase:', gameState?.phase, 'currentPlayerIndex:', gameState?.currentPlayerIndex);
        
        if (!gameState) {
            console.error('[handleDrawCard] gameState is not defined!');
            return;
        }
        
        if (gameState.phase !== 'draw') {
            console.log('[handleDrawCard] Not in draw phase, current phase:', gameState.phase);
            return;
        }
        
        // Stop turn timer when player acts (card draw)
        if (typeof stopTurnTimer === 'function') {
            stopTurnTimer();
        }
        
        // Check if this is a valid draw request
        const currentIdx = gameState.currentPlayerIndex;
        const isCurrentAI = isAIPlayer(currentIdx);
        console.log('[handleDrawCard] currentIdx:', currentIdx, 'isCurrentAI:', isCurrentAI);
        
        // If it's an AI's turn, only allow drawing if called by AI logic
        if (isCurrentAI && !calledByAI) {
            console.log('[handleDrawCard] Blocked human click during AI turn');
            return;
        }
        
        // If it's the human's turn, they should be the one clicking
        if (!isCurrentAI && calledByAI) {
            console.log('[handleDrawCard] AI tried to draw during human turn - blocked');
            return;
        }
        
        console.log('[handleDrawCard] Valid draw for player', currentIdx, '- calling gameState.drawCard()');
        
        // Large deck removed - using scaled player panel instead
        
        if (cardUI) {
            cardUI.setDeckEnabled(false);
            // Flash the current player's deck to show they drew
            cardUI.flashDeck(currentIdx);
        }
        
        const drawnCard = gameState.drawCard();
        console.log('[handleDrawCard] gameState.drawCard() returned:', drawnCard);
        
        // Auto-start music on first card draw by any player
        autoStartMusicOnFirstDraw();
        
        // Revealed card animation removed - using scaled player panel instead
        
        // Play draw card sound effect
        if (window.GameSFX && drawnCard) {
            GameSFX.playDrawCard();
            
            // Check for 6 card (extra turn) - play extra turn sound
            if (drawnCard.rank === '6' || drawnCard.value === '6') {
                setTimeout(() => GameSFX.playExtraTurn(), 200);
            }
        }
        
        // Stop the mobile deck pulse
        if (window.mobileUI) {
            window.mobileUI.setDeckDrawReady(false);
        }
        
        // Update deck count in player panel
        if (window.playerPanelUI) {
            const playerId = `player_${gameState.currentPlayerIndex}`;
            const player = gameState.players[gameState.currentPlayerIndex];
            if (player && player.deck) {
                window.playerPanelUI.updateDeckCount(playerId, player.deck.cards.length);
            }
        }
        
        // Update CardUI deck count immediately after draw (so AI deck visually decreases)
        if (cardUI) {
            cardUI.updateDeckCount(gameState.currentPlayer.deck?.remaining || 0);
            cardUI.updateAllDeckCounts(gameState.players);
        }
        
        // Update player cube with new card
        if (window.updatePlayerCube) {
            // Note: gameState.currentCard holds the drawn card, not individual player cards
            const drawnCard = gameState.currentCard;
            const currentCards = gameState.players.map((p, i) => {
                if (i === gameState.currentPlayerIndex && drawnCard) {
                    const suitSym = getSuitSymbol(drawnCard.suit);
                    return `${drawnCard.rank || drawnCard.value || '?'}${suitSym}`;
                }
                return '-';
            });
            window.updatePlayerCube(gameState.players, gameState.currentPlayerIndex, currentCards);
        }
        
        // Broadcast state to all players
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.updateState({
                currentPlayerIndex: gameState.currentPlayerIndex,
                turnNumber: gameState.turnCount,
                turnPhase: gameState.phase,
                activeCard: gameState.currentCard
            });
        }
        
        // MULTIPLAYER: Notify other players of card draw
        if (window.multiplayerClient && typeof multiplayerClient.isConnected === "function" && multiplayerClient.isConnected() && drawnCard) {
            multiplayerClient.sendCardDraw(
                drawnCard.rank || drawnCard.value,
                drawnCard.suit,
                gameState.currentPlayerIndex
            );
        }
    }
    
    // Track cut target pegs that are flashing
    let flashingCutTargets = [];
    // Track pegs with legal moves that should blink
    let blinkingMovablePegs = [];
    let highlightAnimationId = null;
    
    // Make pegs with legal moves blink to show player which can be moved
    function blinkMovablePegs(moves) {
        // Clear any existing blinking pegs
        clearBlinkingPegs();
        
        if (!moves || moves.length === 0) return;
        
        // Get unique peg IDs that have legal moves
        const movablePegIds = new Set();
        moves.forEach(move => {
            if (move.pegId) {
                movablePegIds.add(move.pegId);
            }
        });
        
        // Find and set up blinking for each movable peg
        movablePegIds.forEach(pegId => {
            const pegData = pegRegistry.get(pegId);
            if (pegData && pegData.bodyMesh) {
                if (!pegData.originalBlinkColor) {
                    pegData.originalBlinkColor = pegData.bodyMesh.material.color.getHex();
                }
                pegData.isBlinking = true;
                blinkingMovablePegs.push(pegData);
            }
        });
        
        console.log(`[blinkMovablePegs] ${blinkingMovablePegs.length} pegs can move`);
    }
    
    function clearBlinkingPegs() {
        blinkingMovablePegs.forEach(peg => {
            if (peg.originalBlinkColor && peg.bodyMesh) {
                peg.bodyMesh.material.color.setHex(peg.originalBlinkColor);
                if (peg.discMesh) peg.discMesh.material.color.setHex(peg.originalBlinkColor);
                // Reset emissive
                if (peg.bodyMesh.material.emissive) {
                    peg.bodyMesh.material.emissive.setHex(0x000000);
                    peg.bodyMesh.material.emissiveIntensity = 0;
                }
            }
            peg.isBlinking = false;
            delete peg.originalBlinkColor;
        });
        blinkingMovablePegs = [];
    }
    
    // Track path-highlighted holes (separate from destination highlights)
    let highlightedPathHoles = [];
    
    // Determine if moves require modal (complex choice)
    function hasComplexChoice(moves) {
        if (!moves || moves.length <= 1) return false;
        
        // Multiple pegs can move - always use modal
        const pegIds = new Set(moves.map(m => m.pegId));
        if (pegIds.size > 1) return true;
        
        // Single peg but multiple strategic options
        const hasCuts = moves.some(m => {
            if (!gameState || !gameState.players) return false;
            const currentPlayerIdx = gameState.currentPlayerIndex;
            for (const player of gameState.players) {
                if (player.index === currentPlayerIdx) continue;
                for (const peg of player.peg || []) {
                    if (peg.holeId === m.toHoleId) return true;
                }
            }
            return false;
        });
        
        const hasFTChoice = moves.some(m => m.isFastTrackEntry);
        const hasBullseyeChoice = moves.some(m => m.toHoleId === 'center');
        const hasSafeZone = moves.some(m => m.toHoleId && m.toHoleId.includes('safe'));
        
        // Use modal if there are strategic choices
        return hasCuts || hasFTChoice || hasBullseyeChoice || hasSafeZone;
    }

    function highlightLegalMoves(moves) {
        clearHighlights();
        
        console.log('[highlightLegalMoves] Highlighting', moves.length, 'moves, difficulty:', GAME_CONFIG.difficulty, 'showHighlights:', GAME_CONFIG.showHighlights);
        
        // HARD MODE: No highlights, user must count their own moves
        if (GAME_CONFIG.difficulty === 'hard') {
            console.log('ğŸ”¥ [HARD MODE] No move highlights - user must count moves manually');
            // Just enable click handling but don't show any visual aids
            addHardModeClickListeners();
            return;
        }
        
        // AUTO-MOVE FOR HUMANS: If only one legal move and auto-move is enabled, execute it automatically
        // BUT NOT during split mode - user must choose their split amounts manually
        const playerIdx = gameState?.currentPlayerIndex;
        const isHumanPlayer = !isAIPlayer(playerIdx);
        const inSplitMode = splitMoveState && splitMoveState.active;
        
        console.log('[highlightLegalMoves] isHumanPlayer:', isHumanPlayer, 'autoMoveForHumans:', GAME_CONFIG.autoMoveForHumans, 'inSplitMode:', inSplitMode);
        
        if (isHumanPlayer && moves.length === 1 && GAME_CONFIG.autoMoveForHumans && !inSplitMode) {
            console.log('\u26a1 Auto-executing single move for human player:', moves[0].toHoleId);
            // Show brief notification
            showAutoMoveBanner();
            setTimeout(() => {
                executeMoveDirectly(moves[0]);
            }, GAME_CONFIG.autoMoveDelay);
            return; // Don't show move selection UI
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FASTTRACK AUTO-TRAVERSE: If enabled, auto-select the FT traverse move
        // when a human player has an FT peg and the FT traverse option is available.
        // This skips the manual choice and keeps the peg moving around the ring.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (isHumanPlayer && GAME_CONFIG.ftAutoTraverse && !inSplitMode) {
            const ftTraverseMove = moves.find(m => 
                m.toHoleId && m.toHoleId.startsWith('ft-') && 
                !m.isLeaveFastTrack && !m.isCenterOption &&
                // Must be from an FT peg (peg currently on FT)
                gameState.currentPlayer.peg.find(p => p.id === m.pegId && p.onFasttrack)
            );
            if (ftTraverseMove) {
                console.log(`ğŸš€ [FT Auto-Traverse] Auto-executing FT move: ${ftTraverseMove.fromHoleId} â†’ ${ftTraverseMove.toHoleId}`);
                if (cardUI) {
                    cardUI.showActionBanner('ğŸš€ Auto-traversing FastTrack...', 'default');
                    setTimeout(() => { if (cardUI) cardUI.hideActionBanner(); }, 800);
                }
                setTimeout(() => {
                    executeMoveDirectly(ftTraverseMove);
                }, GAME_CONFIG.autoMoveDelay);
                return; // Don't show move selection UI
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MOVE SELECTION MODAL: Use touch-friendly modal for complex choices
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const shouldUseModal = isHumanPlayer && moves.length > 1 && window.moveSelectionModal && hasComplexChoice(moves);
        
        if (shouldUseModal && !GAME_CONFIG.suggestionsDisabled) {
            console.log('ğŸ“± [MoveSelectionModal] Showing modal for', moves.length, 'moves');
            window.moveSelectionModal.show(moves, gameState, (selectedMove) => {
                console.log('ğŸ“± [MoveSelectionModal] Move selected:', selectedMove);
                executeMoveDirectly(selectedMove);
            });
            // DON'T return â€” fall through to set up blinking highlights underneath
            // so if the player closes the modal, they can still click highlighted holes
        }
        
        // Make pegs with legal moves blink (unless highlights are disabled)
        if (GAME_CONFIG.showHighlights) {
            console.log('âœ¨ [highlightLegalMoves] Enabling peg blinking for', moves.length, 'moves');
            
            // LOG ALL LEGAL MOVES - EXHAUSTIVE LIST
            console.log('ğŸ“‹ [EXHAUSTIVE LEGAL MOVES] Total:', moves.length);
            moves.forEach((move, idx) => {
                console.log(`   ${idx + 1}. Peg ${move.pegId}: ${move.fromHoleId} â†’ ${move.toHoleId} (${move.steps} steps)${move.isFastTrackEntry ? ' [FT Entry]' : ''}${move.isLeaveFastTrack ? ' [Leave FT]' : ''}${move.type === 'enter' ? ' [ENTER]' : ''}`);
            });
            
            blinkMovablePegs(moves);
            
            // Show peg numbers when multiple pegs can move
            const uniquePegIds = new Set(moves.map(m => m.pegId).filter(Boolean));
            if (uniquePegIds.size > 1) {
                showPegNumbers([...uniquePegIds]);
            }
        } else {
            console.log('âš ï¸ [highlightLegalMoves] showHighlights is FALSE - no visual aids');
        }
        
        // Voice hints - announce available moves
        if (GAME_CONFIG.hintMode === 'voice' || GAME_CONFIG.hintMode === 'all') {
            speakLegalMoves(moves);
        }
        
        // Dropdown suggestion list
        if ((GAME_CONFIG.hintMode === 'dropdown' || GAME_CONFIG.hintMode === 'all') && !GAME_CONFIG.suggestionsDisabled) {
            showMoveDropdown(moves);
        }
        
        // Camera: move TOWARD the choices, not away
        highlightsActive = true;
        focusOnChoices(moves);
        
        // Hide light pillars - just use hole highlighting
        if (window.mobileUI) {
            window.mobileUI.showMoves(moves);
        }
        
        // Only highlight holes if showHighlights is enabled
        if (GAME_CONFIG.showHighlights) {
            // ============================================================
            // FULL PATH HIGHLIGHTING â€” Every hole along each traversal
            // path lights up with a gradient (dim near start, bright at end).
            // Destination holes get the biggest glow + ring (Fitts' Law).
            // ============================================================
            const destinationSet = new Set();  // Track destination holeIds to avoid double-highlighting
            const pathSet = new Set();         // Track path holeIds (non-destination)

            moves.forEach(move => {
                const path = move.path || [];
                const destHoleId = move.toHoleId;
                destinationSet.add(destHoleId);

                // Highlight PATH holes (skip index 0 = start, skip last = destination)
                for (let i = 1; i < path.length - 1; i++) {
                    const holeId = path[i];
                    if (destinationSet.has(holeId)) continue; // Don't dim a destination
                    if (pathSet.has(holeId)) continue;        // Already highlighted
                    pathSet.add(holeId);

                    const hole = holeRegistry.get(holeId);
                    if (!hole || !hole.mesh) continue;

                    // Store original material
                    if (!hole.originalMaterial) {
                        hole.originalMaterial = hole.mesh.material.clone();
                    }

                    // Gradient: progress 0 = dim (near peg), 1 = bright (near destination)
                    const progress = path.length > 2 ? (i - 1) / (path.length - 2) : 0.5;
                    const baseOpacity = 0.25 + progress * 0.35;  // 0.25 â†’ 0.60
                    const emissiveStr = 0.2 + progress * 0.4;    // 0.2 â†’ 0.6

                    const pathColor = 0x00ccff;  // Cyan trail
                    const pathMat = new THREE.MeshStandardMaterial({
                        color: pathColor,
                        emissive: pathColor,
                        emissiveIntensity: emissiveStr,
                        transparent: true,
                        opacity: baseOpacity
                    });
                    hole.mesh.material = pathMat;
                    hole.isPathHighlighted = true;
                    hole.pathProgress = progress;
                    hole.highlightTime = Math.random() * Math.PI * 2;
                    highlightedPathHoles.push(hole);

                    // Bright path ring â€” visible glow along the trail
                    const pathRingGroup = new THREE.Group();
                    pathRingGroup.position.copy(hole.mesh.position);
                    pathRingGroup.position.y += 0.3;
                    pathRingGroup.rotation.x = -Math.PI / 2;

                    // Inner solid ring
                    const innerGeom = new THREE.RingGeometry(2.5, 4, 24);
                    const innerMat = new THREE.MeshBasicMaterial({
                        color: pathColor, transparent: true, opacity: baseOpacity * 0.9, side: THREE.DoubleSide
                    });
                    pathRingGroup.add(new THREE.Mesh(innerGeom, innerMat));

                    // Outer glow ring
                    const outerGeom = new THREE.RingGeometry(4, 6, 24);
                    const outerMat = new THREE.MeshBasicMaterial({
                        color: pathColor, transparent: true, opacity: baseOpacity * 0.45, side: THREE.DoubleSide
                    });
                    pathRingGroup.add(new THREE.Mesh(outerGeom, outerMat));

                    boardGroup.add(pathRingGroup);
                    hole.pathRing = pathRingGroup;
                }
            });

            // Now highlight DESTINATION holes (bright, large glow ring)
            // MUST highlight ALL legal moves - this is EXHAUSTIVE
            console.log(`ğŸ¯ [DESTINATION HIGHLIGHTING] Processing ${moves.length} destination holes...`);
            let highlightedCount = 0;
            let missingCount = 0;
            
            moves.forEach((move, idx) => {
                const hole = holeRegistry.get(move.toHoleId);
                
                if (!hole) {
                    console.error(`âŒ [highlightLegalMoves] HOLE NOT FOUND: ${move.toHoleId}`);
                    missingCount++;
                    return;
                }
                if (!hole.mesh) {
                    console.error(`âŒ [highlightLegalMoves] HOLE HAS NO MESH: ${move.toHoleId}`);
                    missingCount++;
                    return;
                }
                
                // Store original material
                if (!hole.originalMaterial) {
                    hole.originalMaterial = hole.mesh.material.clone();
                }
                
                // Check if this move would cut an opponent
                const cutTarget = findCutTargetAtHole(move.toHoleId);
                const hasCutTarget = cutTarget !== null;
                
                // Create blinking highlight material with glow
                const baseColor = hasCutTarget ? 0xff4444 : 0x00ff88;  // Red for cuts, bright green for safe moves
                const highlightMat = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    emissive: baseColor,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                hole.mesh.material = highlightMat;
                hole.isHighlighted = true;
                hole.hasCutTarget = hasCutTarget;
                hole.highlightTime = Math.random() * Math.PI * 2; // Random start phase for varied blinking
                highlightedHoles.push(hole);
                highlightedCount++;
                
                // Create bullseye wireframe target around the destination hole
                createBullseyeTarget(hole, hasCutTarget ? 0xff4444 : 0x00ff88);
                
                // Flash the opponent token if it can be cut
                if (cutTarget) {
                    flashCutTarget(cutTarget);
                }
            });
            
            console.log(`âœ… [DESTINATION HIGHLIGHTING] Highlighted ${highlightedCount}/${moves.length} holes (${missingCount} missing)`);
            if (missingCount > 0) {
                console.warn(`âš ï¸ ${missingCount} destination holes were NOT highlighted due to missing registry entries!`);
            }
            
            // Start pulsing/blinking animation (includes path pulse)
            startHighlightAnimation();
        }

        // ============================================================
        // CHOICE POPUP â€” Only show when dropdown hint mode is enabled
        // For blink mode (default), users click directly on blinking holes
        // ============================================================
        const showDropdownModal = (GAME_CONFIG.hintMode === 'dropdown' || GAME_CONFIG.hintMode === 'all');
        
        if (isHumanPlayer && moves.length > 1 && showDropdownModal && !GAME_CONFIG.suggestionsDisabled) {
            // Group moves by pegId to see if there are real choices
            const pegGroups = {};
            moves.forEach(m => {
                if (!pegGroups[m.pegId]) pegGroups[m.pegId] = [];
                pegGroups[m.pegId].push(m);
            });
            const uniquePegs = Object.keys(pegGroups);

            // Show choice modal when there are multiple unique destinations
            // (not just same-peg variants like FT entry vs regular)
            if (uniquePegs.length >= 1) {
                showMoveChoiceModal(moves, pegGroups);
            }
        }
        
        // Add click handlers for highlighted holes
        addHoleClickListeners();
    }

    // ============================================================
    // MOVE CHOICE MODAL â€” Replaces small dropdown with a clear,
    // centered popup (Nielsen #1 Visibility, #6 Recognition over recall)
    // ============================================================
    function showMoveChoiceModal(moves, pegGroups) {
        const modal = document.getElementById('move-choice-modal');
        const titleEl = document.getElementById('choice-modal-title');
        const subtitleEl = document.getElementById('choice-modal-subtitle');
        const itemsEl = document.getElementById('choice-modal-items');
        if (!modal || !itemsEl) return;

        const card = gameState.currentCard;
        const cardName = card ? (card.rank || card.value || '?') : '?';

        titleEl.textContent = `Choose Your Move`;
        subtitleEl.textContent = `Card: ${cardName} â€” ${moves.length} option${moves.length !== 1 ? 's' : ''}`;
        itemsEl.innerHTML = '';

        moves.forEach((move, idx) => {
            const item = document.createElement('div');
            item.className = 'choice-item';

            let icon = 'ğŸ“';
            let name = move.toHoleId;
            let desc = `${move.steps || '?'} step${(move.steps || 0) !== 1 ? 's' : ''}`;
            let cls = '';

            // Check if there's also a center option for this peg (penultimate ft-* scenario)
            const hasCenterOptionForPeg = moves.some(m => m.pegId === move.pegId && (m.isCenterOption || m.toHoleId === 'center'));
            const isAlternativeToCenter = hasCenterOptionForPeg && !move.isCenterOption && move.toHoleId !== 'center';

            // Determine styling based on move type
            const friendly = friendlyHoleName(move.toHoleId);
            const cutTarget = findCutTargetAtHole(move.toHoleId);
            if (cutTarget) {
                icon = 'âš”ï¸'; name = `Cut at ${friendly}`; cls = 'cut-choice';
                desc = `Capture ${cutTarget.player.name}'s peg`;
            } else if (move.isCenterOption || move.toHoleId === 'center') {
                icon = 'ğŸ¯'; name = 'Enter the Bullseye'; cls = 'ft-choice';
                desc = 'Safe spot â€” exit with J, Q, or K';
            } else if (isAlternativeToCenter) {
                icon = 'â¡ï¸'; name = `Skip Bullseye`; cls = '';
                desc = `Continue to ${friendly}`;
            } else if (move.isFastTrackEntry) {
                icon = 'âš¡'; name = 'Take the FastTrack shortcut'; cls = 'ft-choice';
                desc = 'Speed across the inner ring';
            } else if (move.isLeaveFastTrack) {
                icon = 'ğŸ”„'; name = 'Exit FastTrack'; cls = '';
                desc = `Back to ${friendly}`;
            } else if (move.toHoleId.startsWith('safe-')) {
                icon = 'ğŸ›¡ï¸'; name = friendly; cls = 'safe-choice';
                desc = 'Protected â€” cannot be cut!';
            } else if (move.toHoleId.startsWith('ft-')) {
                icon = 'â­'; name = friendly;
                desc = `${move.steps} step${move.steps !== 1 ? 's' : ''} on inner ring`;
            } else if (move.type === 'enter') {
                icon = 'ğŸš€'; name = 'Enter the board';
                desc = 'Bring a peg out of holding';
            } else if (move.toHoleId.startsWith('home-')) {
                icon = 'ğŸ’'; name = friendly;
                desc = move.steps === 1 ? 'Land on the home hole' : `${move.steps} steps to home`;
            } else {
                name = `Move to ${friendly}`;
                desc = `${move.steps || '?'} step${(move.steps || 0) !== 1 ? 's' : ''} forward`;
            }

            // Show which peg
            const pegLabel = move.pegId ? move.pegId.replace('peg-', 'P').replace('-', '') : '';

            if (cls) item.classList.add(cls);
            item.innerHTML = `
                <span class="choice-icon">${icon}</span>
                <div class="choice-details">
                    <div class="choice-name">${name}</div>
                    <div class="choice-desc">${desc}</div>
                </div>
                <span class="choice-path-badge">${pegLabel} Â· ${move.steps || '?'}â†·</span>
            `;

            item.addEventListener('click', () => {
                hideMoveChoiceModal();
                executeMoveDirectly(move);
            });
            itemsEl.appendChild(item);
        });

        modal.classList.add('visible');
    }

    function hideMoveChoiceModal() {
        const modal = document.getElementById('move-choice-modal');
        if (modal) modal.classList.remove('visible');
    }
    window.hideMoveChoiceModal = hideMoveChoiceModal;

    // Close choice modal on Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            hideMoveChoiceModal();
        }
    });
    
    // ============================================================
    // BULLSEYE TARGET â€” concentric wireframe rings with pulsing glow
    // ============================================================
    function createBullseyeTarget(hole, color) {
        if (!hole.mesh) return;

        const group = new THREE.Group();
        group.position.copy(hole.mesh.position);
        group.position.y += 0.5;
        group.rotation.x = -Math.PI / 2;

        // Ring specs: [innerRadius, outerRadius, opacity]
        const rings = [
            [2, 4, 0.85],    // Center ring â€” bright solid
            [5, 6.5, 0.6],   // Middle ring
            [8, 9.5, 0.4],   // Outer ring
            [11, 12, 0.22],  // Wide aura ring
        ];

        const meshes = [];
        rings.forEach(([inner, outer, opacity], idx) => {
            const geom = new THREE.RingGeometry(inner, outer, 32);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geom, mat);
            group.add(mesh);
            meshes.push({ mesh, baseOpacity: opacity, idx });
        });

        // Crosshair lines (wireframe feel)
        const lineColor = new THREE.Color(color);
        const lineMat = new THREE.LineBasicMaterial({ color: lineColor, transparent: true, opacity: 0.5 });
        const armLen = 14;
        for (let angle = 0; angle < 4; angle++) {
            const a = (angle / 4) * Math.PI * 2;
            const pts = [
                new THREE.Vector3(Math.cos(a) * 5, Math.sin(a) * 5, 0),
                new THREE.Vector3(Math.cos(a) * armLen, Math.sin(a) * armLen, 0)
            ];
            const lineGeom = new THREE.BufferGeometry().setFromPoints(pts);
            const line = new THREE.Line(lineGeom, lineMat);
            group.add(line);
            meshes.push({ mesh: line, baseOpacity: 0.5, isLine: true });
        }

        boardGroup.add(group);
        hole.glowRing = group;          // keep same property name for clearHighlights compat
        hole.bullseyeRings = meshes;    // per-ring data for animation
    }

    // Remove bullseye target from hole
    function removeHoleGlowRing(hole) {
        if (hole.glowRing) {
            hole.glowRing.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            boardGroup.remove(hole.glowRing);
            delete hole.glowRing;
            delete hole.bullseyeRings;
        }
    }
    
    function findCutTargetAtHole(holeId) {
        const currentPlayerIdx = gameState.currentPlayerIndex;
        
        for (const player of gameState.players) {
            if (player.index === currentPlayerIdx) continue;
            
            for (const peg of player.peg) {
                if (peg.holeId === holeId && peg.holeType !== 'holding') {
                    return { player, peg, pegId: peg.id };
                }
            }
        }
        return null;
    }
    
    // Calculate track distance between two holes (clockwise direction)
    // Returns how many steps from 'fromHoleId' to 'toHoleId' going clockwise
    function getTrackDistance(fromHoleId, toHoleId) {
        if (!fromHoleId || !toHoleId || fromHoleId === toHoleId) return 0;
        
        // Skip special holes
        if (fromHoleId === 'center' || toHoleId === 'center') return -1;
        if (fromHoleId.includes('safe') || toHoleId.includes('safe')) return -1;
        if (fromHoleId.includes('winner') || toHoleId.includes('winner')) return -1;
        
        // Build the clockwise track order (same as game_engine.js)
        const clockwiseTrack = [];
        for (let p = 0; p < 6; p++) {
            for (let h = 1; h <= 4; h++) {
                clockwiseTrack.push(`side-left-${p}-${h}`);
            }
            for (let h = 0; h < 4; h++) {
                clockwiseTrack.push(`outer-${p}-${h}`);
            }
            clockwiseTrack.push(`home-${p}`);
            for (let h = 4; h >= 1; h--) {
                clockwiseTrack.push(`side-right-${p}-${h}`);
            }
            const nextPlayer = (p + 1) % 6;
            clockwiseTrack.push(`ft-${nextPlayer}`);
        }
        
        const fromIdx = clockwiseTrack.indexOf(fromHoleId);
        const toIdx = clockwiseTrack.indexOf(toHoleId);
        
        if (fromIdx === -1 || toIdx === -1) return -1;
        
        // Clockwise distance (how many steps FROM fromIdx TO toIdx going forward)
        const trackLen = clockwiseTrack.length;
        return (toIdx - fromIdx + trackLen) % trackLen;
    }
    
    function flashCutTarget(cutTarget) {
        const peg = pegRegistry.get(cutTarget.pegId);
        if (!peg || !peg.bodyMesh) return;
        
        // Store original color (use bodyMesh which has the material)
        if (!peg.originalColor) {
            peg.originalColor = peg.bodyMesh.material.color.getHex();
        }
        
        peg.isFlashing = true;
        flashingCutTargets.push(peg);
    }
    
    function startHighlightAnimation() {
        // Clear any existing animation
        if (highlightAnimationId) {
            cancelAnimationFrame(highlightAnimationId);
        }
        
        const animate = () => {
            const time = Date.now() * 0.004;
            
            // ---- Animate PATH holes (subtle wave traveling toward destination) ----
            highlightedPathHoles.forEach(hole => {
                if (hole.mesh && hole.mesh.material && hole.isPathHighlighted) {
                    const offsetTime = time + (hole.highlightTime || 0);
                    const progress = hole.pathProgress || 0.5;
                    // Traveling wave: brighter pulse moves from start â†’ end
                    const wave = (Math.sin(offsetTime * 3 - progress * 4) + 1) / 2;
                    const baseOp = 0.2 + progress * 0.3;
                    const opacity = baseOp + wave * 0.2;
                    const emInt = 0.15 + progress * 0.3 + wave * 0.2;

                    hole.mesh.material.opacity = opacity;
                    hole.mesh.material.emissiveIntensity = emInt;

                    if (hole.pathRing) {
                        // pathRing is a Group; animate children
                        hole.pathRing.children.forEach(child => {
                            if (child.material) child.material.opacity = opacity * 0.7;
                        });
                        const s = 1.0 + wave * 0.15;
                        hole.pathRing.scale.set(s, s, 1);
                    }
                }
            });

            // ---- Animate DESTINATION holes (bright pulsing glow) ----
            highlightedHoles.forEach(hole => {
                if (hole.mesh && hole.mesh.material) {
                    // Use offset time for each hole to vary blinking
                    const offsetTime = time + (hole.highlightTime || 0);
                    
                    // Create blinking effect (on/off with smooth transition)
                    const blinkCycle = (Math.sin(offsetTime * 6) + 1) / 2; // 0 to 1
                    const opacity = 0.4 + blinkCycle * 0.6;
                    const emissiveIntensity = 0.3 + blinkCycle * 0.7;
                    
                    // Color cycling between bright colors
                    const baseHue = hole.hasCutTarget ? 0 : 0.35; // Red for cuts, green-cyan for safe
                    const hueShift = Math.sin(offsetTime * 2) * 0.1;
                    const color = new THREE.Color().setHSL(baseHue + hueShift, 1.0, 0.5 + blinkCycle * 0.2);
                    
                    hole.mesh.material.color.copy(color);
                    hole.mesh.material.emissive.copy(color);
                    hole.mesh.material.opacity = opacity;
                    hole.mesh.material.emissiveIntensity = emissiveIntensity;
                    
                    // Animate bullseye rings â€” each ring pulses at a different phase
                    if (hole.bullseyeRings) {
                        hole.bullseyeRings.forEach(r => {
                            const phase = offsetTime * 5 - r.idx * 1.2; // ripple outward
                            const wave = (Math.sin(phase) + 1) / 2;
                            const opacity = r.baseOpacity * (0.5 + wave * 0.5);
                            if (r.mesh.material) {
                                r.mesh.material.opacity = opacity;
                                if (!r.isLine) r.mesh.material.color.copy(color);
                            }
                        });
                        // Gentle overall scale pulse
                        const scalePulse = 1.0 + blinkCycle * 0.08;
                        hole.glowRing.scale.set(scalePulse, scalePulse, 1);
                    }
                }
            });
            
            // Flash cut target pegs (red flash for opponent that will be cut)
            flashingCutTargets.forEach(peg => {
                if (peg.bodyMesh && peg.isFlashing) {
                    const flash = Math.sin(time * 10) > 0;
                    const flashColor = flash ? 0xff0000 : peg.originalColor;
                    peg.bodyMesh.material.color.setHex(flashColor);
                    if (peg.discMesh) peg.discMesh.material.color.setHex(flashColor);
                }
            });
            
            // Blink movable pegs (gold/bright pulsing for player's pegs that can move)
            blinkingMovablePegs.forEach(peg => {
                if (peg.bodyMesh && peg.isBlinking) {
                    // Pulse between original color and bright gold
                    const pulse = (Math.sin(time * 5) + 1) / 2;  // 0 to 1
                    const originalColor = new THREE.Color(peg.originalBlinkColor);
                    const highlightColor = new THREE.Color(0xffd700);  // Gold
                    const blendedColor = originalColor.clone().lerp(highlightColor, pulse * 0.6);
                    peg.bodyMesh.material.color.copy(blendedColor);
                    if (peg.discMesh) peg.discMesh.material.color.copy(blendedColor);
                    
                    // Also animate emissive for glow effect
                    if (peg.bodyMesh.material.emissive) {
                        peg.bodyMesh.material.emissive.setHex(0xffd700);
                        peg.bodyMesh.material.emissiveIntensity = pulse * 0.5;
                    }
                }
            });

            // Animate peg destination highlight rings (pulse and subtle opacity shift)
            if (pegDestHighlightObjects && pegDestHighlightObjects.length > 0) {
                pegDestHighlightObjects.forEach(r => {
                    try {
                        const ps = (r.userData && r.userData.pulseSpeed) ? r.userData.pulseSpeed : 2.0;
                        const base = (r.userData && r.userData.baseScale) ? r.userData.baseScale : 1.0;
                        const s = base + Math.sin(time * ps) * 0.08;
                        r.scale.set(s, s, s);
                        if (r.material) {
                            r.material.opacity = 0.6 + (Math.sin(time * ps) + 1) * 0.15;
                        }
                    } catch (e) {
                        // ignore animation errors for ad-hoc rings
                    }
                });
            }
            
            if (highlightedHoles.length > 0 || highlightedPathHoles.length > 0 || flashingCutTargets.length > 0 || blinkingMovablePegs.length > 0) {
                highlightAnimationId = requestAnimationFrame(animate);
            }
        };
        
        animate();
    }
    
    function clearHighlights() {
        // Unlock camera â€” player has chosen, normal transitions can resume
        highlightsActive = false;

        // Hide peg move dropdown if visible
        hidePegMoveDropdown();

        // Hide move choice modal if visible
        hideMoveChoiceModal();
        
        // Hide move suggestion dropdown (hint mode)
        hideMoveDropdown();
        
        // Hide peg number labels
        hidePegNumbers();
        
        // Exit decision mode - restore UI panels (safe to call multiple times)
        exitDecisionMode();
        
        // Stop animation
        if (highlightAnimationId) {
            cancelAnimationFrame(highlightAnimationId);
            highlightAnimationId = null;
        }
        
        // Clear mobile UI action bar (no light pillars anymore)
        if (window.mobileUI) {
            window.mobileUI.hideMoves();
        }

        // Restore PATH hole materials and remove path rings
        highlightedPathHoles.forEach(hole => {
            if (hole.originalMaterial) {
                hole.mesh.material = hole.originalMaterial;
            }
            hole.isPathHighlighted = false;
            delete hole.pathProgress;
            delete hole.highlightTime;
            if (hole.pathRing) {
                hole.pathRing.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                boardGroup.remove(hole.pathRing);
                delete hole.pathRing;
            }
        });
        highlightedPathHoles = [];
        
        // Restore DESTINATION hole materials and remove glow rings
        highlightedHoles.forEach(hole => {
            if (hole.originalMaterial) {
                hole.mesh.material = hole.originalMaterial;
            }
            hole.isHighlighted = false;
            hole.hasCutTarget = false;
            delete hole.highlightTime;
            
            // Remove glow ring
            removeHoleGlowRing(hole);
        });
        highlightedHoles = [];
        
        // Restore flashing peg colors (cut targets)
        flashingCutTargets.forEach(peg => {
            if (peg.originalColor && peg.bodyMesh) {
                peg.bodyMesh.material.color.setHex(peg.originalColor);
                if (peg.discMesh) peg.discMesh.material.color.setHex(peg.originalColor);
            }
            peg.isFlashing = false;
        });
        flashingCutTargets = [];
        
        // Restore blinking movable pegs
        clearBlinkingPegs();
        
        // Clear peg-specific destination highlights
        clearPegDestinationHighlights();
        
        // Clear hard mode selection
        clearHardModeSelection();
        
        removeHoleClickListeners();
    }
    
    function addHoleClickListeners() {
        window.addEventListener('click', handleHoleClick);
    }
    
    function removeHoleClickListeners() {
        window.removeEventListener('click', handleHoleClick);
        window.removeEventListener('click', handleHardModeClick);
    }
    
    // ============================================================
    // HARD MODE - Manual move validation
    // Player must click peg, then click destination hole (count yourself!)
    // ============================================================
    
    let hardModeSelectedPeg = null;
    
    function addHardModeClickListeners() {
        window.addEventListener('click', handleHardModeClick);
    }
    
    function handleHardModeClick(event) {
        if (gameState.phase !== 'play' || legalMoves.length === 0) return;
        if (isAIPlayer(gameState.currentPlayerIndex)) return;
        
        // Raycast to find clicked object
        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );
        
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(boardGroup.children, true);
        
        for (const intersect of intersects) {
            // Check if a peg was clicked (to select it OR as a destination for cutting)
            for (const [pegId, pegData] of pegRegistry) {
                if (pegData.bodyMesh === intersect.object || 
                    pegData.discMesh === intersect.object ||
                    pegData.mesh === intersect.object) {
                    
                    // Check if this peg belongs to current player and has moves (to SELECT it)
                    const pegMoves = legalMoves.filter(m => m.pegId === pegId);
                    if (pegMoves.length > 0) {
                        // Select this peg
                        hardModeSelectedPeg = pegId;
                        showHardModePegSelected(pegData);
                        console.log('ğŸ”¥ [HARD MODE] Selected peg:', pegId, 'with', pegMoves.length, 'possible moves');
                        return;
                    }
                    
                    // If peg already selected, check if clicked peg is at a valid destination (for cutting)
                    if (hardModeSelectedPeg) {
                        const pegHoleId = pegData.currentHole || pegData.holeId;
                        if (pegHoleId) {
                            const validMove = legalMoves.find(m => 
                                m.pegId === hardModeSelectedPeg && m.toHoleId === pegHoleId
                            );
                            
                            if (validMove) {
                                console.log('âœ… [HARD MODE] Valid move (via peg click):', hardModeSelectedPeg, 'â†’', pegHoleId);
                                clearHardModeSelection();
                                executeMoveDirectly(validMove);
                                return;
                            }
                        }
                    }
                }
            }
            
            // Check if a hole was clicked (to attempt move)
            for (const [holeId, hole] of holeRegistry) {
                if (hole.mesh === intersect.object) {
                    // If no peg selected, prompt to select one first
                    if (!hardModeSelectedPeg) {
                        showIllegalMovePopup('Select a peg first by clicking on it!');
                        return;
                    }
                    
                    // Check if this destination is valid for the selected peg
                    const validMove = legalMoves.find(m => 
                        m.pegId === hardModeSelectedPeg && m.toHoleId === holeId
                    );
                    
                    if (validMove) {
                        // Valid move! Execute it
                        console.log('âœ… [HARD MODE] Valid move:', hardModeSelectedPeg, 'â†’', holeId);
                        clearHardModeSelection();
                        executeMoveDirectly(validMove);
                    } else {
                        // Invalid move - provide detailed reason
                        console.log('âŒ [HARD MODE] Invalid move:', hardModeSelectedPeg, 'â†’', holeId);
                        const reason = getIllegalMoveReason(hardModeSelectedPeg, holeId);
                        showIllegalMovePopup(reason);
                    }
                    return;
                }
            }
        }
    }
    
    function showHardModePegSelected(pegData) {
        // Clear any previous selection
        clearHardModeSelection();
        
        // Highlight the selected peg
        if (pegData.bodyMesh && pegData.bodyMesh.material) {
            pegData._hardModeOriginalEmissive = pegData.bodyMesh.material.emissiveIntensity;
            pegData.bodyMesh.material.emissive = new THREE.Color(0xffffff);
            pegData.bodyMesh.material.emissiveIntensity = 0.5;
        }
        pegData._hardModeSelected = true;
    }
    
    function clearHardModeSelection() {
        hardModeSelectedPeg = null;
        // Reset any highlighted pegs
        pegRegistry.forEach(pegData => {
            if (pegData._hardModeSelected && pegData.bodyMesh && pegData.bodyMesh.material) {
                pegData.bodyMesh.material.emissiveIntensity = pegData._hardModeOriginalEmissive || 0;
                delete pegData._hardModeSelected;
                delete pegData._hardModeOriginalEmissive;
            }
        });
    }
    
    function formatHoleId(holeId) {
        const parts = holeId.split('-');
        if (parts[0] === 'outer') return `Outer track position ${parts[2]}`;
        if (parts[0] === 'side') return `Side track`;
        if (parts[0] === 'ft') return `FastTrack ${parts[1]}`;
        if (parts[0] === 'safe') return `Safe zone ${parts[2]}`;
        if (parts[0] === 'home') return `Home`;
        if (parts[0] === 'center') return `Bullseye`;
        return holeId;
    }
    
    // ================================================================
    // GET DETAILED ILLEGAL MOVE REASON
    // Explains WHY a move is not legal for better player understanding
    // ================================================================
    function getIllegalMoveReason(pegId, targetHoleId) {
        if (!gameState || !gameState.currentCard || !gameState.currentPlayer) {
            return 'No active card or player.';
        }
        
        const card = gameState.currentCard;
        const player = gameState.currentPlayer;
        const peg = player.peg.find(p => p.id === pegId);
        if (!peg) return 'Selected peg not found.';
        
        const cardRank = card.rank || card.value || '?';
        const hops = card.movement;
        const target = formatHoleId(targetHoleId);
        
        // Check specific reasons
        if (card.direction === 'backward') {
            if (targetHoleId.startsWith('ft-')) {
                return `The ${cardRank} moves backward â€” you cannot back into FastTrack holes.`;
            }
            if (targetHoleId.startsWith('safe-')) {
                return `The ${cardRank} moves backward â€” you cannot back into the Safe Zone.`;
            }
            if (targetHoleId === 'center') {
                return `The ${cardRank} moves backward â€” you cannot back into the Bullseye.`;
            }
        }
        
        if (peg.lockedToSafeZone && !targetHoleId.startsWith('safe-') && !targetHoleId.startsWith('home-') && card.direction !== 'backward') {
            return `This peg is locked to the Safe Zone â€” it can only move into safe zone holes or home.`;
        }
        
        if (peg.onFasttrack && peg.mustExitFasttrack) {
            if (targetHoleId.startsWith('ft-')) {
                return `A 4 was drawn â€” this peg must EXIT FastTrack to the outer track, not continue on the ring.`;
            }
        }
        
        // Check if own peg is blocking
        const ownPegBlocking = player.peg.find(p => p.holeId === targetHoleId && p.id !== pegId && !p.inBullseye);
        if (ownPegBlocking) {
            return `Your own peg is on ${target} â€” you cannot land on or pass through your own pegs.`;
        }
        
        // Distance check
        return `${target} is not exactly ${hops} ${hops === 1 ? 'hole' : 'holes'} away with the ${cardRank} card. Count carefully!`;
    }
    
    // Wrapper to use the full popup for hard mode illegal move reporting
    // (The styled popup is defined above with showIllegalMovePopup)
    
    function hideIllegalMovePopup() {
        const popup = document.getElementById('illegal-move-popup');
        if (popup) popup.remove();
    }
    window.hideIllegalMovePopup = hideIllegalMovePopup;
    
    // Track currently selected peg for dropdown
    let selectedPegForDropdown = null;
    
    // Track peg-selected state for destination-click workflow
    let selectedPegId = null;
    let selectedPegMoves = null;
    let pegDestHighlightedHoles = [];   // holes highlighted for a specific peg's destinations
    let pegDestHighlightObjects = [];   // THREE.js objects (rings, labels) to clean up

    // â”€â”€ Highlight all destination holes (and path) for a specific peg's moves â”€â”€
    function highlightPegDestinations(moves) {
        if (!moves || moves.length === 0) return;
        const destColors = {
            normal:    0x00ff88,
            fasttrack: 0xffcc00,
            bullseye:  0xff4488,
            safezone:  0x44aaff,
            cut:       0xff2222
        };

        moves.forEach(move => {
            const path = move.path || [];
            const destHoleId = move.toHoleId;

            // Highlight PATH holes (dim cyan trail)
            for (let i = 1; i < path.length - 1; i++) {
                const hole = holeRegistry.get(path[i]);
                if (!hole || !hole.mesh) continue;
                if (hole._pegDestSaved) continue; // already saved
                hole._pegDestSaved = hole.mesh.material;
                const progress = path.length > 2 ? (i - 1) / (path.length - 2) : 0.5;
                hole.mesh.material = new THREE.MeshStandardMaterial({
                    color: 0x00ccff,
                    emissive: 0x00ccff,
                    emissiveIntensity: 0.15 + progress * 0.35,
                    transparent: true,
                    opacity: 0.25 + progress * 0.3
                });
                pegDestHighlightedHoles.push(hole);
            }

            // Highlight DESTINATION hole (bright glow + ring)
            const destHole = holeRegistry.get(destHoleId);
            if (!destHole || !destHole.mesh) return;
            let color = destColors.normal;
            if (move.isFastTrackEntry) color = destColors.fasttrack;
            else if (move.isLeaveFastTrack) color = 0x00ccff;  // Cyan for leave-FT
            else if (destHoleId === 'center') color = destColors.bullseye;
            else if (destHoleId.startsWith('safe-')) color = destColors.safezone;
            else if (findCutTargetAtHole(destHoleId)) color = destColors.cut;

            if (!destHole._pegDestSaved) {
                destHole._pegDestSaved = destHole.mesh.material;
                destHole.mesh.material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.7,
                    transparent: true,
                    opacity: 0.85
                });
                pegDestHighlightedHoles.push(destHole);
            }

            // Add a bright ring around destination
            // Larger ring for easier clicking; scale up on mobile
            const isMobile = window.innerWidth <= 768;
            const innerR = isMobile ? 12 : 6;
            const outerR = isMobile ? 28 : 9;
            const ringGeom = new THREE.RingGeometry(innerR, outerR, 48);
            const ringMat = new THREE.MeshBasicMaterial({
                color: color, transparent: true, opacity: 0.9, side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.position.copy(destHole.mesh.position);
            ring.position.y += 0.4;
            ring.rotation.x = -Math.PI / 2;
            // Add subtle pulsing metadata so animate loop can pulse the ring
            ring.userData = ring.userData || {};
            ring.userData.pulseSpeed = 2 + Math.random() * 1.5;
            ring.userData.baseScale = 1;
            boardGroup.add(ring);
            pegDestHighlightObjects.push(ring);
        });
    }

    function clearPegDestinationHighlights() {
        pegDestHighlightedHoles.forEach(hole => {
            if (hole._pegDestSaved) {
                hole.mesh.material = hole._pegDestSaved;
                delete hole._pegDestSaved;
            }
        });
        pegDestHighlightedHoles = [];
        pegDestHighlightObjects.forEach(obj => {
            if (obj.parent) obj.parent.remove(obj);
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
        });
        pegDestHighlightObjects = [];
        selectedPegId = null;
        selectedPegMoves = null;
    }
    
    function handleHoleClick(event) {
        console.log('[handleHoleClick] Click detected, splitMoveState.active:', splitMoveState?.active, 'phase:', splitMoveState?.phase);
        
        // SPLIT MODE: Special handling for 7 card split
        if (splitMoveState.active && (splitMoveState.phase === 'select_first_peg' || splitMoveState.phase === 'select_second_peg')) {
            console.log('[Split Click] In peg selection phase:', splitMoveState.phase);
            
            // In peg selection phase - check if a selectable peg was clicked
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            // Pegs are added to scene, not boardGroup - check both
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            console.log('[Split Click] Raycast found', intersects.length, 'intersections');
            
            // Log which pegs are selectable
            let selectablePegs = [];
            for (const [pegId, pegData] of pegRegistry) {
                if (pegData.isSplitSelectable) {
                    selectablePegs.push(pegId);
                }
            }
            console.log('[Split Click] Selectable pegs in registry:', selectablePegs);
            
            for (const intersect of intersects) {
                console.log('[Split Click] Checking intersect object:', intersect.object.type, intersect.object.name || '(unnamed)');
                
                for (const [pegId, pegData] of pegRegistry) {
                    if (pegData.isSplitSelectable && 
                        (pegData.bodyMesh === intersect.object || 
                         pegData.discMesh === intersect.object ||
                         pegData.touchMesh === intersect.object ||
                         pegData.mesh === intersect.object)) {
                        console.log('[Split Click] âœ… Peg clicked:', pegId);
                        if (handleSplitPegClick(pegId)) {
                            return;
                        }
                    }
                }
            }
            console.log('[Split Click] No selectable peg was clicked');
            return; // In peg selection phase, only accept peg clicks
        }
        
        // SPLIT MODE DEST SELECTION: Allow clicks during destination selection
        const inSplitDestPhase = splitMoveState.active && 
            (splitMoveState.phase === 'select_first_dest' || splitMoveState.phase === 'select_second_dest');
        
        if (!inSplitDestPhase && (gameState.phase !== 'play' || legalMoves.length === 0)) return;
        
        // Check if clicking outside dropdown to close it
        const dropdown = document.getElementById('peg-move-dropdown');
        if (dropdown.classList.contains('visible')) {
            if (!dropdown.contains(event.target)) {
                hidePegMoveDropdown();
            }
            return;
        }
        
        // Raycast to find clicked object
        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );
        
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(boardGroup.children, true);
        
        for (const intersect of intersects) {
            // First check if a blinking peg was clicked (player's own peg with moves)
            for (const [pegId, pegData] of pegRegistry) {
                if (pegData.isBlinking && 
                    (pegData.bodyMesh === intersect.object || 
                     pegData.discMesh === intersect.object ||
                     pegData.touchMesh === intersect.object ||
                     pegData.mesh === intersect.object)) {
                    // Find all moves for this peg
                    const pegMoves = legalMoves.filter(m => m.pegId === pegId);
                    if (pegMoves.length === 1) {
                        // Single move â€” execute immediately (clear legal move)
                        console.log('[Click] Active peg clicked with single legal move - executing');
                        dismissCardRulePopup();
                        
                        executeMoveDirectly(pegMoves[0]);
                        return;
                    } else if (pegMoves.length > 1) {
                        // Multiple moves â€” light up ALL destination tracks for this peg
                        // PLUS show a popup/dropdown with tips for each option
                        console.log('[Click] Active peg clicked with multiple moves - showing options');
                        clearPegDestinationHighlights();
                        highlightPegDestinations(pegMoves);
                        selectedPegMoves = pegMoves;
                        selectedPegId = pegId;
                        showPegMoveDropdown(pegId, pegMoves, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            // Check if ANY peg was clicked - might be at a legal destination (for cutting)
            for (const [pegId, pegData] of pegRegistry) {
                if (pegData.bodyMesh === intersect.object || 
                    pegData.discMesh === intersect.object ||
                    pegData.touchMesh === intersect.object ||
                    pegData.mesh === intersect.object) {
                    // Get the hole this peg is on
                    const pegHoleId = pegData.currentHole || pegData.holeId;
                    if (pegHoleId) {
                        // Check if this hole is a legal destination (via highlight OR legalMoves array)
                        const hole = holeRegistry.get(pegHoleId);
                        const isHighlighted = hole && hole.isHighlighted;
                        const isLegalDest = legalMoves.some(m => m.toHoleId === pegHoleId);
                        
                        if (isHighlighted || isLegalDest) {
                            console.log('[handleHoleClick] Clicked peg at legal destination:', pegHoleId, 'highlighted:', isHighlighted, 'inLegalMoves:', isLegalDest);
                            executeHoleClick(pegHoleId);
                            return;
                        }
                    }
                }
            }
            
            // Then check if a highlighted hole was clicked
            for (const [holeId, hole] of holeRegistry) {
                if (hole.mesh === intersect.object) {
                    // If a peg was pre-selected and this hole is one of its destinations
                    if (selectedPegId && selectedPegMoves) {
                        const matchingMoves = selectedPegMoves.filter(m => m.toHoleId === holeId);
                        if (matchingMoves.length === 1) {
                            console.log('[Click] Glowing hole clicked with single move - executing');
                            clearPegDestinationHighlights();
                            hidePegMoveDropdown();
                            dismissCardRulePopup();
                            
                            executeMoveDirectly(matchingMoves[0]);
                            return;
                        } else if (matchingMoves.length > 1) {
                            // Multiple moves to same hole (e.g. FT entry vs perimeter)
                            showHoleMoveDropdown(matchingMoves, event.clientX, event.clientY);
                            return;
                        }
                    }
                    // Accept click if highlighted OR if it's in the legalMoves destinations
                    const isLegalDest = legalMoves.some(m => m.toHoleId === holeId);
                    if (hole.isHighlighted || isLegalDest) {
                        console.log('[Click] Glowing hole clicked - executing move');
                        clearPegDestinationHighlights();
                        dismissCardRulePopup();
                        
                        executeHoleClick(holeId);
                        return;
                    }
                }
            }
        }
    }
    
    // Manual control mode - allow hole-to-hole jumping OR direct jump
    let manualMoveState = {
        active: false,
        pegId: null,
        startHole: null,
        currentHole: null,
        targetHole: null,
        path: [],
        totalSteps: 0,
        stepsTaken: 0,
        allValidMoves: [] // All possible destinations (1 to card value)
    };
    
    function isManualControlMode() {
        return window.gameControlMode === 'manual';
    }
    
    function startManualMoveSequence(moves) {
        if (!moves || moves.length === 0) return;
        
        // All moves should be for the same peg
        const pegId = moves[0].pegId;
        const startHole = moves[0].fromHoleId;
        
        // Find the maximum distance move (final destination)
        const maxMove = moves.reduce((max, m) => m.steps > max.steps ? m : max, moves[0]);
        
        manualMoveState.active = true;
        manualMoveState.pegId = pegId;
        manualMoveState.startHole = startHole;
        manualMoveState.currentHole = startHole;
        manualMoveState.targetHole = maxMove.toHoleId;
        manualMoveState.path = [startHole];
        manualMoveState.totalSteps = maxMove.steps;
        manualMoveState.stepsTaken = 0;
        manualMoveState.allValidMoves = moves;
        
        console.log('[Manual] Started manual sequence:', {
            pegId,
            from: startHole,
            to: maxMove.toHoleId,
            totalSteps: maxMove.steps,
            validMoves: moves.length
        });
    }
    
    function handleManualHoleClick(holeId) {
        if (!manualMoveState.active) return false;
        
        // Find if this hole is a valid destination
        const moveToHole = manualMoveState.allValidMoves.find(m => m.toHoleId === holeId);
        if (!moveToHole) {
            console.warn('[Manual] Clicked hole is not a valid destination:', holeId);
            return false;
        }
        
        console.log('[Manual] Executing move to:', holeId, 'steps:', moveToHole.steps);
        
        // Reset manual state
        manualMoveState.active = false;
        manualMoveState.pegId = null;
        manualMoveState.currentHole = null;
        manualMoveState.targetHole = null;
        manualMoveState.path = [];
        manualMoveState.totalSteps = 0;
        manualMoveState.stepsTaken = 0;
        manualMoveState.allValidMoves = [];
        
        // Execute the move through the game engine (it handles animation)
        executeMoveDirectly(moveToHole);
        return true;
    }
    
    function showPegMoveDropdown(pegId, moves, x, y) {
        selectedPegForDropdown = pegId;
        const dropdown = document.getElementById('peg-move-dropdown');
        const itemsContainer = document.getElementById('dropdown-items');
        
        // Update header with peg number
        const pegNum = getPegNumber(pegId);
        const headerTitle = dropdown.querySelector('.dropdown-title');
        if (headerTitle) {
            headerTitle.textContent = `Peg #${pegNum} - Choose Move`;
        }
        
        // Clear previous items
        itemsContainer.innerHTML = '';
        
        // Generate dropdown items for each move
        moves.forEach((move, index) => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            
            // Determine move type and styling
            let icon = 'ğŸ“';
            let moveName = move.toHoleId;
            let moveSteps = `${move.steps} step${move.steps !== 1 ? 's' : ''}`;
            
            // Friendly name for destination
            const friendly = friendlyHoleName(move.toHoleId);
            
            // Check if this is a cut move
            const cutTarget = findCutTargetAtHole(move.toHoleId);
            if (cutTarget) {
                item.classList.add('cut-move');
                icon = 'âš”ï¸';
                moveName = `Cut at ${friendly}`;
                moveSteps = `Capture ${cutTarget.player.name}'s peg`;
            }
            // Check if FastTrack entry
            else if (move.isFastTrackEntry) {
                item.classList.add('fasttrack-move');
                icon = 'âš¡';
                moveName = 'Take the FastTrack shortcut';
            }
            // Check if leaving FastTrack to perimeter
            else if (move.isLeaveFastTrack) {
                if (move.isForcedFTExit) {
                    icon = 'âš ï¸';
                    moveName = 'Blocked â€” Exit FastTrack';
                } else {
                    icon = 'ğŸ”„';
                    moveName = `Exit FastTrack to ${friendly}`;
                }
            }
            // Check if bullseye/center
            else if (move.toHoleId === 'center') {
                item.classList.add('fasttrack-move');
                icon = 'ğŸ¯';
                moveName = 'Enter the Bullseye';
                moveSteps = 'Safe spot â€” exit with J, Q, or K';
            }
            // Check if safe zone
            else if (move.toHoleId.startsWith('safe-')) {
                item.classList.add('safe-move');
                icon = 'ğŸ›¡ï¸';
                moveName = friendly;
                moveSteps = 'Protected â€” cannot be cut!';
            }
            // Check if winner hole
            else if (move.toHoleId.includes('winner')) {
                item.classList.add('safe-move');
                icon = 'ğŸ†';
                moveName = 'Winner Hole!';
            }
            // Enter from holding
            else if (move.type === 'enter') {
                icon = 'ğŸš€';
                moveName = 'Enter the board';
                moveSteps = 'Bring a peg into play';
            }
            // Home hole
            else if (move.toHoleId.startsWith('home-')) {
                icon = 'ğŸ’';
                moveName = friendly;
            }
            // FastTrack corner (traversing)
            else if (move.toHoleId.startsWith('ft-')) {
                icon = 'â­';
                moveName = friendly;
            }
            // Regular perimeter hole
            else {
                moveName = `Move to ${friendly}`;
            }
            
            item.innerHTML = `
                <span class="move-icon">${icon}</span>
                <div class="move-details">
                    <div class="move-name">${moveName}</div>
                    <div class="move-steps">${moveSteps}</div>
                </div>
            `;
            
            // Add click handler - pass full move object, not just holeId
            // This is important for FastTrack entry where two moves have same holeId
            item.addEventListener('click', () => {
                console.log('ğŸ“ Dropdown click - executing move:', move, 'isFastTrackEntry:', move.isFastTrackEntry);
                hidePegMoveDropdown();
                executeMoveDirectly(move);
            });
            
            itemsContainer.appendChild(item);
        });
        
        // Position dropdown near the click point; on mobile place at bottom center to avoid covering board
        if (window.innerWidth <= 768) {
            dropdown.style.left = '50%';
            dropdown.style.transform = 'translateX(-50%)';
            dropdown.style.bottom = '12px';
            dropdown.style.top = 'auto';
            dropdown.style.maxHeight = '40vh';
            dropdown.style.overflowY = 'auto';
        } else {
            dropdown.style.left = `${Math.min(x, window.innerWidth - 260)}px`;
            dropdown.style.top = `${Math.min(y, window.innerHeight - 300)}px`;
            dropdown.style.transform = '';
            dropdown.style.bottom = 'auto';
            dropdown.style.maxHeight = '';
            dropdown.style.overflowY = '';
        }
        dropdown.classList.add('visible');
    }
    
    function hidePegMoveDropdown() {
        const dropdown = document.getElementById('peg-move-dropdown');
        dropdown.classList.remove('visible');
        selectedPegForDropdown = null;
    }
    
    // Expose to global scope for onclick
    window.hidePegMoveDropdown = hidePegMoveDropdown;
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('peg-move-dropdown');
        if (dropdown && dropdown.classList.contains('visible')) {
            // Check if click is outside dropdown
            if (!dropdown.contains(e.target)) {
                hidePegMoveDropdown();
            }
        }
        
        // Global panel dismiss: close info panels when tapping outside
        // Mom Help Panel
        const momHelp = document.getElementById('mom-help-panel');
        if (momHelp && momHelp.classList.contains('visible') && !momHelp.contains(e.target)) {
            hideMomHelp();
        }
        
        // Rules Modal
        const rulesModal = document.getElementById('rules-modal');
        if (rulesModal && rulesModal.classList.contains('visible')) {
            const rulesContent = rulesModal.firstElementChild;
            if (rulesContent && !rulesContent.contains(e.target)) {
                toggleRulesModal();
            }
        }
        
        // Illegal Move Popup - auto-dismiss on outside tap
        const illegalPopup = document.getElementById('illegal-move-popup');
        if (illegalPopup && illegalPopup.style.display !== 'none' && !illegalPopup.contains(e.target)) {
            hideIllegalMovePopup();
        }
    });
    
    // Close dropdown with Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const dropdown = document.getElementById('peg-move-dropdown');
            if (dropdown && dropdown.classList.contains('visible')) {
                hidePegMoveDropdown();
                e.preventDefault();
            }
        }
    });
    
    // Execute a move by clicking on a hole (called by handleHoleClick or AI)
    function executeHoleClick(holeId) {
        // Allow split mode to proceed even in different game phases
        const inSplitDestPhase = splitMoveState.active && 
            (splitMoveState.phase === 'select_first_dest' || splitMoveState.phase === 'select_second_dest');
        
        if (!inSplitDestPhase && (gameState.phase !== 'play' || legalMoves.length === 0)) return;
        
        // Find ALL moves to this hole (there may be multiple, e.g., FastTrack entry vs regular)
        const movesToHole = legalMoves.filter(m => m.toHoleId === holeId);
        if (movesToHole.length === 0) {
            console.warn('No legal move to hole:', holeId);
            return;
        }
        
        // If multiple moves to same hole, show dropdown to let player choose
        if (movesToHole.length > 1) {
            console.log('ğŸ“ Multiple moves to same hole, showing choice dropdown:', movesToHole);
            // Show dropdown near center of screen
            showHoleMoveDropdown(movesToHole, window.innerWidth / 2, window.innerHeight / 2);
            return;
        }
        
        // Single move - execute directly
        executeMoveDirectly(movesToHole[0]);
    }
    
    // Show dropdown when multiple moves go to same destination (e.g., FastTrack entry options)
    function showHoleMoveDropdown(moves, x, y) {
        const dropdown = document.getElementById('peg-move-dropdown');
        if (!dropdown) return;
        
        const header = dropdown.querySelector('.dropdown-header');
        const itemsContainer = document.getElementById('dropdown-items');
        
        if (!itemsContainer) {
            console.error('dropdown-items container not found!');
            return;
        }
        
        const titleEl = dropdown.querySelector('.dropdown-title');
        if (titleEl) titleEl.textContent = 'ğŸ¯ Choose Move Type';
        itemsContainer.innerHTML = '';
        
        moves.forEach((move) => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            
            let icon = 'ğŸ“';
            let moveName = move.toHoleId;
            let moveDesc = '';
            
            if (move.isFastTrackEntry) {
                icon = 'âš¡';
                moveName = 'Enter FastTrack';
                moveDesc = 'Traverse inner ring';
                item.classList.add('fasttrack-move');
            } else if (move.isLeaveFastTrack && move.isForcedFTExit) {
                icon = 'âš ï¸';
                moveName = 'Blocked â€” Exit FastTrack';
                moveDesc = 'Own peg blocking FT ring';
            } else if (move.isLeaveFastTrack) {
                icon = 'ğŸ”„';
                moveName = 'Leave FastTrack';
                moveDesc = 'Continue on outer perimeter';
            } else if (move.isCenterOption) {
                icon = 'ğŸ¯';
                moveName = 'Enter Bullseye';
                moveDesc = 'Center hole';
                item.classList.add('fasttrack-move');
            } else if (move.toHoleId.startsWith('ft-')) {
                icon = 'â­ï¸';
                moveName = 'Continue on Track';
                moveDesc = 'Stay on perimeter';
            } else {
                moveName = move.toHoleId;
                moveDesc = `${move.steps} steps`;
            }
            
            item.innerHTML = `
                <span class="move-icon">${icon}</span>
                <div class="move-details">
                    <div class="move-name">${moveName}</div>
                    <div class="move-steps">${moveDesc}</div>
                </div>
            `;
            
            item.addEventListener('click', () => {
                console.log('ğŸ“ Hole dropdown click - executing move:', move, 'isFastTrackEntry:', move.isFastTrackEntry);
                hidePegMoveDropdown();
                executeMoveDirectly(move);
            });
            
            itemsContainer.appendChild(item);
        });
        
        dropdown.style.left = `${Math.min(x - 100, window.innerWidth - 220)}px`;
        dropdown.style.top = `${Math.min(y - 50, window.innerHeight - 300)}px`;
        dropdown.classList.add('visible');
    }
    
    // Execute a move directly (called by dropdown or executeHoleClick)
    // This ensures the correct move object is used, including isFastTrackEntry flag
    function executeMoveDirectly(move) {
        if (!move) {
            console.error('ğŸ“ executeMoveDirectly: No move provided!');
            return;
        }
        
        console.log('ğŸ“ executeMoveDirectly called:', move.toHoleId, 'type:', move.type, 'isFastTrackEntry:', move.isFastTrackEntry, 'splitPhase:', splitMoveState?.phase);
        
        // SPLIT MODE: Handle first destination click BEFORE phase check
        // (Split mode continues in 'play' phase but we want to be lenient)
        if (splitMoveState && splitMoveState.active && splitMoveState.phase === 'select_first_dest') {
            executeSplitMoveFirst(move);
            return;
        }
        
        // SPLIT MODE: Handle second destination click
        if (splitMoveState && splitMoveState.active && splitMoveState.phase === 'select_second_dest') {
            executeSplitMoveSecond(move);
            return;
        }
        
        // Phase check for non-split moves
        if (gameState.phase !== 'play') {
            console.error('ğŸ“ executeMoveDirectly: Wrong phase!', gameState.phase, 'expected: play');
            // PHASE RECOVERY: If stuck in 'animating' for too long, force back to 'play' and retry
            if (gameState.phase === 'animating') {
                console.warn('âš ï¸ PHASE RECOVERY: Forcing phase from animating â†’ play');
                gameState.phase = 'play';
                // Retry the move after recovery
                setTimeout(() => executeMoveDirectly(move), 100);
                return;
            }
            // If phase is 'draw', the move came too late â€” skip this call
            if (gameState.phase === 'draw') {
                console.warn('âš ï¸ executeMoveDirectly called during draw phase â€” ignoring stale move');
                return;
            }
            return;
        }
        
        // Execute the move immediately when clicking a highlighted hole
        hideTurnBanner();
        clearHighlights();
        
        // SPECIAL: Joker backward move - show jack-in-the-box celebration!
        if (move.type === 'joker_backward') {
            console.log('ğŸƒ [Joker Backward] Triggering special effects!');
            showJokerBackwardCelebration(move, () => {
                console.log('[executeMoveDirectly] Starting animation for Joker backward move:', move.toHoleId);
                animatePegMove(move, () => {
                    console.log('[executeMoveDirectly] Animation complete, calling gameState.executeMove');
                    gameState.executeMove(move);
                    console.log('[executeMoveDirectly] gameState.executeMove returned, phase is now:', gameState.phase);
                    
                    // BoardManifold: validate landing
                    if (window.BoardManifold && move.pegId) {
                        const peg = (gameState.currentPlayer?.peg || []).find(p => p.id === move.pegId);
                        const actualHole = peg ? peg.holeId : move.toHoleId;
                        const landingResult = BoardManifold.validateLanding(move.pegId, actualHole, move.toHoleId, gameState.currentCard?.rank);
                        if (!landingResult.valid) {
                            console.error(`[BoardManifold] LANDING VIOLATION: ${landingResult.reason}`);
                        } else {
                            console.log(`[BoardManifold] Landing validated: ${move.pegId} â†’ ${actualHole}`);
                        }
                    }
                    cardUI.clearCard();
                    if (window.mobileUI) window.mobileUI.hideFloatingCard();
                });
            });
        } else {
            // Normal move execution
            console.log('[executeMoveDirectly] Starting animation for move:', move.toHoleId);
            animatePegMove(move, () => {
                console.log('[executeMoveDirectly] Animation complete, calling gameState.executeMove');
                
                // Dispatch event for Mom Daemon
                document.dispatchEvent(new CustomEvent('moveMade', { detail: { move } }));
                
                gameState.executeMove(move);
                console.log('[executeMoveDirectly] gameState.executeMove returned, phase is now:', gameState.phase);
                
                // BoardManifold: validate landing â€” guarantee peg is in the correct hole
                if (window.BoardManifold && move.pegId) {
                    const peg = (gameState.currentPlayer?.peg || []).find(p => p.id === move.pegId);
                    const actualHole = peg ? peg.holeId : move.toHoleId;
                    const landingResult = BoardManifold.validateLanding(move.pegId, actualHole, move.toHoleId, gameState.currentCard?.rank);
                    if (!landingResult.valid) {
                        console.error(`[BoardManifold] LANDING VIOLATION: ${landingResult.reason}`);
                    } else {
                        console.log(`[BoardManifold] Landing validated: ${move.pegId} â†’ ${actualHole}`);
                    }
                }
                cardUI.clearCard();
                if (window.mobileUI) window.mobileUI.hideFloatingCard();
            });
        }
    }
    // Expose executeMoveDirectly and executeHoleClick for external modules (ask_mom.js)
    window.executeMoveDirectly = executeMoveDirectly;
    window.executeHoleClick = executeHoleClick;
    window.clearHighlights = clearHighlights;
    window.getPegNumber = getPegNumber;
    window.getTrackDistance = getTrackDistance;
    
    function executeSplitMoveFirst(move) {
        console.log('[Split] First move:', move, 'Steps used:', move.steps);
        
        // Update split state
        splitMoveState.usedMoves = move.steps;
        splitMoveState.remainingMoves = 7 - move.steps;
        splitMoveState.firstMovePeg = move.pegId;
        
        // Track whether the first sub-move was an FT traversal
        const peg = gameState.currentPlayer.peg.find(p => p.id === move.pegId);
        const firstMoveIsFT = (peg && peg.onFasttrack) || move.isFastTrackEntry === true;
        splitMoveState.firstMoveWasFT = firstMoveIsFT;
        
        // Clear highlights and indicators
        hideTurnBanner();
        clearHighlights();
        hideSplitMoveIndicator();
        
        // Execute the move without ending turn
        const cutPeg = gameState.executeMoveWithoutEndingTurn ? 
            gameState.executeMoveWithoutEndingTurn(move) : 
            null;
        
        // If all 7 moves used on first peg, end turn after animation
        if (splitMoveState.remainingMoves === 0) {
            console.log('[Split] All 7 moves used on first peg - ending turn');
            
            animatePegMove(move, () => {
                if (cutPeg) {
                    animateCut(cutPeg);
                }
                
                // Reset split state and end turn
                resetSplitMoveState();
                cardUI.clearCard();
                if (window.mobileUI) window.mobileUI.hideFloatingCard();
                gameState.endTurn();
            });
            return;
        }
        
        // Animate the first move, then transition to second peg selection
        animatePegMove(move, () => {
            if (cutPeg) {
                animateCut(cutPeg);
            }
            
            // Transition to second peg selection
            transitionToSecondPegSelection();
        });
    }
    
    function transitionToSecondPegSelection() {
        const player = gameState.currentPlayer;
        const remaining = splitMoveState.remainingMoves;
        
        console.log('[Split] Transitioning to second peg selection. Remaining moves:', remaining);
        
        // Find all active pegs that can be selected for second move (not the first peg)
        const selectablePegs = [];
        
        for (const peg of player.peg) {
            console.log('[Split] Checking peg', peg.id, 'at', peg.holeId, 'holeType:', peg.holeType);
            
            // Skip holding pegs
            if (peg.holeType === 'holding') {
                console.log('[Split] Skipping peg', peg.id, '- in holding');
                continue;
            }
            
            // Can't move same peg twice in a split
            if (peg.id === splitMoveState.firstMovePeg) {
                console.log('[Split] Skipping peg', peg.id, '- already moved in first part of split');
                continue;
            }
            
            // Skip completed circuit pegs
            if (peg.completedCircuit) {
                console.log('[Split] Skipping peg', peg.id, '- completed circuit');
                continue;
            }
            
            // Skip bullseye pegs
            if (peg.inBullseye || peg.holeType === 'bullseye') {
                console.log('[Split] Skipping peg', peg.id, '- in bullseye');
                continue;
            }
            
            // Check if this peg has valid moves with remaining steps
            console.log('[Split] Calculating moves for peg', peg.id, 'with', remaining, 'steps');
            const testMoves = calculateMovesForPegRange(peg, remaining, remaining);
            console.log('[Split] Peg', peg.id, 'has', testMoves.length, 'valid moves for', remaining, 'steps');
            if (testMoves.length > 0) {
                selectablePegs.push(peg.id);
            }
        }
        
        if (selectablePegs.length === 0) {
            // No second moves available - end split and turn
            console.log('[Split] No pegs can move remaining ' + remaining + ' spaces - ending turn');
            cardUI.showMessage('No peg can move ' + remaining + ' spaces', 2000);
            setTimeout(() => {
                resetSplitMoveState();
                cardUI.clearCard();
                if (window.mobileUI) window.mobileUI.hideFloatingCard();
                gameState.endTurn();
            }, 2000);
            return;
        }
        
        console.log('[Split] Found ' + selectablePegs.length + ' pegs that can move ' + remaining + ' spaces:', selectablePegs);
        
        // Enter second peg selection phase
        splitMoveState.phase = 'select_second_peg';
        splitMoveState.selectablePegs = selectablePegs;
        
        // Highlight selectable pegs and show their numbers
        highlightSelectablePegsForSplit(selectablePegs);
        showPegNumbers(selectablePegs);
        
        // Re-add click listener (may have been removed by previous operations)
        addHoleClickListeners();
        
        // Build peg list for message
        const pegList = selectablePegs.map(id => `#${getPegNumber(id)}`).join(', ');
        
        // Show instruction with peg numbers
        showSplitMoveIndicator(`Tap peg (${pegList}) for ${remaining}`, remaining);
        
        // For AI, auto-select using planned second move or best available
        if (isAIPlayer(gameState.currentPlayerIndex)) {
            setTimeout(() => {
                const planned = splitMoveState.aiPlannedSecondMove;
                if (planned && selectablePegs.includes(planned.pegId)) {
                    // Use the pre-planned second move
                    console.log(`ğŸ¤– [AI Split] Using planned 2nd move: ${planned.pegId}â†’${planned.toHoleId}`);
                    splitMoveState.selectedPeg = planned.pegId;
                    splitMoveState.phase = 'select_second_dest';
                    clearSplitPegHighlights();
                    hidePegNumbers();
                    legalMoves = [planned];
                    clearHighlights();
                    executeMoveDirectly(planned);
                } else {
                    // Fallback: pick first available peg
                    handleSplitPegClick(selectablePegs[0]);
                }
            }, AI_CONFIG.thinkingDelay || 500);
        }
    }
    
    function executeSplitMoveSecond(move) {
        console.log('[Split] Second move:', move);
        
        // Clear all states and indicators
        hideTurnBanner();
        clearHighlights();
        clearSplitPegHighlights();
        hideSplitMoveIndicator();
        hidePegNumbers();
        
        // Execute the move without ending turn (to handle cuts properly)
        const cutPeg = gameState.executeMoveWithoutEndingTurn ? 
            gameState.executeMoveWithoutEndingTurn(move) : 
            null;
        
        // Animate and execute second move
        animatePegMove(move, () => {
            if (cutPeg) {
                animateCut(cutPeg);
            }
            
            // Reset split state and end turn
            resetSplitMoveState();
            cardUI.clearCard();
            if (window.mobileUI) window.mobileUI.hideFloatingCard();
            gameState.endTurn();
        });
    }
    
    // Phase recovery watchdog â€” detects stuck animations and forces completion
    let _animationWatchdogTimer = null;
    function startAnimationWatchdog(onComplete, move) {
        clearAnimationWatchdog();
        _animationWatchdogTimer = setTimeout(() => {
            _animationWatchdogTimer = null;
            // If phase is still 'play' and no highlights visible, the animation callback never fired
            if (gameState && gameState.phase === 'play' && legalMoves.length === 0) {
                console.error('â° WATCHDOG: Animation callback never fired! Forcing completion for move:', move?.toHoleId);
                if (onComplete) {
                    try { onComplete(); } catch(e) { console.error('â° WATCHDOG onComplete error:', e); }
                }
            }
            // If stuck in 'animating' phase (executeMove started but endTurn never completed)
            if (gameState && gameState.phase === 'animating') {
                console.error('â° WATCHDOG: Stuck in animating phase! Forcing endTurn');
                resetSplitMoveState();
                gameState.phase = 'play';
                gameState.endTurn();
            }
        }, 15000); // 15 second safety net
    }
    function clearAnimationWatchdog() {
        if (_animationWatchdogTimer) {
            clearTimeout(_animationWatchdogTimer);
            _animationWatchdogTimer = null;
        }
    }

    function animatePegMove(move, onComplete) {
        // Dismiss card rule popup when move begins
        dismissCardRulePopup();
        
        // Turn timer removed
        
        // Dispatch animation start event for mobile UI auto-hide
        if (typeof MobileUI !== 'undefined' && MobileUI.dispatchAnimationStart) {
            MobileUI.dispatchAnimationStart();
        }
        
        // Start watchdog timer â€” if animation callback doesn't fire within 15s, force it
        const wrappedComplete = () => {
            _pegMoveInProgress = false;
            clearAnimationWatchdog();
            // Dispatch animation end event for mobile UI
            if (typeof MobileUI !== 'undefined' && MobileUI.dispatchAnimationEnd) {
                MobileUI.dispatchAnimationEnd();
            }
            if (onComplete) onComplete();
        };
        startAnimationWatchdog(onComplete, move);
        
        // Hide mobile UI elements during animation
        if (window.mobileUI) {
            window.mobileUI.hideMoves();
            window.mobileUI.hideCardPopup();
            // Keep floating card visible but will hide after move completes
        }
        
        // Show move announcement for all players
        const player = gameState.currentPlayer;
        const playerName = player.name || `Player ${gameState.currentPlayerIndex + 1}`;
        const card = gameState.currentCard;
        const spaces = move.steps || (card ? card.movement : '?');
        const direction = card ? card.direction : null;
        showMoveAnnouncement(playerName, spaces, direction);
        
        // Find the peg mesh
        const pegData = player.peg.find(p => p.id === move.pegId);
        const peg = pegRegistry.get(move.pegId);
        
        if (!peg || !peg.mesh) {
            console.warn('Peg mesh not found for:', move.pegId);
            clearAnimationWatchdog();
            if (onComplete) onComplete();
            return;
        }
        
        // Get the path to traverse (array of hole IDs)
        const path = move.path || [move.fromHoleId, move.toHoleId];
        console.log(`ğŸ›¤ï¸ Path traversal: ${path.join(' â†’ ')}`);
        
        // â”€â”€ CAMERA FOCUS FIRST â”€â”€
        // Focus camera on the peg's starting position before any movement begins.
        // Once the camera arrives, THEN start the hop animation.
        const pegStartX = peg.mesh.position.x;
        const pegStartZ = peg.mesh.position.z;
        
        function beginHopsAfterFocus() {
            _pegMoveInProgress = true;
            
            // If path only has starting position or just 1-2 holes, do direct animation
            if (path.length <= 2) {
                animatePegDirect(peg, move, wrappedComplete);
                return;
            }
            
            // Animate through each hole in the path (skip first which is starting position)
            let currentHopIndex = 1;
            const hopDuration = 200; // ms per hop - fast bouncy hops
            const pegHeight = 10; // Consistent peg height above holes
            const hopArc = 12; // Arc height during hop
            const totalHops = path.length - 1;  // Total steps for sound progressions
            
            function animateNextHop() {
                if (currentHopIndex >= path.length) {
                    // Animation complete - ensure final position
                    const finalHole = holeRegistry.get(move.toHoleId);
                    if (finalHole) {
                        const fx = finalHole.position ? finalHole.position.x : finalHole.x;
                        const fz = finalHole.position ? finalHole.position.z : finalHole.z;
                        peg.mesh.position.set(fx, pegHeight, fz);
                    }
                    peg.currentHole = move.toHoleId;
                    hideAIThinking();
                    if (wrappedComplete) wrappedComplete();
                    return;
                }
                
                const targetHoleId = path[currentHopIndex];
                const targetHole = holeRegistry.get(targetHoleId);
                
                if (!targetHole) {
                    console.warn('Hop target hole not found:', targetHoleId);
                    currentHopIndex++;
                    animateNextHop();
                    return;
                }
                
                const targetX = targetHole.position ? targetHole.position.x : targetHole.x;
                const targetZ = targetHole.position ? targetHole.position.z : targetHole.z;
                
                // Capture start position for this hop
                const startX = peg.mesh.position.x;
                const startZ = peg.mesh.position.z;
                const hopStartTime = Date.now();
                
                // Simple bouncy hop animation
                function animateHop() {
                    const elapsed = Date.now() - hopStartTime;
                    const progress = Math.min(elapsed / hopDuration, 1);
                    
                    if (progress >= 1) {
                        // Land at target hole
                        peg.mesh.position.set(targetX, pegHeight, targetZ);
                        
                        // Play step sound when landing on each hole!
                        if (window.GameSFX) {
                            GameSFX.playStep(currentHopIndex - 1, totalHops);
                        }
                        
                        currentHopIndex++;
                        // Immediately start next hop
                        animateNextHop();
                        return;
                    }
                    
                    // Linear interpolation for X/Z movement
                    const t = progress;
                    const x = startX + (targetX - startX) * t;
                    const z = startZ + (targetZ - startZ) * t;
                    
                    // Parabolic arc for Y (hop up and down)
                    const hopProgress = Math.sin(progress * Math.PI);
                    const y = pegHeight + hopProgress * hopArc;
                    
                    peg.mesh.position.set(x, y, z);
                    
                    // Camera follows peg every frame during movement
                    updateCameraForPegMove(x, z);
                    
                    requestAnimationFrame(animateHop);
                }
                
                animateHop();
            }
            
            animateNextHop();
        }
        
        // Focus camera on the peg BEFORE movement starts
        if (!userOverrideCamera && !userIsInteracting && currentCameraView !== 'manual') {
            const camHeight = 250;
            const camOffset = 120;
            smoothCameraTransition(
                { x: pegStartX * 0.6, y: camHeight, z: pegStartZ * 0.6 + camOffset },
                { x: pegStartX, y: 0, z: pegStartZ },
                1800,
                beginHopsAfterFocus
            );
        } else {
            // Manual/override mode â€” start immediately
            _pegMoveInProgress = true;
            beginHopsAfterFocus();
        }
    }
    
    // Direct animation (no path traversal - for enter moves etc)
    function animatePegDirect(peg, move, onComplete) {
        console.log('[animatePegDirect] Starting direct animation for:', move.toHoleId);
        const destHole = holeRegistry.get(move.toHoleId);
        if (!destHole) {
            console.warn('[animatePegDirect] Destination hole not found:', move.toHoleId);
            if (onComplete) onComplete();
            return;
        }
        
        // Get destination coordinates
        const destX = destHole.position ? destHole.position.x : destHole.x;
        const destZ = destHole.position ? destHole.position.z : destHole.z;
        const pegHeight = 10;
        const hopArc = 20; // Slightly higher arc for direct moves
        
        // Capture start position
        const startX = peg.mesh.position.x;
        const startZ = peg.mesh.position.z;
        
        const duration = 400; // Quick direct hop
        const startTime = Date.now();
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            if (progress >= 1) {
                console.log('[animatePegDirect] Animation complete, calling onComplete');
                peg.mesh.position.set(destX, pegHeight, destZ);
                peg.currentHole = move.toHoleId;
                
                // Update camera (never in manual mode)
                if (!userOverrideCamera && currentCameraView !== 'manual') {
                    controls.target.set(destX, 0, destZ);
                    camera.lookAt(controls.target);
                }
                
                hideAIThinking();
                if (onComplete) {
                    console.log('[animatePegDirect] Calling onComplete callback NOW');
                    onComplete();
                } else {
                    console.warn('[animatePegDirect] No onComplete callback provided!');
                }
                return;
            }
            
            // Linear interpolation for X/Z
            const t = progress;
            const x = startX + (destX - startX) * t;
            const z = startZ + (destZ - startZ) * t;
            
            // Parabolic arc for Y
            const hopProgress = Math.sin(progress * Math.PI);
            const y = pegHeight + hopProgress * hopArc;
            
            peg.mesh.position.set(x, y, z);
            
            // Update camera for ground/chase modes
            if (typeof updateCameraForPegMove === 'function') {
                updateCameraForPegMove(x, z);
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();
    }
    
    // Helper function to instantly update peg position (for analyzer corrections)
    function updatePegPosition(pegId, toHoleId) {
        const peg = pegRegistry.get(pegId);
        const targetHole = holeRegistry.get(toHoleId);
        
        if (!peg || !peg.mesh || !targetHole) {
            console.warn('ğŸ”§ updatePegPosition: Could not find peg or hole', pegId, toHoleId);
            return false;
        }
        
        const x = targetHole.position ? targetHole.position.x : targetHole.x;
        const z = targetHole.position ? targetHole.position.z : targetHole.z;
        const y = LINE_HEIGHT + 10;  // Standard peg height
        
        peg.mesh.position.set(x, y, z);
        peg.currentHole = toHoleId;
        
        console.log(`ğŸ”§ updatePegPosition: Moved ${pegId} to ${toHoleId} at (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
        return true;
    }
    
    // Expose updatePegPosition globally for analyzer corrections
    window.updatePegPosition = updatePegPosition;
    
    function animateCut(cutPegInfo, moveInfo) {
        // ============================================================
        // CINEMATIC VANQUISH SEQUENCE
        // 1. Camera smoothly focuses on vanquished peg
        // 2. Sad wail plays as peg slowly arcs to holding area
        // 3. Camera follows the peg all the way to holding
        // 4. Pause at landing so player sees the peg arrive home
        // 5. Camera smoothly pans back to the triumphant attacker peg
        // 6. Attacker peg does a victory dance with jingle
        // ============================================================
        console.log('ğŸ¬ Cinematic vanquish for:', cutPegInfo);
        
        if (!cutPegInfo || !cutPegInfo.peg || !cutPegInfo.player) {
            console.warn('Invalid cut peg info');
            return;
        }
        
        const victimPlayer = cutPegInfo.player;
        const victimPeg = cutPegInfo.peg;
        const pegMesh = pegRegistry.get(victimPeg.id);
        
        if (!pegMesh || !pegMesh.mesh) {
            console.warn('Cut peg mesh not found:', victimPeg.id);
            return;
        }
        
        // Game engine already set victimPeg.holeId to the target holding hole
        const targetHoleId = victimPeg.holeId;
        const targetHole = holeRegistry.get(targetHoleId);
        
        if (!targetHole) {
            console.error('Target hole not found for cut peg animation:', targetHoleId);
            return;
        }
        
        // Get target position
        const targetX = targetHole.position ? targetHole.position.x : targetHole.x;
        const targetZ = targetHole.position ? targetHole.position.z : targetHole.z;
        
        // === PHASE 1: Focus camera on victim, then arc to holding ===
        const startPos = pegMesh.mesh.position.clone();
        const endPos = new THREE.Vector3(targetX, LINE_HEIGHT + 10, targetZ);
        
        // Calculate distance for proportional arc height
        const dist = startPos.distanceTo(endPos);
        const maxArcHeight = Math.max(LINE_HEIGHT + 80, dist * 0.6);
        
        const isManual = currentCameraView === 'manual';
        
        // Play the sad vanquish sound
        if (window.GameSFX) {
            GameSFX.playVanquishSad();
        }
        
        // First: smooth camera pan to victim peg, THEN start the arc
        if (!isManual && !userIsInteracting) {
            const camOffset = 80;
            smoothCameraTransition(
                { x: startPos.x + camOffset * 0.5, y: maxArcHeight + 60, z: startPos.z + camOffset },
                { x: startPos.x, y: LINE_HEIGHT + 10, z: startPos.z },
                1200,
                beginCinematicArc
            );
        } else {
            beginCinematicArc();
        }
        
        function beginCinematicArc() {
            const arcDuration = 2800; // Slow dramatic arc
            const arcStartTime = Date.now();
            
            function animateCinematicArc() {
                const elapsed = Date.now() - arcStartTime;
                const progress = Math.min(elapsed / arcDuration, 1);
                
                // Ultra-smooth ease-in-out (slow start, slow finish, dramatic middle)
                const t = -(Math.cos(Math.PI * progress) - 1) / 2;
                
                // Horizontal interpolation
                const x = startPos.x + (endPos.x - startPos.x) * t;
                const z = startPos.z + (endPos.z - startPos.z) * t;
                
                // Dramatic parabolic arc - high peak in the middle
                const arcT = Math.sin(progress * Math.PI);
                const baseY = startPos.y + (endPos.y - startPos.y) * t;
                const y = baseY + arcT * maxArcHeight;
                
                pegMesh.mesh.position.set(x, y, z);
                
                // Slow mournful spin
                pegMesh.mesh.rotation.y += 0.04;
                
                // Slight wobble for drama
                pegMesh.mesh.rotation.x = Math.sin(progress * Math.PI * 3) * 0.15;
                pegMesh.mesh.rotation.z = Math.cos(progress * Math.PI * 2) * 0.1;
                
                // Camera smoothly follows the arcing peg all the way to holding
                if (!isManual && !userIsInteracting) {
                    controls.target.x += (x - controls.target.x) * 0.025;
                    controls.target.y += (y - controls.target.y) * 0.025;
                    controls.target.z += (z - controls.target.z) * 0.025;
                    
                    // Gently drift camera position to keep a good viewing angle
                    const desiredCamX = x + 80 * 0.5;
                    const desiredCamY = Math.max(y + 60, maxArcHeight + 60);
                    const desiredCamZ = z + 80;
                    camera.position.x += (desiredCamX - camera.position.x) * 0.015;
                    camera.position.y += (desiredCamY - camera.position.y) * 0.015;
                    camera.position.z += (desiredCamZ - camera.position.z) * 0.015;
                    
                    camera.lookAt(controls.target);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animateCinematicArc);
                } else {
                    // === PHASE 2: Landing impact ===
                    pegMesh.mesh.rotation.set(0, 0, 0);
                    pegMesh.mesh.position.copy(endPos);
                    
                    // Landing thump
                    if (window.GameSFX) {
                        GameSFX._playImpact(GameSFX.audioContext.currentTime, 0.4);
                    }
                    
                    console.log(`ğŸ˜¢ Peg ${victimPeg.id} vanquished to ${targetHoleId}`);
                    
                    // === PHASE 3: Pause at landing so player sees peg in holding ===
                    // Focus camera on the landing spot for a beat
                    if (!isManual && !userIsInteracting) {
                        smoothCameraTransition(
                            { x: endPos.x + 40, y: LINE_HEIGHT + 100, z: endPos.z + 60 },
                            { x: endPos.x, y: LINE_HEIGHT + 10, z: endPos.z },
                            1200
                        );
                    }
                    
                    // Hold for 1.2s so the player sees the peg in holding, then transition
                    setTimeout(() => {
                        performVictoryDance(moveInfo);
                    }, 1200);
                }
            }
            
            animateCinematicArc();
        }
        
        // === VICTORY DANCE SUB-FUNCTION ===
        function performVictoryDance(moveInfo) {
            // Find the attacker peg
            let attackerPegMesh = null;
            let attackerPegPos = null;
            
            // Try to find via moveInfo first
            if (moveInfo && moveInfo.pegId) {
                const reg = pegRegistry.get(moveInfo.pegId);
                if (reg && reg.mesh) {
                    attackerPegMesh = reg.mesh;
                    attackerPegPos = reg.mesh.position.clone();
                }
            }
            
            // Fallback: find via gameState.currentPlayer â€” pick peg closest to where victim was
            if (!attackerPegMesh && gameState && gameState.currentPlayer) {
                const pegs = gameState.currentPlayer.peg || [];
                let bestDist = Infinity;
                for (const p of pegs) {
                    const reg = pegRegistry.get(p.id);
                    if (reg && reg.mesh) {
                        const d = reg.mesh.position.distanceTo(startPos);
                        if (d < bestDist) {
                            bestDist = d;
                            attackerPegMesh = reg.mesh;
                            attackerPegPos = reg.mesh.position.clone();
                        }
                    }
                }
            }
            
            if (!attackerPegMesh) {
                console.log('No attacker peg found for victory dance');
                return;
            }
            
            // === PHASE 4: Smooth pan to attacker peg ===
            if (!isManual) {
                smoothCameraTransition(
                    { x: attackerPegPos.x + 50, y: LINE_HEIGHT + 80, z: attackerPegPos.z + 60 },
                    { x: attackerPegPos.x, y: LINE_HEIGHT + 10, z: attackerPegPos.z },
                    1800,
                    startDance
                );
            } else {
                startDance();
            }
            
            function startDance() {
                // Play victory jingle
                if (window.GameSFX) {
                    GameSFX.playVanquishDance();
                }
                
                // === PHASE 5: Victory dance animation ===
                const danceStart = Date.now();
                const danceDuration = 1200;
                const bounceBaseY = attackerPegPos.y;
                const bounceHeight = 15;
                const numBounces = 4;
                
                function animateDance() {
                    const elapsed = Date.now() - danceStart;
                    const progress = Math.min(elapsed / danceDuration, 1);
                    
                    // Bouncing
                    const bouncePhase = progress * numBounces * Math.PI * 2;
                    const bounceDecay = 1 - progress; // Bounces get smaller
                    const yOffset = Math.abs(Math.sin(bouncePhase)) * bounceHeight * bounceDecay;
                    attackerPegMesh.position.y = bounceBaseY + yOffset;
                    
                    // Spin celebration
                    attackerPegMesh.rotation.y += 0.15 * bounceDecay;
                    
                    // Slight scale pulse for flair
                    const scalePulse = 1 + Math.sin(bouncePhase) * 0.08 * bounceDecay;
                    attackerPegMesh.scale.set(scalePulse, scalePulse, scalePulse);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateDance);
                    } else {
                        // Reset to normal
                        attackerPegMesh.rotation.y = 0;
                        attackerPegMesh.position.y = bounceBaseY;
                        attackerPegMesh.scale.set(1, 1, 1);
                        console.log('ğŸ’ƒ Victory dance complete!');
                    }
                }
                
                animateDance();
            }
        }
    }
    
    // ============================================================
    // LAUNCH GAME HANDLER
    // Called when a game session is ready to start
    // ============================================================
    
    window.launchGame = function(session) {
        console.log('Launching game:', session);
        
        // Hide auth and lobby
        document.getElementById('auth-container').style.display = 'none';
        document.getElementById('lobby-container').style.display = 'none';
        
        // Start game with player count
        const playerCount = session.playerOrder ? session.playerOrder.length : 4;
        initGame(playerCount);
        
        // Update player panels with session players
        if (session.playerOrder && typeof updatePlayerPanelsFromSession === 'function') {
            updatePlayerPanelsFromSession(session);
        }
    };
    
    // ============================================================
    // INITIALIZATION FLOW - DEV MODE: Skip auth, play with AI
    // ============================================================
    
    // AI_CONFIG is defined at the top of this script block
    
    function isAIPlayer(playerIndex) {
        // First check gameState for explicit isAI setting (from session/multiplayer)
        // This takes priority over AI_CONFIG defaults
        if (gameState && gameState.players[playerIndex]) {
            const player = gameState.players[playerIndex];
            // If isAI is explicitly set (true or false), use that value
            if (typeof player.isAI === 'boolean') {
                return player.isAI;
            }
            // If isHuman is explicitly true, they're not AI
            if (player.isHuman === true || player.isLocal === true) {
                return false;
            }
        }
        // Fall back to AI_CONFIG for initial AI players (solo play mode)
        if (AI_CONFIG.enabled && AI_CONFIG.players.includes(playerIndex)) {
            return true;
        }
        return false;
    }
    window.isAIPlayer = isAIPlayer;
    
    // Show Joker backward move celebration - jack-in-the-box joker pops out!
    function showJokerBackwardCelebration(move, onComplete) {
        console.log('ğŸƒ [Joker Celebration] Starting jack-in-the-box animation!');
        
        // Play the special Joker backward sound effect
        if (window.GameSFX) {
            GameSFX.playJokerBackward();
        }
        
        // Create the celebration overlay
        const overlay = document.createElement('div');
        overlay.id = 'joker-celebration-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        `;
        
        // Jack-in-the-box container
        const jackBox = document.createElement('div');
        jackBox.style.cssText = `
            font-size: 120px;
            animation: popOut 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform-origin: bottom center;
        `;
        jackBox.textContent = 'ğŸƒ';
        
        // Fanfare text
        const fanfare = document.createElement('div');
        fanfare.style.cssText = `
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5);
            margin-top: 20px;
            animation: bounce 0.6s ease-in-out infinite alternate;
        `;
        fanfare.textContent = 'ğŸª JOKER SURPRISE! ğŸª';
        
        // Subtitle
        const subtitle = document.createElement('div');
        subtitle.style.cssText = `
            font-size: 24px;
            color: #FFF;
            margin-top: 10px;
            text-align: center;
        `;
        subtitle.textContent = 'Backward Cut - Opponent Sent Home!';
        
        overlay.appendChild(jackBox);
        overlay.appendChild(fanfare);
        overlay.appendChild(subtitle);
        document.body.appendChild(overlay);
        
        // Add CSS animations
        if (!document.getElementById('joker-celebration-styles')) {
            const style = document.createElement('style');
            style.id = 'joker-celebration-styles';
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes popOut {
                    0% { transform: scale(0) translateY(100px); opacity: 0; }
                    50% { transform: scale(1.2) translateY(-20px); }
                    100% { transform: scale(1) translateY(0); opacity: 1; }
                }
                @keyframes bounce {
                    from { transform: translateY(0); }
                    to { transform: translateY(-10px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Remove overlay after 2 seconds and proceed
        setTimeout(() => {
            overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
                if (onComplete) onComplete();
            }, 300);
        }, 2000);
    }
    
    function showMoveAnnouncement(playerName, spaces, direction) {
        const indicator = document.getElementById('ai-thinking');
        const nameEl = document.getElementById('ai-name');
        const infoEl = document.getElementById('move-info');
        if (indicator && nameEl && infoEl) {
            nameEl.textContent = playerName || 'Player';
            if (direction === 'backward') {
                infoEl.textContent = `moving ${spaces} back`;
            } else {
                infoEl.textContent = `moving ${spaces} space${spaces !== 1 ? 's' : ''}`;
            }
            indicator.classList.add('active');
        }
    }
    
    function showAIThinking(playerName) {
        showMoveAnnouncement(playerName, '?', null);
    }
    
    function hideAIThinking() {
        const indicator = document.getElementById('ai-thinking');
        if (indicator) {
            indicator.classList.remove('active');
        }
    }
    
    // ============================================================
    // TURN ACTION BANNER SYSTEM
    // ============================================================
    
    let pendingMoveSelection = null;
    
    // Show turn banner using CardUI's integrated action banner
    function showTurnBanner(playerName, playerColor, message) {
        if (cardUI) {
            cardUI.showActionBanner(`${playerName}: ${message}`, 'default');
        }
    }
    
    // â”€â”€ "DRAW AGAIN!" popup â€” shown immediately when a peg lands on an extra-turn card â”€â”€
    function showDrawAgainPopup() {
        // Remove any existing popup
        const old = document.getElementById('draw-again-popup');
        if (old) old.remove();
        
        const el = document.createElement('div');
        el.id = 'draw-again-popup';
        el.innerHTML = 'ğŸƒ DRAW AGAIN!';
        Object.assign(el.style, {
            position: 'fixed',
            top: '32%',
            left: '50%',
            transform: 'translate(-50%, -50%) scale(0.6)',
            zIndex: '20002',
            pointerEvents: 'none',
            fontSize: '38px',
            fontWeight: '900',
            fontFamily: '"Segoe UI", system-ui, sans-serif',
            color: '#fff',
            textShadow: '0 0 20px rgba(255,215,0,0.9), 0 2px 8px rgba(0,0,0,0.7)',
            background: 'linear-gradient(135deg, rgba(255,180,0,0.92), rgba(255,120,0,0.92))',
            padding: '14px 36px',
            borderRadius: '16px',
            border: '3px solid rgba(255,255,255,0.5)',
            boxShadow: '0 8px 40px rgba(255,165,0,0.5), 0 0 0 6px rgba(255,200,0,0.25)',
            opacity: '0',
            transition: 'none'
        });
        document.body.appendChild(el);
        
        // Animate in
        requestAnimationFrame(() => {
            el.style.transition = 'transform 0.35s cubic-bezier(0.18,1.2,0.4,1), opacity 0.2s ease-out';
            el.style.opacity = '1';
            el.style.transform = 'translate(-50%, -50%) scale(1)';
        });
        
        // Fade out after 2.5s
        setTimeout(() => {
            el.style.transition = 'opacity 0.6s ease-in, transform 0.6s ease-in';
            el.style.opacity = '0';
            el.style.transform = 'translate(-50%, -60%) scale(0.9)';
            setTimeout(() => el.remove(), 700);
        }, 2500);
    }
    
    function showCardDrawnBanner(playerName, playerColor, cardValue, hasMultipleMoves) {
        if (cardUI && hasMultipleMoves) {
            cardUI.showActionBanner(`Select a flashing hole to move to`, 'select');
        }
    }

    // ============================================================
    // CARD RULE POPUP â€” shows card + brief rule on draw
    // ============================================================

    const CARD_RULES = {
        'A':     { icon: 'ğŸ…°ï¸', rule: 'Enter a peg OR hop 1. Draw again.' },
        'JOKER': { icon: 'ğŸƒ', rule: 'Enter a peg OR hop 1. Draw again.' },
        '2':     { icon: '2ï¸âƒ£',  rule: 'Hop 2 forward.' },
        '3':     { icon: '3ï¸âƒ£',  rule: 'Hop 3 forward.' },
        '4':     { icon: '4ï¸âƒ£',  rule: 'Hop 4 BACKWARD. FT pegs must exit.' },
        '5':     { icon: '5ï¸âƒ£',  rule: 'Hop 5 forward.' },
        '6':     { icon: '6ï¸âƒ£',  rule: 'Enter a peg OR hop 6. Draw again.' },
        '7':     { icon: '7ï¸âƒ£',  rule: 'WILD: Move any token 1-7 spaces.' },
        '8':     { icon: '8ï¸âƒ£',  rule: 'Hop 8 forward.' },
        '9':     { icon: '9ï¸âƒ£',  rule: 'Hop 9 forward.' },
        '10':    { icon: 'ğŸ”Ÿ', rule: 'Hop 10 forward.' },
        'J':     { icon: 'ğŸ¤´', rule: 'Hop 1 + draw again + exit bullseye.' },
        'Q':     { icon: 'ğŸ‘¸', rule: 'Hop 1 + draw again + exit bullseye.' },
        'K':     { icon: 'ğŸ‘‘', rule: 'Hop 1 + draw again + exit bullseye.' },
    };

    // Inject popup CSS once
    (function injectCardPopupCSS() {
        if (document.getElementById('card-rule-popup-css')) return;
        const s = document.createElement('style');
        s.id = 'card-rule-popup-css';
        s.textContent = `
            @keyframes cardPopIn {
                0%   { opacity:0; transform:translate(-50%,-50%) scale(0.7); }
                15%  { opacity:1; transform:translate(-50%,-50%) scale(1.05); }
                25%  { transform:translate(-50%,-50%) scale(1); }
                80%  { opacity:1; transform:translate(-50%,-50%) scale(1); }
                100% { opacity:0; transform:translate(-50%,-50%) scale(0.95); }
            }
            #card-rule-popup {
                position: fixed;
                top: 38%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 20001;
                pointer-events: none;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 6px;
                animation: cardPopIn 3s ease-in-out forwards;
            }
            #card-rule-popup .crp-card {
                width: 80px; height: 112px;
                background: #fff;
                border-radius: 10px;
                display: flex; flex-direction: column;
                align-items: center; justify-content: center;
                font-size: 32px; font-weight: 800;
                box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 0 3px rgba(255,255,255,0.15);
                position: relative;
                color: #222;
            }
            #card-rule-popup .crp-card.red { color: #d32f2f; }
            #card-rule-popup .crp-card .crp-suit {
                font-size: 16px; margin-top: 2px;
            }
            #card-rule-popup .crp-rule {
                background: rgba(0,0,0,0.88);
                color: #fff;
                font-size: 15px; font-weight: 600;
                padding: 8px 18px;
                border-radius: 8px;
                text-align: center;
                max-width: 300px;
                line-height: 1.3;
                border: 1px solid rgba(255,255,255,0.15);
                text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            }
            #card-rule-popup .crp-hint {
                font-size: 12px;
                color: rgba(255,255,255,0.6);
                font-weight: 400;
            }
            @media (max-width: 768px) {
                #card-rule-popup .crp-card { width: 64px; height: 90px; font-size: 26px; }
                #card-rule-popup .crp-rule { font-size: 13px; padding: 6px 14px; max-width: 260px; }
            }
        `;
        document.head.appendChild(s);
    })();

    // â”€â”€ No Legal Moves Popup (human players only) â”€â”€
    (function injectNoMovesCSS() {
        if (document.getElementById('no-moves-popup-css')) return;
        const s = document.createElement('style');
        s.id = 'no-moves-popup-css';
        s.textContent = `
            @keyframes noMovesIn {
                0%   { opacity:0; transform:translate(-50%,-50%) scale(0.8); }
                100% { opacity:1; transform:translate(-50%,-50%) scale(1); }
            }
            @keyframes noMovesOut {
                0%   { opacity:1; transform:translate(-50%,-50%) scale(1); }
                100% { opacity:0; transform:translate(-50%,-50%) scale(0.9); }
            }
            #no-moves-overlay {
                position: fixed; inset: 0;
                background: rgba(0,0,0,0.55);
                z-index: 25000;
            }
            #no-moves-popup {
                position: fixed;
                top: 42%; left: 50%;
                transform: translate(-50%,-50%);
                z-index: 25001;
                display: flex; flex-direction: column;
                align-items: center; gap: 12px;
                animation: noMovesIn 0.3s ease-out forwards;
            }
            #no-moves-popup.closing {
                animation: noMovesOut 0.25s ease-in forwards;
            }
            #no-moves-popup .nmp-card {
                width: 90px; height: 126px;
                background: #fff;
                border-radius: 12px;
                display: flex; flex-direction: column;
                align-items: center; justify-content: center;
                font-size: 36px; font-weight: 800;
                box-shadow: 0 12px 40px rgba(0,0,0,0.6), 0 0 0 3px rgba(255,255,255,0.2);
                color: #222;
                position: relative;
            }
            #no-moves-popup .nmp-card.red { color: #d32f2f; }
            #no-moves-popup .nmp-card .nmp-suit { font-size: 18px; margin-top: 2px; }
            #no-moves-popup .nmp-body {
                background: rgba(20,20,30,0.95);
                border-radius: 12px;
                padding: 16px 28px;
                text-align: center;
                max-width: 320px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            }
            #no-moves-popup .nmp-title {
                font-size: 18px; font-weight: 700;
                color: #ff6b6b;
                margin-bottom: 6px;
            }
            #no-moves-popup .nmp-msg {
                font-size: 14px; color: rgba(255,255,255,0.75);
                line-height: 1.4; margin-bottom: 14px;
            }
            #no-moves-popup .nmp-btn {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: #fff;
                border: none; border-radius: 8px;
                padding: 10px 32px;
                font-size: 15px; font-weight: 600;
                cursor: pointer;
                transition: transform 0.15s, box-shadow 0.15s;
                box-shadow: 0 4px 16px rgba(102,126,234,0.4);
            }
            #no-moves-popup .nmp-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(102,126,234,0.6);
            }
            @media (max-width: 768px) {
                #no-moves-popup .nmp-card { width: 72px; height: 100px; font-size: 28px; }
                #no-moves-popup .nmp-body { padding: 12px 20px; max-width: 280px; }
                #no-moves-popup .nmp-title { font-size: 16px; }
                #no-moves-popup .nmp-msg { font-size: 13px; }
            }
        `;
        document.head.appendChild(s);
    })();

    function showNoLegalMovesPopup(card, onDismiss, isInJail) {
        // Remove existing
        const oldOverlay = document.getElementById('no-moves-overlay');
        const oldPopup = document.getElementById('no-moves-popup');
        if (oldOverlay) oldOverlay.remove();
        if (oldPopup) oldPopup.remove();

        const rank = (card.rank || card.value || '?').toString().toUpperCase();
        const suitSym = getSuitSymbol(card.suit);
        const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
        const info = CARD_RULES[rank] || { rule: 'Hop ' + (card.movement || '?') + ' forward.' };

        const cardIcon = rank === 'JOKER' ? 'ğŸƒ' : (rank === 'A' ? 'ğŸ…°ï¸' : (rank === 'J' ? 'ğŸ¤´' : (rank === 'Q' ? 'ğŸ‘¸' : (rank === 'K' ? 'ğŸ‘‘' : rank))));

        // Overlay
        const overlay = document.createElement('div');
        overlay.id = 'no-moves-overlay';

        // Popup
        const popup = document.createElement('div');
        popup.id = 'no-moves-popup';
        
        if (isInJail) {
            // Jail version â€” prisoner with ball and chain
            popup.innerHTML = `
                <div style="font-size:64px; margin-bottom:8px; animation: jailShake 0.5s ease-in-out infinite alternate;">â›“ï¸</div>
                <div class="nmp-body">
                    <div class="nmp-title" style="color:#ff9944;">Still in jail!</div>
                    <div style="font-size:40px; margin:8px 0;">ğŸ‘®â€â™‚ï¸ğŸ”’</div>
                    <div class="nmp-msg" style="color:#ffcc88;">You need an Ace or a Face card (J, Q, K) to break out!<br>Hang in there â€” freedom is just a card away.</div>
                    <div class="nmp-card ${isRed ? 'red' : ''}" style="margin:12px auto 0; width:fit-content;">
                        <span>${cardIcon}</span>
                        <span class="nmp-suit">${suitSym}</span>
                    </div>
                    <button class="nmp-btn" style="margin-top:14px;">OK</button>
                </div>
                <style>
                    @keyframes jailShake {
                        from { transform: rotate(-5deg); }
                        to { transform: rotate(5deg); }
                    }
                </style>
            `;
        } else {
            popup.innerHTML = `
                <div class="nmp-card ${isRed ? 'red' : ''}">
                    <span>${cardIcon}</span>
                    <span class="nmp-suit">${suitSym}</span>
                </div>
                <div class="nmp-body">
                    <div class="nmp-title">No Legal Moves</div>
                    <div class="nmp-msg">${info.rule}<br>All pegs are blocked â€” turn will be skipped.</div>
                    <button class="nmp-btn">OK</button>
                </div>
            `;
        }

        document.body.appendChild(overlay);
        document.body.appendChild(popup);

        function dismiss() {
            popup.classList.add('closing');
            overlay.style.transition = 'opacity 0.25s';
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.remove();
                popup.remove();
                if (onDismiss) onDismiss();
            }, 260);
        }

        popup.querySelector('.nmp-btn').addEventListener('click', dismiss);
        overlay.addEventListener('click', dismiss);

        // Auto-dismiss after 6s in case user doesn't click
        setTimeout(() => {
            if (document.getElementById('no-moves-popup')) {
                dismiss();
            }
        }, 6000);
    }

    function showCardRulePopup(card, movesCount) {
        // Remove existing popup
        const old = document.getElementById('card-rule-popup');
        if (old) old.remove();

        const rank = (card.rank || card.value || '?').toString().toUpperCase();
        const suitSym = getSuitSymbol(card.suit);
        const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
        const info = CARD_RULES[rank] || { icon: 'ğŸ‚ ', rule: 'Hop ' + (card.movement || '?') + ' forward.' };

        // Build hint line
        let hint = '';
        if (movesCount === 0) {
            hint = 'No legal moves â€” turn skipped';
        } else if (movesCount === 1) {
            hint = 'Tap the flashing hole to move';
        } else if (movesCount > 1) {
            hint = 'Choose a flashing hole';
        }

        const popup = document.createElement('div');
        popup.id = 'card-rule-popup';
        popup.innerHTML = `
            <div class="crp-card ${isRed ? 'red' : ''}">
                <span>${rank === 'JOKER' ? 'ğŸƒ' : (rank === 'A' ? 'ğŸ…°ï¸' : (rank === 'J' ? 'ğŸ¤´' : (rank === 'Q' ? 'ğŸ‘¸' : (rank === 'K' ? 'ğŸ‘‘' : rank))))}</span>
                <span class="crp-suit">${suitSym}</span>
            </div>
            <div class="crp-rule">
                ${info.rule}
                ${hint ? '<div class="crp-hint">' + hint + '</div>' : ''}
            </div>
        `;
        document.body.appendChild(popup);

        // Auto-remove
        setTimeout(() => {
            const el = document.getElementById('card-rule-popup');
            if (el) el.remove();
        }, 3100);
    }

    // Dismiss card rule popup (called when player clicks a move)
    function dismissCardRulePopup() {
        const el = document.getElementById('card-rule-popup');
        if (el) el.remove();
    }
    window.dismissCardRulePopup = dismissCardRulePopup;
    
    // Show detailed explanation for 7 card split process
    function show7CardExplanationModal() {
        // Remove existing modal
        const old = document.getElementById('seven-card-modal');
        if (old) old.remove();
        
        const modal = document.createElement('div');
        modal.id = 'seven-card-modal';
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #ffd700;
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.8), 0 0 40px rgba(255,215,0,0.3);
            animation: modalFadeIn 0.3s ease-out;
        `;
        
        modal.innerHTML = `
            <style>
                @keyframes modalFadeIn {
                    from { opacity: 0; transform: translate(-50%, -45%); }
                    to { opacity: 1; transform: translate(-50%, -50%); }
                }
            </style>
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 3rem; margin-bottom: 8px;">âœ¨</div>
                <div style="font-size: 1.5rem; font-weight: bold; color: #ffd700; margin-bottom: 8px;">Card 7 - Wild Card</div>
                <div style="font-size: 0.9rem; color: #aaa;">Move any token 1-7 spaces</div>
            </div>
            
            <div style="background: rgba(0,0,0,0.3); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                <div style="font-weight: bold; color: #4ade80; margin-bottom: 12px; font-size: 1.1rem;">ğŸ“‹ How It Works:</div>
                <div style="line-height: 1.8; color: #ddd;">
                    <div style="margin-bottom: 8px;">1ï¸âƒ£ <strong>Click a peg</strong> to select it</div>
                    <div style="margin-bottom: 8px;">2ï¸âƒ£ <strong>Click a glowing hole</strong> to move (1-7 spaces)</div>
                    <div style="margin-bottom: 8px;">3ï¸âƒ£ If you used 1-6 spaces, <strong>click another peg</strong></div>
                    <div style="margin-bottom: 8px;">4ï¸âƒ£ That peg moves the <strong>remaining spaces</strong></div>
                </div>
            </div>
            
            <div style="background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <div style="font-size: 0.85rem; color: #ffd700;">
                    ğŸ’¡ <strong>Examples:</strong><br>
                    â€¢ Move peg #1 three spaces, then peg #2 four spaces<br>
                    â€¢ Move peg #1 all seven spaces (no second peg needed)<br>
                    â€¢ Both moves are clockwise only
                </div>
            </div>
            
            <button onclick="document.getElementById('seven-card-modal').remove()" style="
                width: 100%;
                padding: 12px;
                background: linear-gradient(135deg, #4ade80, #22c55e);
                border: none;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                font-size: 1rem;
                cursor: pointer;
                transition: all 0.2s;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(74,222,128,0.4)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
                Got It! Let's Play
            </button>
        `;
        
        document.body.appendChild(modal);
        
        // Auto-dismiss after 8 seconds
        setTimeout(() => {
            const el = document.getElementById('seven-card-modal');
            if (el) el.remove();
        }, 8000);
    }
    
    function enableMakeMoveButton() {
        // Not needed with integrated banner
        return;
    }
    
    function hideTurnBanner() {
        if (cardUI) {
            cardUI.hideActionBanner();
        }
    }
    
    // ============================================================
    // LARGE CENTERED DECK UI
    // ============================================================
    
    function showLargeDeck() {
        console.log('[LargeDeck] Showing large centered deck');
        hideLargeDeck();
        
        const player = gameState.currentPlayer;
        const playerName = player.name || `Player ${gameState.currentPlayerIndex + 1}`;
        const playerColor = player.color || '#3498db';
        
        const overlay = document.createElement('div');
        overlay.id = 'large-deck-overlay';
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5); z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            animation: fadeIn 0.3s ease-out;
        `;
        
        const banner = document.createElement('div');
        banner.style.cssText = `
            font-size: 32px; font-weight: bold; color: ${playerColor};
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8); margin-bottom: 30px;
            animation: pulse 1.5s ease-in-out infinite;
        `;
        banner.textContent = `${playerName}'s Turn`;
        
        const deck = document.createElement('div');
        deck.id = 'large-deck-card';
        deck.style.cssText = `
            width: 200px; height: 280px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px; border: 4px solid #fff;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 80px; transition: transform 0.2s ease;
            animation: deckBounce 2s ease-in-out infinite;
        `;
        deck.textContent = 'ğŸ´';
        
        deck.addEventListener('mouseenter', () => { deck.style.transform = 'scale(1.1) rotate(5deg)'; });
        deck.addEventListener('mouseleave', () => { deck.style.transform = 'scale(1) rotate(0deg)'; });
        deck.addEventListener('click', () => { handleDrawCard(false); });
        
        const instruction = document.createElement('div');
        instruction.style.cssText = `
            font-size: 24px; color: #fff; margin-top: 30px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            animation: pulse 1.5s ease-in-out infinite;
        `;
        instruction.textContent = 'Click to Draw Card';
        
        overlay.appendChild(banner);
        overlay.appendChild(deck);
        overlay.appendChild(instruction);
        document.body.appendChild(overlay);
        
        if (!document.getElementById('large-deck-styles')) {
            const style = document.createElement('style');
            style.id = 'large-deck-styles';
            style.textContent = `
                @keyframes deckBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
                @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
            `;
            document.head.appendChild(style);
        }
    }
    
    function hideLargeDeck() {
        const overlay = document.getElementById('large-deck-overlay');
        if (overlay) {
            overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
            setTimeout(() => { if (overlay.parentNode) overlay.parentNode.removeChild(overlay); }, 300);
        }
    }
    
    function showRevealedCard(card) {
        console.log('[LargeDeck] Showing revealed card:', card.rank);
        
        const overlay = document.createElement('div');
        overlay.id = 'revealed-card-overlay';
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); z-index: 10000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            animation: fadeIn 0.3s ease-out;
        `;
        
        const cardDisplay = document.createElement('div');
        const cardColor = (card.suit === 'hearts' || card.suit === 'diamonds' || card.suit === 'red') ? '#e74c3c' : '#2c3e50';
        cardDisplay.style.cssText = `
            width: 200px; height: 280px; background: #fff;
            border-radius: 15px; border: 4px solid #FFD700;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.5);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 100px; font-weight: bold; color: ${cardColor};
            animation: cardFlip 0.6s ease-out;
        `;
        
        const rank = document.createElement('div');
        rank.textContent = card.rank;
        cardDisplay.appendChild(rank);
        
        if (card.suit) {
            const suitSymbols = { 'hearts': 'â™¥', 'diamonds': 'â™¦', 'clubs': 'â™£', 'spades': 'â™ ', 'red': 'ğŸƒ', 'black': 'ğŸƒ' };
            const suitEl = document.createElement('div');
            suitEl.style.fontSize = '40px';
            suitEl.textContent = suitSymbols[card.suit] || '';
            cardDisplay.appendChild(suitEl);
        }
        
        overlay.appendChild(cardDisplay);
        document.body.appendChild(overlay);
        
        if (!document.getElementById('card-flip-styles')) {
            const style = document.createElement('style');
            style.id = 'card-flip-styles';
            style.textContent = `
                @keyframes cardFlip {
                    0% { transform: rotateY(90deg) scale(0.5); opacity: 0; }
                    50% { transform: rotateY(45deg) scale(0.8); }
                    100% { transform: rotateY(0deg) scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }
        
        setTimeout(() => {
            overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
            setTimeout(() => {
                if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
                updatePlayerPanelCard(card);
            }, 300);
        }, 1500);
    }
    
    function updatePlayerPanelCard(card) {
        console.log('[LargeDeck] Updating player panel with card:', card.rank);
        if (window.GameUIMinimal && window.GameUIMinimal.setDrawnCard) {
            window.GameUIMinimal.setDrawnCard(card);
        }
        if (cardUI && cardUI.showCard) {
            cardUI.showCard(card);
        }
    }
    
    // Show auto-move notification for human players
    // ================================================================
    // FASTTRACK AUTO/MANUAL TRAVERSAL CHOICE DIALOG
    // Shows when a human player enters FastTrack, offering them the
    // choice to traverse automatically or manually each turn.
    // ================================================================
    function showFTTraversalChoiceDialog() {
        // Don't show if dialog already exists
        if (document.getElementById('ft-traversal-dialog')) return;
        
        const dialog = document.createElement('div');
        dialog.id = 'ft-traversal-dialog';
        Object.assign(dialog.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'linear-gradient(135deg, rgba(10,0,40,0.97), rgba(30,10,60,0.98))',
            border: '2px solid #9966ff',
            borderRadius: '18px',
            padding: '30px 40px',
            zIndex: '10000',
            textAlign: 'center',
            color: '#fff',
            fontFamily: "'Segoe UI', sans-serif",
            boxShadow: '0 0 40px rgba(153,102,255,0.5), 0 0 80px rgba(100,50,200,0.3)',
            maxWidth: '420px',
            animation: 'ftDialogFadeIn 0.4s ease-out'
        });
        
        dialog.innerHTML = `
            <style>
                @keyframes ftDialogFadeIn {
                    from { opacity: 0; transform: translate(-50%, -50%) scale(0.85); }
                    to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
                .ft-choice-btn {
                    display: block;
                    width: 100%;
                    padding: 14px 20px;
                    margin: 8px 0;
                    border: none;
                    border-radius: 12px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: transform 0.15s, box-shadow 0.15s;
                }
                .ft-choice-btn:hover {
                    transform: scale(1.03);
                    box-shadow: 0 4px 20px rgba(255,255,255,0.2);
                }
                .ft-auto-btn {
                    background: linear-gradient(135deg, #6633cc, #9966ff);
                    color: #fff;
                }
                .ft-manual-btn {
                    background: linear-gradient(135deg, #1a5276, #2e86c1);
                    color: #fff;
                }
            </style>
            <div style="font-size: 28px; margin-bottom: 8px;">âš¡ FastTrack Entered!</div>
            <div style="font-size: 14px; color: #ccc; margin-bottom: 20px;">
                How do you want to traverse the inner ring?
            </div>
            <button class="ft-choice-btn ft-auto-btn" onclick="window._ftChooseMode('auto')">
                ğŸš€ Auto Traverse
                <div style="font-size:12px;font-weight:normal;margin-top:4px;opacity:0.8;">
                    Automatically move around the ring each turn
                </div>
            </button>
            <button class="ft-choice-btn ft-manual-btn" onclick="window._ftChooseMode('manual')">
                ğŸ¯ Manual Control
                <div style="font-size:12px;font-weight:normal;margin-top:4px;opacity:0.8;">
                    Choose your move each turn (continue, exit, or bullseye)
                </div>
            </button>
        `;
        
        document.body.appendChild(dialog);
    }
    
    // Handle FT traversal mode choice
    window._ftChooseMode = function(mode) {
        GAME_CONFIG.ftAutoTraverse = (mode === 'auto');
        console.log(`âš¡ [FT Choice] Player chose ${mode} FastTrack traversal (ftAutoTraverse=${GAME_CONFIG.ftAutoTraverse})`);
        
        const dialog = document.getElementById('ft-traversal-dialog');
        if (dialog) {
            dialog.style.transition = 'opacity 0.3s, transform 0.3s';
            dialog.style.opacity = '0';
            dialog.style.transform = 'translate(-50%, -50%) scale(0.85)';
            setTimeout(() => dialog.remove(), 300);
        }
        
        // Show confirmation banner
        if (cardUI) {
            const msg = mode === 'auto' 
                ? 'ğŸš€ Auto-traversing FastTrack ring' 
                : 'ğŸ¯ Manual FastTrack mode â€” choose each move';
            cardUI.showActionBanner(msg, 'default');
            setTimeout(() => { if (cardUI) cardUI.hideActionBanner(); }, 2000);
        }
    };
    
    // ================================================================
    // ILLEGAL MOVE POPUP â€” Shows when player clicks an illegal hole
    // Used in hard mode or when manually selecting moves
    // ================================================================
    function showIllegalMovePopup(reason) {
        // Remove any existing popup
        const existing = document.getElementById('illegal-move-popup');
        if (existing) existing.remove();
        
        const popup = document.createElement('div');
        popup.id = 'illegal-move-popup';
        Object.assign(popup.style, {
            position: 'fixed',
            top: '30%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'linear-gradient(135deg, rgba(120,10,10,0.96), rgba(80,0,0,0.98))',
            border: '2px solid #ff4444',
            borderRadius: '14px',
            padding: '24px 36px',
            zIndex: '10001',
            textAlign: 'center',
            color: '#fff',
            fontFamily: "'Segoe UI', sans-serif",
            boxShadow: '0 0 30px rgba(255, 50, 50, 0.5)',
            maxWidth: '380px',
            animation: 'illegalMoveShake 0.5s ease-out'
        });
        
        popup.innerHTML = `
            <style>
                @keyframes illegalMoveShake {
                    0%,100% { transform: translate(-50%, -50%); }
                    10%,30%,50%,70%,90% { transform: translate(-50%, -50%) translateX(-5px); }
                    20%,40%,60%,80% { transform: translate(-50%, -50%) translateX(5px); }
                }
            </style>
            <div style="font-size: 26px; margin-bottom: 8px;">ğŸš« Illegal Move</div>
            <div style="font-size: 14px; color: #ffcccc; line-height: 1.5;">
                ${reason}
            </div>
            <div style="font-size: 12px; color: #ff9999; margin-top: 12px; opacity: 0.7;">
                Peg returned to original position
            </div>
        `;
        
        document.body.appendChild(popup);
        
        // Play error sound
        if (window.gameSFX && window.gameSFX.playError) {
            window.gameSFX.playError();
        }
        
        // Auto-dismiss after 3 seconds
        setTimeout(() => {
            if (popup.parentNode) {
                popup.style.transition = 'opacity 0.4s';
                popup.style.opacity = '0';
                setTimeout(() => popup.remove(), 400);
            }
        }, 3000);
    }

    function showAutoMoveBanner() {
        if (cardUI) {
            cardUI.showActionBanner('âš¡ Auto-moving (only one choice)', 'default');
            // Auto-hide after a short delay
            setTimeout(() => {
                if (cardUI) cardUI.hideActionBanner();
            }, 800);
        }
    }

    function handleBannerAction() {
        // Execute the pending move if one is selected
        if (pendingMoveSelection) {
            hideTurnBanner();
            
            const move = pendingMoveSelection;
            pendingMoveSelection = null;
            
            console.log('Executing selected move from banner:', move);
            clearHighlights();
            animatePegMove(move, () => {
                gameState.executeMove(move);
                cardUI.clearCard();
            });
        }
    }
    
    // Expose to global scope for onclick
    window.handleBannerAction = handleBannerAction;
    
    // ============================================================
    // PLAY AGAIN & FIRST PLAYER ANNOUNCEMENT
    // ============================================================
    
    // Track game session type for replay rules
    let gameSessionType = 'solo'; // 'solo', 'private', 'public'
    let replayAgreements = {}; // { playerId: boolean }
    let totalHumanPlayers = 1;
    
    function showPlayAgainButton(winner) {
        // Remove any existing play again overlay
        let existing = document.getElementById('play-again-overlay');
        if (existing) existing.remove();
        
        const overlay = document.createElement('div');
        overlay.id = 'play-again-overlay';
        Object.assign(overlay.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'linear-gradient(135deg, rgba(20,30,50,0.95), rgba(10,15,30,0.98))',
            padding: '40px 60px',
            borderRadius: '20px',
            border: '2px solid rgba(255,215,0,0.5)',
            boxShadow: '0 0 60px rgba(255,215,0,0.3), inset 0 0 30px rgba(255,215,0,0.05)',
            zIndex: '50000',
            textAlign: 'center',
            backdropFilter: 'blur(20px)',
            WebkitBackdropFilter: 'blur(20px)',
            maxWidth: '500px',
            width: '90%'
        });
        
        // Winner announcement
        const winnerAvatar = winner.avatar || 'ğŸ‘¤';
        const winnerColor = winner.colorHex || '#ffd700';
        
        const winnerText = document.createElement('div');
        Object.assign(winnerText.style, {
            fontSize: '28px',
            color: '#fff',
            marginBottom: '8px'
        });
        winnerText.innerHTML = `<span style="font-size: 42px; margin-right: 10px;">${winnerAvatar}</span><span style="color: ${winnerColor}; font-weight: bold;">${winner.name}</span>`;
        overlay.appendChild(winnerText);
        
        // "WINS!" title
        const winsTitle = document.createElement('div');
        Object.assign(winsTitle.style, {
            fontSize: '40px',
            fontWeight: '900',
            color: '#ffd700',
            textShadow: '0 0 30px rgba(255,215,0,0.8), 0 0 60px rgba(255,180,0,0.4)',
            marginBottom: '25px',
            letterSpacing: '4px'
        });
        winsTitle.textContent = 'ğŸ‘‘ WINS! ğŸ‘‘';
        overlay.appendChild(winsTitle);
        
        // Medallion points (only for public lobby games)
        if (gameSessionType === 'public') {
            const pointsDiv = document.createElement('div');
            Object.assign(pointsDiv.style, {
                background: 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,180,0,0.1))',
                border: '1px solid rgba(255,215,0,0.4)',
                borderRadius: '10px',
                padding: '15px',
                marginBottom: '20px'
            });
            pointsDiv.innerHTML = `
                <div style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 5px;">ğŸ… Medallion Points Awarded</div>
                <div style="font-size: 20px; color: #ffd700; font-weight: bold;">Winner: +100 pts</div>
                <div style="font-size: 14px; color: rgba(255,255,255,0.5); margin-top: 5px;">Participants: +25 pts</div>
            `;
            overlay.appendChild(pointsDiv);
        }
        
        // â”€â”€ ButterflyFX Growth: Victory Share Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (window.GrowthSubstrate) {
            GrowthSubstrate.injectVictoryShare(overlay, winner, {
                turns: gameState.turnCount || 0,
                theme: currentThemeName || 'spaceace',
                players: activePlayerCount || 4,
                isAI: (currentGameMode === 'solo')
            });
        }

        // Button container
        const btnContainer = document.createElement('div');
        Object.assign(btnContainer.style, {
            display: 'flex',
            flexDirection: 'column',
            gap: '12px',
            marginTop: '20px'
        });
        
        // Shared button styles
        const primaryBtnStyle = {
            padding: '15px 40px',
            fontSize: '18px',
            fontWeight: 'bold',
            background: 'linear-gradient(135deg, rgba(100,200,255,0.7), rgba(60,150,255,0.7))',
            border: '2px solid rgba(150,220,255,0.5)',
            borderRadius: '30px',
            color: '#fff',
            cursor: 'pointer',
            boxShadow: '0 0 25px rgba(100,200,255,0.5)',
            textShadow: '0 0 10px rgba(255,255,255,0.5)',
            transition: 'all 0.3s'
        };
        const secondaryBtnStyle = {
            padding: '12px 30px',
            fontSize: '15px',
            fontWeight: 'bold',
            background: 'rgba(100,100,100,0.3)',
            border: '1px solid rgba(150,150,150,0.3)',
            borderRadius: '25px',
            color: 'rgba(255,255,255,0.8)',
            cursor: 'pointer',
            transition: 'all 0.3s'
        };
        
        const makePrimaryBtn = (text, onClick) => {
            const btn = document.createElement('button');
            Object.assign(btn.style, primaryBtnStyle);
            btn.innerHTML = text;
            btn.onmouseover = () => btn.style.transform = 'scale(1.03)';
            btn.onmouseout = () => btn.style.transform = 'scale(1)';
            btn.onclick = onClick;
            return btn;
        };
        const makeSecondaryBtn = (text, onClick) => {
            const btn = document.createElement('button');
            Object.assign(btn.style, secondaryBtnStyle);
            btn.innerHTML = text;
            btn.onmouseover = () => { btn.style.transform = 'scale(1.02)'; btn.style.background = 'rgba(130,130,130,0.4)'; };
            btn.onmouseout = () => { btn.style.transform = 'scale(1)'; btn.style.background = 'rgba(100,100,100,0.3)'; };
            btn.onclick = onClick;
            return btn;
        };
        
        // â”€â”€ Buttons depend on game type â”€â”€
        if (gameSessionType === 'public') {
            // MATCH GAME â†’ Rematch (back to lobby)
            btnContainer.appendChild(makePrimaryBtn('ğŸ”„ Rematch', () => {
                requestReplay(true, overlay, winner);
            }));
            btnContainer.appendChild(makeSecondaryBtn('ğŸ  Back to Lobby', () => {
                overlay.remove();
                window.location.href = 'lobby.html';
            }));
        } else if (gameSessionType === 'private') {
            // PRIVATE GAME â†’ Replay + Leave Game
            btnContainer.appendChild(makePrimaryBtn(`ğŸ”„ Replay`, () => {
                overlay.remove();
                isReplayGame = true;
                initGame(activePlayerCount);
            }));
            btnContainer.appendChild(makeSecondaryBtn('ğŸšª Leave Game', () => {
                overlay.remove();
                window.location.href = window.location.pathname.includes('board_3d') ? '.' : 'index.html';
            }));
        } else {
            // SOLO / AI â†’ Replay (back to landing page)
            btnContainer.appendChild(makePrimaryBtn(`ğŸ”„ Play Again`, () => {
                overlay.remove();
                isReplayGame = true;
                initGame(activePlayerCount);
            }));
            btnContainer.appendChild(makeSecondaryBtn('ğŸ  Back to Menu', () => {
                overlay.remove();
                window.location.href = window.location.pathname.includes('board_3d') ? '.' : 'index.html';
            }));
        }
        
        overlay.appendChild(btnContainer);
        document.body.appendChild(overlay);
    }
    
    function requestReplay(wantsReplay, overlay, winner) {
        // For multiplayer public games, broadcast replay request
        if (window.multiplayerClient && typeof multiplayerClient.isConnected === "function" && multiplayerClient.isConnected()) {
            multiplayerClient.sendReplayVote(wantsReplay);
            
            // Update button to show waiting state
            const waitingDiv = document.createElement('div');
            Object.assign(waitingDiv.style, {
                marginTop: '15px',
                padding: '15px',
                background: 'rgba(100,200,255,0.1)',
                borderRadius: '10px',
                border: '1px solid rgba(100,200,255,0.3)'
            });
            waitingDiv.id = 'replay-waiting';
            waitingDiv.innerHTML = `
                <div style="color: #7dd3fc; margin-bottom: 10px;">â³ Waiting for all players...</div>
                <div id="replay-votes" style="font-size: 14px; color: rgba(255,255,255,0.7);"></div>
            `;
            overlay.appendChild(waitingDiv);
        } else {
            // Solo/private immediate replay
            overlay.remove();
            isReplayGame = true;
            initGame(activePlayerCount);
        }
    }
    
    function updateReplayVotes(votes) {
        const votesDiv = document.getElementById('replay-votes');
        if (!votesDiv) return;
        
        const votesList = Object.entries(votes).map(([name, agreed]) => 
            `${agreed ? 'âœ…' : 'â“'} ${name}`
        ).join(' | ');
        votesDiv.textContent = votesList;
        
        // Check if all agreed
        const allAgreed = Object.values(votes).every(v => v === true);
        const anyDeclined = Object.values(votes).some(v => v === false);
        
        if (allAgreed && Object.keys(votes).length >= totalHumanPlayers) {
            // All agreed - start replay
            const overlay = document.getElementById('play-again-overlay');
            if (overlay) overlay.remove();
            isReplayGame = true;
            initGame(activePlayerCount);
        } else if (anyDeclined) {
            // Someone declined - show message
            const waitingDiv = document.getElementById('replay-waiting');
            if (waitingDiv) {
                waitingDiv.innerHTML = `
                    <div style="color: #ff6b6b; margin-bottom: 10px;">âŒ Replay declined</div>
                    <div style="font-size: 14px; color: rgba(255,255,255,0.7);">Starting new game with random first player...</div>
                `;
                setTimeout(() => {
                    const overlay = document.getElementById('play-again-overlay');
                    if (overlay) overlay.remove();
                    isReplayGame = false;
                    lastWinnerIndex = null;
                    initGame(activePlayerCount);
                }, 2000);
            }
        }
    }
    
    function showFirstPlayerAnnouncement(playerName, playerColor, reason) {
        // Remove any existing announcement
        let existing = document.getElementById('first-player-announcement');
        if (existing) existing.remove();
        
        const announcement = document.createElement('div');
        announcement.id = 'first-player-announcement';
        Object.assign(announcement.style, {
            position: 'fixed',
            top: '30%',
            left: '50%',
            transform: 'translate(-50%, -50%) scale(0.8)',
            background: 'linear-gradient(135deg, rgba(20,30,50,0.85), rgba(10,15,30,0.9))',
            padding: '30px 50px',
            borderRadius: '15px',
            border: '2px solid rgba(100,200,255,0.4)',
            boxShadow: '0 0 50px rgba(100,180,255,0.3)',
            zIndex: '40000',
            textAlign: 'center',
            backdropFilter: 'blur(15px)',
            WebkitBackdropFilter: 'blur(15px)',
            opacity: '0',
            transition: 'all 0.5s cubic-bezier(0.4, 0, 0.2, 1)'
        });
        
        const text = document.createElement('div');
        Object.assign(text.style, {
            fontSize: '28px',
            fontWeight: 'bold',
            color: '#fff',
            textShadow: '0 0 15px rgba(100,200,255,0.5)'
        });
        
        if (reason === 'winner') {
            text.innerHTML = `ğŸ† <span style="color: ${playerColor}">${playerName}</span> goes first!`;
        } else {
            text.innerHTML = `ğŸ² <span style="color: ${playerColor}">${playerName}</span> goes first!`;
        }
        announcement.appendChild(text);
        
        const subtext = document.createElement('div');
        Object.assign(subtext.style, {
            fontSize: '14px',
            color: 'rgba(200,230,255,0.6)',
            marginTop: '10px'
        });
        subtext.textContent = reason === 'winner' ? 'Winner of last game' : 'Randomly selected';
        announcement.appendChild(subtext);
        
        document.body.appendChild(announcement);
        
        // Animate in
        requestAnimationFrame(() => {
            announcement.style.opacity = '1';
            announcement.style.transform = 'translate(-50%, -50%) scale(1)';
        });
        
        // Fade out and remove
        setTimeout(() => {
            announcement.style.opacity = '0';
            announcement.style.transform = 'translate(-50%, -50%) scale(0.9)';
            setTimeout(() => announcement.remove(), 500);
        }, 3000);
    }

    // ============================================================
    // TURN TIMER SYSTEM â€” stubs overridden by full implementation below
    // ============================================================
    
    // ============================================================
    // BOT REPLACEMENT SYSTEM
    // ============================================================
    
    function replacePlayerWithBot(playerIndex) {
        const player = gameState.players[playerIndex];
        const oldName = player.name;
        
        // Mark as AI player
        if (!AI_CONFIG.players.includes(playerIndex)) {
            AI_CONFIG.players.push(playerIndex);
        }
        
        // Update player name to indicate bot
        player.name = `ğŸ¤– ${oldName} (Bot)`;
        player.isBot = true;
        
        // Update player panel
        if (window.playerPanelUI) {
            window.playerPanelUI.updatePanel(`player_${playerIndex}`, {
                name: player.name,
                mood: 'neutral'
            });
        }
        
        // Alert all players
        showBotAlert(oldName, `${oldName} has been replaced with a bot due to inactivity`, true);
        
        // Let the bot take over immediately
        setTimeout(() => {
            aiTakeTurn();
        }, 2000);
    }
    
    function showBotAlert(playerName, message, isReplacement) {
        const alert = document.getElementById('bot-alert');
        const titleEl = document.getElementById('bot-alert-title');
        const msgEl = document.getElementById('bot-alert-message');
        
        if (alert && titleEl && msgEl) {
            titleEl.textContent = isReplacement ? 'Player Replaced' : 'âš ï¸ Warning';
            msgEl.textContent = message;
            alert.classList.add('visible');
            
            setTimeout(() => {
                alert.classList.remove('visible');
            }, 4000);
        }
    }
    
    // ============================================================
    // PAUSE SYSTEM
    // ============================================================
    
    let gamePaused = false;
    let pauseTimerInterval = null;
    let pauseTimeRemaining = 300; // 5 minutes
    const PAUSE_TIME_LIMIT = 300; // 5 minutes in seconds
    
    function togglePause() {
        if (gamePaused) {
            resumeGame();
        } else {
            pauseGame();
        }
    }
    
    function pauseGame() {
        if (gamePaused) return;
        gamePaused = true;
        pauseTimeRemaining = PAUSE_TIME_LIMIT;
        
        const overlay = document.getElementById('pause-overlay');
        if (overlay) {
            overlay.classList.add('visible');
            updatePauseTimer();
        }
        
        pauseTimerInterval = setInterval(() => {
            pauseTimeRemaining--;
            updatePauseTimer();
            
            if (pauseTimeRemaining <= 0) {
                resumeGame();
            }
        }, 1000);
        
        // Broadcast pause state
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.updateState({ paused: true });
        }
    }
    
    function resumeGame() {
        gamePaused = false;
        
        if (pauseTimerInterval) {
            clearInterval(pauseTimerInterval);
            pauseTimerInterval = null;
        }
        
        const overlay = document.getElementById('pause-overlay');
        if (overlay) {
            overlay.classList.remove('visible');
        }
        
        // Broadcast resume state
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.updateState({ paused: false });
        }
    }
    
    function updatePauseTimer() {
        const timerEl = document.getElementById('pause-timer');
        if (timerEl) {
            const mins = Math.floor(pauseTimeRemaining / 60);
            const secs = pauseTimeRemaining % 60;
            timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }
    }
    
    // Expose to global scope
    window.togglePause = togglePause;
    window.resumeGame = resumeGame;
    
    // Toggle auto-move setting for human players
    function toggleAutoMove(enabled) {
        GAME_CONFIG.autoMoveForHumans = enabled;
        const label = document.getElementById('auto-move-label');
        if (label) {
            label.textContent = enabled ? 'ON' : 'OFF';
        }
        
        // Sync settings panel buttons
        const autoBtn = document.getElementById('btn-move-auto');
        const manualBtn = document.getElementById('btn-move-manual');
        if (autoBtn) {
            autoBtn.style.background = enabled ? '#4a4a6e' : '#2a2a3e';
            autoBtn.style.borderColor = enabled ? '#888' : '#555';
        }
        if (manualBtn) {
            manualBtn.style.background = enabled ? '#2a2a3e' : '#4a4a6e';
            manualBtn.style.borderColor = enabled ? '#555' : '#888';
        }
        
        console.log(`âš¡ Auto-move for humans: ${enabled ? 'ENABLED' : 'DISABLED'}`);
    }
    window.toggleAutoMove = toggleAutoMove;

    // ============================================================
    // GAME SESSION MANAGEMENT - Leave, Return, Boot, Turn Timer
    // ============================================================
    
    // Session state
    let gameSessionSettings = {
        isOrganizer: false,
        organizerId: null,
        replaceWithBot: true,
        noReturns: false,
        turnTimer: true,
        turnTimerWaitSeconds: 120,   // 2 minutes silent wait
        turnTimerClockSeconds: 60,   // 1 minute visible countdown
        turnTimerSeconds: 180,       // total (wait + clock)
        warningSeconds: 60,
        noBots: false
    };
    
    let playerLeftState = {
        hasLeft: false,
        originalPlayerId: null,
        botReplacementId: null,
        canReturn: true
    };
    
    let turnTimerState = {
        active: false,
        intervalId: null,
        waitTimeoutId: null,
        secondsRemaining: 0,
        clockSeconds: 60,
        phase: null,        // 'wait' or 'clock'
        isWarning: false
    };
    
    // Initialize session settings from URL params or server data
    function initSessionSettings(settings = {}) {
        gameSessionSettings = {
            ...gameSessionSettings,
            ...settings
        };
        
        // Show/hide organizer button
        const orgBtn = document.getElementById('organizer-menu-btn');
        if (orgBtn) {
            orgBtn.style.display = gameSessionSettings.isOrganizer ? 'inline-flex' : 'none';
        }
        
        // Start turn timer if enabled
        if (gameSessionSettings.turnTimer) {
            console.log('[Session] Turn timer enabled:', gameSessionSettings.turnTimerSeconds, 'seconds');
        }
    }
    
    // Leave Game Functions
    function showLeaveGameModal() {
        const modal = document.getElementById('leave-game-modal');
        const message = document.getElementById('leave-game-message');
        
        if (message) {
            if (gameSessionSettings.noBots || !gameSessionSettings.replaceWithBot) {
                message.textContent = 'You will be removed from the game. Your pegs will be taken off the board.';
            } else if (gameSessionSettings.noReturns) {
                message.textContent = 'A bot will replace you. You will NOT be able to return to this game.';
            } else {
                message.textContent = 'A bot will play for you while you\'re away. You can return anytime.';
            }
        }
        
        if (modal) {
            modal.classList.add('visible');
            modal.style.display = 'flex';
        }
    }
    
    function closeLeaveGameModal() {
        const modal = document.getElementById('leave-game-modal');
        if (modal) {
            modal.classList.remove('visible');
            modal.style.display = 'none';
        }
    }
    
    function confirmLeaveGame() {
        closeLeaveGameModal();
        
        const myPlayerIndex = getMyPlayerIndex();
        if (myPlayerIndex < 0) return;
        
        if (gameSessionSettings.noBots || !gameSessionSettings.replaceWithBot) {
            // Remove player completely
            removePlayerFromGame(myPlayerIndex);
        } else {
            // Replace with bot
            replacePlayerWithBot(myPlayerIndex);
            playerLeftState.hasLeft = true;
            playerLeftState.canReturn = !gameSessionSettings.noReturns;
            
            // Show return banner if allowed
            if (playerLeftState.canReturn) {
                showReturnBanner();
            }
        }
        
        // Notify server
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.sendAction({
                type: 'player_left',
                playerIndex: myPlayerIndex,
                replaceWithBot: gameSessionSettings.replaceWithBot && !gameSessionSettings.noBots
            });
        }
        
        // In solo mode (no multiplayer), navigate back to menu
        // since no human is left to watch the game
        const remainingHumans = gameState ? 
            gameState.players.filter(p => !p.isAI).length : 0;
        if (!isMultiplayer || remainingHumans === 0) {
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1500);
        }
    }
    
    function replacePlayerWithBot(playerIndex) {
        if (!gameState || !gameState.players[playerIndex]) return;
        
        const player = gameState.players[playerIndex];
        playerLeftState.originalPlayerId = player.id;
        
        // Mark player as AI
        player.isAI = true;
        player.wasHuman = true; // Track that this was a human
        player.name = `ğŸ¤– ${player.name} (Bot)`;
        
        // Update UI
        if (window.GameUIMinimal) {
            window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
        }
        
        // Show bot alert
        showBotAlert(`${player.name.replace(' (Bot)', '')} left`, 'A bot is now playing for them');
        
        // If it's this player's turn, AI takes over
        if (gameState.currentPlayerIndex === playerIndex) {
            setTimeout(() => aiTakeTurn(), 1000);
        }
        
        console.log(`[Session] Player ${playerIndex} replaced with bot`);
    }
    
    function removePlayerFromGame(playerIndex) {
        if (!gameState || !gameState.players[playerIndex]) return;
        
        const player = gameState.players[playerIndex];
        const playerName = player.name;
        
        // Remove all pegs from the board â€” both game state and 3D scene
        if (player.pegs) {
            player.pegs.forEach(peg => {
                // Remove 3D mesh from scene
                if (peg.mesh) {
                    if (peg.mesh.parent) peg.mesh.parent.remove(peg.mesh);
                    peg.mesh.visible = false;
                    // Dispose geometry and materials
                    peg.mesh.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
                // Remove from pegRegistry
                if (typeof pegRegistry !== 'undefined') {
                    pegRegistry.forEach((regPeg, id) => {
                        if (regPeg.playerIndex === playerIndex) {
                            pegRegistry.delete(id);
                        }
                    });
                }
                // Clear peg state
                peg.position = -1;
                peg.state = 'removed';
            });
        }
        
        // Mark player as eliminated
        player.eliminated = true;
        player.active = false;
        
        // Hide their player panel
        if (window.playerPanelUI) {
            const panelEl = document.getElementById(`player_${playerIndex}`);
            if (panelEl) {
                panelEl.style.transition = 'opacity 0.5s, transform 0.5s';
                panelEl.style.opacity = '0';
                panelEl.style.transform = 'scale(0.8)';
                setTimeout(() => { panelEl.style.display = 'none'; }, 600);
            }
        }
        
        // Update UI
        if (window.GameUIMinimal) {
            window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
        }
        
        // If it was this player's turn, advance to next
        if (gameState.currentPlayerIndex === playerIndex) {
            gameState.advanceTurn();
        }
        
        console.log(`[Session] Player ${playerIndex} (${playerName}) fully removed from game`);
    }
    
    function showReturnBanner() {
        const banner = document.getElementById('return-game-banner');
        if (banner) {
            banner.style.display = 'block';
        }
    }
    
    function hideReturnBanner() {
        const banner = document.getElementById('return-game-banner');
        if (banner) {
            banner.style.display = 'none';
        }
    }
    
    function returnToGame() {
        if (!playerLeftState.hasLeft || !playerLeftState.canReturn) return;
        
        const myPlayerIndex = getMyPlayerIndex();
        if (myPlayerIndex < 0) return;
        
        const player = gameState.players[myPlayerIndex];
        if (player) {
            player.isAI = false;
            player.name = player.name.replace('ğŸ¤– ', '').replace(' (Bot)', '');
            
            // Update UI
            if (window.GameUIMinimal) {
                window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
            }
        }
        
        playerLeftState.hasLeft = false;
        hideReturnBanner();
        
        // Notify server
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.sendAction({
                type: 'player_returned',
                playerIndex: myPlayerIndex
            });
        }
        
        showBotAlert('Welcome Back!', 'You are now playing again');
        console.log(`[Session] Player ${myPlayerIndex} returned to game`);
    }
    
    function getMyPlayerIndex() {
        // In multiplayer, this comes from session
        // For now, return human player index (first non-AI)
        if (!gameState) return -1;
        for (let i = 0; i < gameState.players.length; i++) {
            if (!gameState.players[i].isAI && !gameState.players[i].wasHuman) {
                return i;
            }
        }
        return 0; // Default to first player in solo mode
    }
    
    // Organizer Controls
    function toggleOrganizerMenu() {
        const menu = document.getElementById('organizer-menu');
        if (!menu) return;
        
        if (menu.style.display === 'none' || !menu.style.display) {
            updateOrganizerPlayerList();
            menu.style.display = 'block';
        } else {
            menu.style.display = 'none';
        }
    }
    
    function closeOrganizerMenu() {
        const menu = document.getElementById('organizer-menu');
        if (menu) menu.style.display = 'none';
    }
    
    function updateOrganizerPlayerList() {
        const container = document.getElementById('organizer-player-list');
        if (!container || !gameState) return;
        
        const myIndex = getMyPlayerIndex();
        
        container.innerHTML = gameState.players.map((p, idx) => {
            const isOrganizer = idx === 0; // Organizer is usually player 0
            const isAI = p.isAI;
            const isMe = idx === myIndex;
            
            return `
                <div class="org-player-item ${isAI ? 'is-ai' : ''} ${isOrganizer ? 'is-host' : ''}">
                    <div class="player-info">
                        <span class="player-avatar">${p.avatar || 'ğŸ‘¤'}</span>
                        <span class="player-name" style="color: ${p.colorHex || '#fff'}">${p.name}${isMe ? ' (You)' : ''}</span>
                    </div>
                    ${!isOrganizer && !isMe ? `<button class="boot-btn" onclick="bootPlayer(${idx})">Boot</button>` : ''}
                </div>
            `;
        }).join('');
    }
    
    function bootPlayer(playerIndex) {
        if (!gameSessionSettings.isOrganizer) return;
        if (!gameState || !gameState.players[playerIndex]) return;
        
        const player = gameState.players[playerIndex];
        const playerName = player.name;
        
        // Replace with bot or remove based on settings
        if (gameSessionSettings.noBots || !gameSessionSettings.replaceWithBot) {
            removePlayerFromGame(playerIndex);
        } else {
            replacePlayerWithBot(playerIndex);
        }
        
        // Close and refresh menu
        updateOrganizerPlayerList();
        
        // Notify server
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.sendAction({
                type: 'player_booted',
                playerIndex: playerIndex,
                bootedBy: getMyPlayerIndex()
            });
        }
        
        console.log(`[Session] Organizer booted player ${playerIndex}: ${playerName}`);
    }
    
    // ============================================================
    // MID-GAME JOIN REQUESTS (Invited players can join after start)
    // ============================================================
    
    let pendingJoinRequests = []; // Array of { id, name, avatar, timestamp }
    let currentJoinRequest = null; // For the notification popup
    
    function addJoinRequest(playerId, playerName, playerAvatar = 'ğŸ‘¤') {
        // Only organizer handles join requests
        if (!gameSessionSettings.isOrganizer) return;
        
        const request = {
            id: playerId,
            name: playerName,
            avatar: playerAvatar,
            timestamp: Date.now()
        };
        
        pendingJoinRequests.push(request);
        updateJoinRequestUI();
        
        // Show notification popup for the newest request
        showJoinRequestNotification(request);
        
        console.log(`[Session] Join request received from ${playerName} (${playerId})`);
    }
    
    function updateJoinRequestUI() {
        // Update badge count
        const badge = document.getElementById('join-request-badge');
        if (badge) {
            if (pendingJoinRequests.length > 0) {
                badge.textContent = pendingJoinRequests.length;
                badge.style.display = 'flex';
            } else {
                badge.style.display = 'none';
            }
        }
        
        // Update join requests section in organizer menu
        const section = document.getElementById('join-requests-section');
        const list = document.getElementById('join-requests-list');
        
        if (section && list) {
            if (pendingJoinRequests.length > 0) {
                section.style.display = 'block';
                list.innerHTML = pendingJoinRequests.map(req => `
                    <div class="join-request-item" data-request-id="${req.id}">
                        <div class="request-info">
                            <span class="request-avatar">${req.avatar}</span>
                            <span class="request-name">${req.name}</span>
                        </div>
                        <div class="request-actions">
                            <button class="approve-btn" onclick="approveJoinRequestById('${req.id}')">âœ“ Approve</button>
                            <button class="deny-btn" onclick="denyJoinRequestById('${req.id}')">âœ—</button>
                        </div>
                    </div>
                `).join('');
            } else {
                section.style.display = 'none';
            }
        }
    }
    
    function showJoinRequestNotification(request) {
        currentJoinRequest = request;
        
        const notification = document.getElementById('join-request-notification');
        const avatarEl = document.getElementById('join-notify-avatar');
        const nameEl = document.getElementById('join-notify-name');
        const slotOptions = document.getElementById('join-slot-options');
        const slotInfo = document.getElementById('join-slot-info');
        const replaceBotOption = document.getElementById('join-replace-bot-option');
        const newSlotOption = document.getElementById('join-new-slot-option');
        
        if (notification && avatarEl && nameEl) {
            avatarEl.textContent = request.avatar;
            nameEl.textContent = request.name;
            
            // Check available slots
            const availableSlots = getAvailableSlotInfo();
            
            // Show appropriate options based on what's available
            if (slotOptions && slotInfo) {
                if (availableSlots.hasBotSlot && availableSlots.hasEmptySlot) {
                    // Both options available - show radio buttons
                    slotOptions.style.display = 'block';
                    slotInfo.style.display = 'none';
                    if (replaceBotOption) replaceBotOption.style.display = 'flex';
                    if (newSlotOption) newSlotOption.style.display = 'flex';
                } else if (availableSlots.hasBotSlot) {
                    // Only bot replacement available
                    slotOptions.style.display = 'none';
                    slotInfo.style.display = 'block';
                    slotInfo.innerHTML = 'ğŸ¤– Will replace a bot player';
                } else if (availableSlots.hasEmptySlot) {
                    // Only new slot available
                    slotOptions.style.display = 'none';
                    slotInfo.style.display = 'block';
                    slotInfo.innerHTML = 'â• Will start with fresh pegs in slot ' + (availableSlots.emptySlotIndex + 1);
                } else {
                    // No slots - shouldn't happen but handle it
                    slotOptions.style.display = 'none';
                    slotInfo.style.display = 'block';
                    slotInfo.innerHTML = 'âš ï¸ No available slots';
                }
            }
            
            notification.style.display = 'block';
            
            // Play notification sound if available
            if (window.GameSFX && window.GameSFX.playNotification) {
                window.GameSFX.playNotification();
            }
        }
    }
    
    function getAvailableSlotInfo() {
        if (!gameState) return { hasBotSlot: false, hasEmptySlot: false };
        
        const currentPlayerCount = gameState.players.length;
        const isPrivateGame = gameSessionSettings.isPrivate !== false;
        const hasAnyBot = gameState.players.some(p => p.isAI);
        
        // Calculate max allowed players
        let maxPlayers = 6;
        if (!isPrivateGame) {
            maxPlayers = 4; // Public games max 4
        } else if (hasAnyBot) {
            maxPlayers = 4; // Private games with bots max 4
        }
        
        // Check for bot slots
        let botSlotIndex = -1;
        for (let i = 0; i < gameState.players.length; i++) {
            if (gameState.players[i].isAI) {
                botSlotIndex = i;
                break;
            }
        }
        
        // Check for empty slots
        let emptySlotIndex = -1;
        if (currentPlayerCount < maxPlayers) {
            emptySlotIndex = currentPlayerCount; // Next available slot
        }
        
        return {
            hasBotSlot: botSlotIndex !== -1,
            botSlotIndex: botSlotIndex,
            hasEmptySlot: emptySlotIndex !== -1,
            emptySlotIndex: emptySlotIndex,
            maxPlayers: maxPlayers,
            currentCount: currentPlayerCount
        };
    }
    
    function hideJoinRequestNotification() {
        const notification = document.getElementById('join-request-notification');
        if (notification) {
            notification.style.display = 'none';
        }
        currentJoinRequest = null;
    }
    
    function approveJoinRequest() {
        if (!currentJoinRequest) return;
        
        // Get selected slot type from radio buttons
        const slotTypeRadio = document.querySelector('input[name="join-slot-type"]:checked');
        const slotType = slotTypeRadio ? slotTypeRadio.value : 'replace-bot';
        
        approveJoinRequestWithSlot(currentJoinRequest.id, slotType);
        hideJoinRequestNotification();
    }
    
    function denyJoinRequest() {
        if (!currentJoinRequest) return;
        denyJoinRequestById(currentJoinRequest.id);
        hideJoinRequestNotification();
    }
    
    function approveJoinRequestById(requestId) {
        // Default to replace-bot when called from list
        approveJoinRequestWithSlot(requestId, 'replace-bot');
    }
    
    function approveJoinRequestWithSlot(requestId, slotType) {
        const requestIndex = pendingJoinRequests.findIndex(r => r.id === requestId);
        if (requestIndex === -1) return;
        
        const request = pendingJoinRequests[requestIndex];
        pendingJoinRequests.splice(requestIndex, 1);
        
        // Send approval to lobby server (server will broadcast late_player_joined)
        if (lobbyWebSocket && lobbyWebSocket.readyState === WebSocket.OPEN) {
            lobbyWebSocket.send(JSON.stringify({
                type: 'approve_late_join',
                user_id: requestId,
                slot_type: slotType
            }));
            console.log(`[Session] Sent approve_late_join for ${request.name} (slot_type=${slotType})`);
        } else {
            // Fallback: apply locally only (offline / no server)
            const availableSlots = getAvailableSlotInfo();
            let assignedSlot = -1;
            
            if (slotType === 'new-slot' && availableSlots.hasEmptySlot) {
                assignedSlot = createNewPlayerSlot(request);
            } else if (availableSlots.hasBotSlot) {
                assignedSlot = availableSlots.botSlotIndex;
                const player = gameState.players[assignedSlot];
                player.isAI = false;
                player.name = request.name;
                player.avatar = request.avatar;
                player.userId = request.id;
                player.wasHuman = false;
                if (window.GameUIMinimal) {
                    window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
                }
            } else if (availableSlots.hasEmptySlot) {
                assignedSlot = createNewPlayerSlot(request);
            }
            
            if (assignedSlot !== -1) {
                showBotAlert(`${request.name} Joined!`, 'A new player has entered the game');
            } else {
                showBotAlert('Game Full', `Cannot add ${request.name} - no available slots`);
            }
        }
        
        updateJoinRequestUI();
        updateOrganizerPlayerList();
        
        // Show next notification if there are more requests
        if (pendingJoinRequests.length > 0) {
            showJoinRequestNotification(pendingJoinRequests[0]);
        }
    }
    
    function createNewPlayerSlot(request) {
        if (!gameState) return -1;
        
        const newSlotIndex = gameState.players.length;
        const availableSlots = getAvailableSlotInfo();
        
        if (!availableSlots.hasEmptySlot) return -1;
        
        // Create new player with fresh start
        const playerColors = ['#ff2020', '#2196ff', '#4caf50', '#ffeb3b', '#ff9800', '#9c27b0'];
        const newPlayer = {
            name: request.name,
            avatar: request.avatar,
            userId: request.id,
            colorHex: playerColors[newSlotIndex % playerColors.length],
            isAI: false,
            pegs: [],
            deck: null, // Will need to create deck
            pegsInHolding: 4,
            pegsInSafeZone: 0,
            pegsInBullseye: 0
        };
        
        // Add to game state
        gameState.players.push(newPlayer);
        
        // Initialize pegs at start position
        if (typeof initializePegsForPlayer === 'function') {
            initializePegsForPlayer(newSlotIndex);
        }
        
        // Update UI
        if (window.GameUIMinimal) {
            window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
        }
        
        return newSlotIndex;
    }
    
    function denyJoinRequestById(requestId) {
        const requestIndex = pendingJoinRequests.findIndex(r => r.id === requestId);
        if (requestIndex === -1) return;
        
        const request = pendingJoinRequests[requestIndex];
        pendingJoinRequests.splice(requestIndex, 1);
        
        // Notify lobby server
        if (lobbyWebSocket && lobbyWebSocket.readyState === WebSocket.OPEN) {
            lobbyWebSocket.send(JSON.stringify({
                type: 'reject_late_join',
                user_id: requestId
            }));
        }
        
        console.log(`[Session] Denied join request from ${request.name}`);
        
        updateJoinRequestUI();
        
        // Show next notification if there are more requests
        if (pendingJoinRequests.length > 0) {
            showJoinRequestNotification(pendingJoinRequests[0]);
        }
    }
    
    function findAvailableBotSlot() {
        if (!gameState) return -1;
        
        // First, look for AI players (bots)
        for (let i = 0; i < gameState.players.length; i++) {
            if (gameState.players[i].isAI) {
                return i;
            }
        }
        
        // Then, look for eliminated players
        for (let i = 0; i < gameState.players.length; i++) {
            if (gameState.players[i].eliminated) {
                return i;
            }
        }
        
        return -1; // No available slots
    }
    
    // Expose join request functions globally
    window.addJoinRequest = addJoinRequest;
    window.approveJoinRequest = approveJoinRequest;
    window.denyJoinRequest = denyJoinRequest;
    window.approveJoinRequestById = approveJoinRequestById;
    window.approveJoinRequestWithSlot = approveJoinRequestWithSlot;
    window.denyJoinRequestById = denyJoinRequestById;
    window.getAvailableSlotInfo = getAvailableSlotInfo;
    window.createNewPlayerSlot = createNewPlayerSlot;
    
    // Handle incoming join request from server (WebSocket message)
    function handleServerJoinRequest(data) {
        if (!gameSessionSettings.isOrganizer) return;
        
        addJoinRequest(
            data.playerId || data.user_id,
            data.playerName || data.username,
            data.avatar || data.avatar_id || 'ğŸ‘¤'
        );
    }
    window.handleServerJoinRequest = handleServerJoinRequest;

    // ============================================================
    // TURN TIMER SYSTEM â€” 2 minute wait + 1 minute visible clock
    // ============================================================
    // Phase 1: 2 minutes silent wait (timer display hidden)
    // Phase 2: 1 minute visible countdown clock
    // On expire: replace with bot (or remove if organizer set no-bots)
    
    function startTurnTimer() {
        if (!gameSessionSettings.turnTimer) return;
        
        // Only use turn timer in multiplayer games with 2+ human players.
        // Solo play against bots doesn't need a timer.
        if (gameState && gameState.players) {
            const humanCount = gameState.players.filter(p => p && !p.isAI && !p.isBot).length;
            if (humanCount <= 1) return;
        }
        
        stopTurnTimer();
        
        const waitSeconds = gameSessionSettings.turnTimerWaitSeconds || 120;
        const clockSeconds = gameSessionSettings.turnTimerClockSeconds || 60;
        
        turnTimerState.active = true;
        turnTimerState.phase = 'wait';  // 'wait' then 'clock'
        turnTimerState.secondsRemaining = waitSeconds;
        turnTimerState.clockSeconds = clockSeconds;
        turnTimerState.isWarning = false;
        
        // Hide timer display during silent wait phase
        const timerDisplay = document.getElementById('turn-timer-display');
        const countdown = document.getElementById('turn-timer-countdown');
        const warning = document.getElementById('turn-timer-warning');
        const label = document.getElementById('turn-timer-label');
        
        if (timerDisplay) timerDisplay.style.display = 'none';
        if (warning) warning.style.display = 'none';
        if (countdown) countdown.classList.remove('warning', 'critical');
        
        turnTimerState.intervalId = setInterval(() => {
            turnTimerState.secondsRemaining--;
            
            if (turnTimerState.phase === 'wait') {
                // Silent phase â€” no visible UI
                if (turnTimerState.secondsRemaining <= 0) {
                    // Transition to visible clock phase
                    turnTimerState.phase = 'clock';
                    turnTimerState.secondsRemaining = turnTimerState.clockSeconds;
                    turnTimerState.isWarning = true;
                    
                    // Show the countdown clock
                    if (timerDisplay) timerDisplay.style.display = 'block';
                    if (label) label.textContent = 'Time Remaining';
                    if (warning) {
                        warning.textContent = 'âš ï¸ Make your move!';
                        warning.style.display = 'block';
                    }
                    if (countdown) countdown.classList.add('warning');
                    updateTurnTimerDisplay();
                }
            } else {
                // Visible clock phase
                updateTurnTimerDisplay();
                
                // Critical phase (last 15 seconds) â€” pulse red
                if (turnTimerState.secondsRemaining <= 15) {
                    if (countdown) countdown.classList.add('critical');
                    if (warning) warning.textContent = 'â° Hurry up!';
                }
                
                // Time fully expired
                if (turnTimerState.secondsRemaining <= 0) {
                    handleTurnTimerExpired();
                }
            }
        }, 1000);
    }
    
    function stopTurnTimer() {
        if (turnTimerState.intervalId) {
            clearInterval(turnTimerState.intervalId);
            turnTimerState.intervalId = null;
        }
        if (turnTimerState.waitTimeoutId) {
            clearTimeout(turnTimerState.waitTimeoutId);
            turnTimerState.waitTimeoutId = null;
        }
        turnTimerState.active = false;
        turnTimerState.phase = null;
        
        const timerDisplay = document.getElementById('turn-timer-display');
        if (timerDisplay) timerDisplay.style.display = 'none';
    }
    
    function updateTurnTimerDisplay() {
        const countdown = document.getElementById('turn-timer-countdown');
        if (!countdown) return;
        
        const mins = Math.floor(turnTimerState.secondsRemaining / 60);
        const secs = turnTimerState.secondsRemaining % 60;
        countdown.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function handleTurnTimerExpired() {
        stopTurnTimer();
        
        const currentIdx = gameState?.currentPlayerIndex;
        if (currentIdx === undefined) return;
        
        const player = gameState.players[currentIdx];
        if (!player || player.isAI) return;
        
        // Check organizer setting: bots allowed?
        if (gameSessionSettings.noBots) {
            // === NO BOTS MODE: Remove player entirely ===
            showBotAlert(
                `${player.name} Timed Out`,
                `${player.name} ran out of time and has been removed from the game. Their pegs have been cleared.`
            );
            removePlayerFromGame(currentIdx);
            console.log(`[TurnTimer] Player ${currentIdx} removed (no-bots mode)`);
        } else {
            // === BOTS ALLOWED: Replace with bot ===
            showBotAlert(
                'Time\'s Up!',
                `${player.name} ran out of time and has been replaced by a bot.`
            );
            replacePlayerWithBot(currentIdx);
            
            // Let the bot take over
            setTimeout(() => aiTakeTurn(), 1000);
            console.log(`[TurnTimer] Player ${currentIdx} replaced with bot`);
        }
    }
    
    function showBotAlert(title, message) {
        const alert = document.getElementById('bot-alert');
        const titleEl = document.getElementById('bot-alert-title');
        const msgEl = document.getElementById('bot-alert-message');
        
        if (alert && titleEl && msgEl) {
            titleEl.textContent = title;
            msgEl.textContent = message;
            alert.classList.add('visible');
            
            setTimeout(() => {
                alert.classList.remove('visible');
            }, 3000);
        }
    }
    
    // Expose functions globally
    window.showLeaveGameModal = showLeaveGameModal;
    window.closeLeaveGameModal = closeLeaveGameModal;
    window.confirmLeaveGame = confirmLeaveGame;
    window.returnToGame = returnToGame;
    window.toggleOrganizerMenu = toggleOrganizerMenu;
    window.closeOrganizerMenu = closeOrganizerMenu;
    window.bootPlayer = bootPlayer;
    window.initSessionSettings = initSessionSettings;
    window.startTurnTimer = startTurnTimer;
    window.stopTurnTimer = stopTurnTimer;

    // =================================================================
    // Game Chat System (Tournament/Guild Games)
    // =================================================================
    
    let gameChatState = {
        enabled: false,         // Chat available for this game type
        visible: true,          // Chat panel open
        optedOut: false,        // User opted out
        messages: [],           // Chat history
        unreadCount: 0,         // Unread messages when minimized
        blockedUsers: [],       // Blocked user IDs
        blockedByUsers: [],     // Users who blocked current user
        unblockCooldowns: {}    // Cooldown tracking
    };
    
    function initGameChat(gameType) {
        // Chat only for tournament and guild games
        gameChatState.enabled = (gameType === 'tournament' || gameType === 'guild');
        
        if (!gameChatState.enabled) {
            const panel = document.getElementById('game-chat-panel');
            const toggle = document.getElementById('game-chat-toggle');
            if (panel) panel.style.display = 'none';
            if (toggle) toggle.style.display = 'none';
            return;
        }
        
        // Load preferences
        gameChatState.optedOut = localStorage.getItem('ft_game_chat_opted_out') === 'true';
        
        // Load block cooldowns
        try {
            const stored = localStorage.getItem('ft_block_cooldowns');
            if (stored) {
                gameChatState.unblockCooldowns = JSON.parse(stored);
            }
        } catch(e) {}
        
        // Show chat panel
        updateGameChatUI();
    }
    
    function updateGameChatUI() {
        const panel = document.getElementById('game-chat-panel');
        const toggle = document.getElementById('game-chat-toggle');
        const active = document.getElementById('game-chat-active');
        const disabled = document.getElementById('game-chat-disabled');
        const optedOut = document.getElementById('game-chat-opted-out');
        
        if (!gameChatState.enabled) {
            if (panel) panel.style.display = 'none';
            if (toggle) toggle.style.display = 'none';
            return;
        }
        
        if (gameChatState.visible) {
            if (panel) panel.classList.add('visible');
            if (toggle) toggle.style.display = 'none';
            gameChatState.unreadCount = 0;
            updateChatUnreadBadge();
        } else {
            if (panel) panel.classList.remove('visible');
            if (toggle) toggle.style.display = 'flex';
        }
        
        // Show appropriate content
        if (active) active.style.display = gameChatState.optedOut ? 'none' : 'block';
        if (optedOut) optedOut.style.display = gameChatState.optedOut ? 'block' : 'none';
        if (disabled) disabled.style.display = 'none';
        
        // Update opt button
        const optBtn = document.getElementById('game-chat-opt-btn');
        if (optBtn) {
            optBtn.textContent = gameChatState.optedOut ? 'ğŸ”” Opt In' : 'ğŸ”‡ Opt Out';
        }
    }
    
    function toggleGameChat() {
        gameChatState.visible = true;
        gameChatState.unreadCount = 0;
        updateGameChatUI();
    }
    
    function minimizeGameChat() {
        gameChatState.visible = false;
        updateGameChatUI();
    }
    
    function toggleGameChatOptOut() {
        gameChatState.optedOut = !gameChatState.optedOut;
        localStorage.setItem('ft_game_chat_opted_out', gameChatState.optedOut ? 'true' : 'false');
        updateGameChatUI();
    }
    
    function showGameChatSettings() {
        const modal = document.getElementById('game-chat-settings-modal');
        if (modal) modal.style.display = 'flex';
    }
    
    function hideGameChatSettings() {
        const modal = document.getElementById('game-chat-settings-modal');
        if (modal) modal.style.display = 'none';
    }
    
    function showGameBlockedUsers() {
        hideGameChatSettings();
        // For now, show a simple alert - could expand to full modal
        alert('Blocked users management. Use the lobby to manage blocked users.');
    }
    
    function sendGameChatMessage() {
        if (!gameChatState.enabled || gameChatState.optedOut) return;
        
        const input = document.getElementById('game-chat-input');
        const message = input?.value?.trim();
        if (!message) return;
        
        // Send to server
        if (typeof GameStateBroadcaster !== 'undefined') {
            GameStateBroadcaster.sendAction({
                type: 'game_chat',
                message: message
            });
        }
        
        // Also call WebSocket send if available
        if (typeof window.sendToServer === 'function') {
            window.sendToServer({
                type: 'game_chat',
                message: message
            });
        }
        
        input.value = '';
    }
    
    function receiveGameChatMessage(data) {
        if (!gameChatState.enabled || gameChatState.optedOut) return;
        
        // Check if sender is blocked
        if (gameChatState.blockedUsers.includes(data.senderId)) return;
        if (gameChatState.blockedByUsers.includes(data.senderId)) return;
        
        const container = document.getElementById('game-chat-messages');
        if (!container) return;
        
        // Clear placeholder
        const placeholder = container.querySelector('div[style*="text-align: center"]');
        if (placeholder) placeholder.remove();
        
        const time = new Date(data.timestamp || Date.now()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        const msgEl = document.createElement('div');
        msgEl.className = 'game-chat-msg';
        msgEl.dataset.senderId = data.senderId;
        msgEl.innerHTML = `
            <span class="game-chat-sender ${data.isGuildmaster ? 'guildmaster' : ''}">
                ${escapeHtmlChat(data.senderName)}${data.isGuildmaster ? ' ğŸ‘‘' : ''}:
            </span>
            <span class="game-chat-text">${escapeHtmlChat(data.message)}</span>
            <span class="game-chat-time">${time}</span>
        `;
        
        container.appendChild(msgEl);
        container.scrollTop = container.scrollHeight;
        
        // Track unread if minimized
        if (!gameChatState.visible) {
            gameChatState.unreadCount++;
            updateChatUnreadBadge();
        }
        
        gameChatState.messages.push(data);
    }
    
    function updateChatUnreadBadge() {
        const badge = document.getElementById('chat-unread-badge');
        if (badge) {
            if (gameChatState.unreadCount > 0) {
                badge.textContent = gameChatState.unreadCount;
                badge.style.display = 'block';
            } else {
                badge.style.display = 'none';
            }
        }
    }
    
    function blockUserInGame(userId, userName) {
        // Check cooldown
        const cooldownEnd = gameChatState.unblockCooldowns[userId];
        if (cooldownEnd && Date.now() < cooldownEnd) {
            const hours = Math.ceil((cooldownEnd - Date.now()) / (1000 * 60 * 60));
            alert(`Must wait ${hours} hours to block this user again`);
            return;
        }
        
        gameChatState.blockedUsers.push(userId);
        
        // Remove their messages from view
        const messages = document.querySelectorAll(`.game-chat-msg[data-sender-id="${userId}"]`);
        messages.forEach(el => el.remove());
        
        // Send to server
        if (typeof window.sendToServer === 'function') {
            window.sendToServer({
                type: 'block_user',
                userId: userId
            });
        }
        
        console.log(`[Chat] Blocked user ${userName}`);
    }
    
    function escapeHtmlChat(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Expose game chat functions
    window.initGameChat = initGameChat;
    window.toggleGameChat = toggleGameChat;
    window.minimizeGameChat = minimizeGameChat;
    window.toggleGameChatOptOut = toggleGameChatOptOut;
    window.showGameChatSettings = showGameChatSettings;
    window.hideGameChatSettings = hideGameChatSettings;
    window.showGameBlockedUsers = showGameBlockedUsers;
    window.sendGameChatMessage = sendGameChatMessage;
    window.receiveGameChatMessage = receiveGameChatMessage;
    window.blockUserInGame = blockUserInGame;

    function aiTakeTurn() {
        console.log('[aiTakeTurn] Called, gameState:', !!gameState, 'winner:', gameState?.winner);
        if (!gameState || gameState.winner) return;
        
        const currentIdx = gameState.currentPlayerIndex;
        console.log('[aiTakeTurn] currentIdx:', currentIdx, 'isAI:', isAIPlayer(currentIdx));
        if (!isAIPlayer(currentIdx)) return;
        
        const playerName = gameState.players[currentIdx].name;
        console.log(`[aiTakeTurn] ${playerName} taking turn, phase:`, gameState.phase);
        
        // Show AI thinking
        showAIThinking(playerName);
        
        // Get entity-specific draw delay from ManifoldAI (or fall back to AI_CONFIG)
        let drawDelay = AI_CONFIG.drawDelay;
        if (window.ManifoldAI) {
            const entity = ManifoldAI.getEntity(currentIdx);
            if (entity) {
                drawDelay = entity.drawDelay;
                console.log(`[aiTakeTurn] ${entity.emoji} ${entity.archetype} drawDelay: ${drawDelay}ms`);
            }
        }
        
        // AI draws card - the onCardDrawn handler will highlight moves
        // and then aiSelectAndClickMove will be called after delay
        setTimeout(() => {
            console.log('[aiTakeTurn] After delay, phase:', gameState.phase, 'drawDelay was:', drawDelay);
            if (gameState.phase === 'draw') {
                console.log('[aiTakeTurn] Calling handleDrawCard(true)');
                handleDrawCard(true);  // true = called by AI
                // Note: The rest is handled by onCardDrawn which calls aiSelectAndClickMove
            } else {
                console.error('[aiTakeTurn] NOT in draw phase! Cannot draw. Phase is:', gameState.phase);
            }
        }, drawDelay);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AI DECISION ENGINE - Helix-style rule-based scoring system
    // Uses priority-weighted evaluation following ButterflyFX kernel pattern
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * AI Move Evaluation Rules - Truth Table Style
     * Each rule returns a score contribution. Higher total score = better move.
     * 
     * Rule Priority (Fibonacci-aligned weights):
     * - Level 6 (Weight 89): Win condition (winner hole)
     * - Level 5 (Weight 55): Safe zone progress  
     * - Level 4 (Weight 34): Cut opponent
     * - Level 3 (Weight 21): FastTrack/Bullseye entry
     * - Level 2 (Weight 13): Enter from holding
     * - Level 1 (Weight 8):  Position advantage
     * - Level 0 (Weight 5):  Random tiebreaker
     */
    const AI_MOVE_RULES = {
        // WIN CONDITION - Highest priority
        isWinnerHole: {
            weight: 89,
            evaluate: (move, context) => {
                return move.toHoleId.includes('winner') ? 1 : 0;
            }
        },
        
        // SAFE ZONE PROGRESS - Very high priority
        isSafeZoneMove: {
            weight: 55,
            evaluate: (move, context) => {
                if (!move.toHoleId.includes('safe')) return 0;
                // Higher safe zone number = closer to winning
                const parts = move.toHoleId.split('-');
                const safeNum = parseInt(parts[2]) || 1;
                return safeNum / 4; // 0.25 to 1.0
            }
        },
        
        // CUT OPPONENT - High priority
        isCutMove: {
            weight: 34,
            evaluate: (move, context) => {
                const cutTarget = findCutTargetAtHole(move.toHoleId);
                if (!cutTarget) return 0;
                // Extra value for cutting opponent close to their safe zone
                const victimPegsOnBoard = cutTarget.player.peg.filter(p => p.holeType !== 'holding').length;
                return 0.5 + (victimPegsOnBoard > 3 ? 0.5 : victimPegsOnBoard * 0.1);
            }
        },
        
        // BULLSEYE CUT - Very high priority for royal cards
        // Strategy: Use royal card to enter bullseye and cut opponent sitting there
        isBullseyeCut: {
            weight: 40,  // Higher than regular cut - bullseye is valuable position
            evaluate: (move, context) => {
                // Only applies to bullseye/center moves
                if (move.toHoleId !== 'center' && !move.isCenterOption) return 0;
                
                // Check if opponent is in bullseye
                const cutTarget = findCutTargetAtHole('center');
                if (!cutTarget) return 0;
                
                // High value: you get bullseye AND cut opponent
                // Even higher value if opponent was close to exiting
                const victimPeg = cutTarget.peg;
                if (victimPeg && victimPeg.eligibleForSafeZone) {
                    return 1.0;  // Max value - opponent was about to finish
                }
                return 0.8;  // Still great - took bullseye and cut
            }
        },
        
        // FASTTRACK ENTRY - High priority (bypasses most of the board)
        isFastTrackEntry: {
            weight: 25,  // Increased to ensure AI prioritizes FastTrack entry
            evaluate: (move, context) => {
                // FastTrack (not bullseye) is generally safe and valuable
                if (move.isFastTrackEntry === true) {
                    console.log(`ğŸ¤– [AI FT] FastTrack ENTRY option detected: ${move.toHoleId}, returning score 1.0`);
                    return 1.0;
                }
                // Penalize NON-entry when landing on ft-* (incentivize choosing FastTrack entry)
                if (move.toHoleId.startsWith('ft-') && !move.isFastTrackEntry && !context.peg?.onFasttrack) {
                    console.log(`ğŸ¤– [AI FT] FastTrack PASS-THROUGH option (not entering): ${move.toHoleId}, returning score -0.3`);
                    return -0.3;  // Slight penalty for NOT entering FastTrack when on ft-* hole
                }
                return 0;
            }
        },
        
        // FASTTRACK TRAVERSAL - Default preference is to stay on FT
        // BUT bots can choose to leave FT for strategic reasons:
        //   - To cut an opponent (difficulty-dependent)
        //   - To enter bullseye/center
        //   - When forced by 4-card (mustExitFasttrack)
        // Easy bots: NEVER leave FT voluntarily
        // Normal+: Leave FT to cut if strategic
        // Warpath: Will always leave if there's a cut available
        isFastTrackTraversal: {
            weight: 60,  // Higher than safe zone (55) for default FT preference
            evaluate: (move, context) => {
                // Only applies to pegs already ON FastTrack
                if (!context.peg?.onFasttrack) return 0;
                
                // Continuing on FastTrack ring (ft-* to ft-*)
                if (move.toHoleId.startsWith('ft-') && !move.isLeaveFastTrack) {
                    return 1.0;
                }
                
                // Leaving FastTrack â€” check if there's a strategic reason
                if (move.isLeaveFastTrack) {
                    const diffPreset = getDifficultyPreset();
                    
                    // Check if leaving FT lands on an opponent (cut opportunity)
                    const cutAtDest = typeof findCutTargetAtHole === 'function' 
                        ? findCutTargetAtHole(move.toHoleId) : null;
                    
                    if (cutAtDest && diffPreset.aiFTLeaveToCut) {
                        // Strategic reason to leave FT: CUT!
                        // Return positive score â€” the isCutMove rule will add MORE on top
                        console.log(`ğŸ¤– [AI FT] Leave FT FOR CUT at ${move.toHoleId} â€” allowing (difficulty: ${GAME_CONFIG.difficulty})`);
                        return 0.3;  // Slight positive â€” let isCutMove weight decide final priority
                    }
                    
                    // Entering bullseye from FT â€” check if cutting opponent there
                    if (move.toHoleId === 'center' || move.isCenterOption) {
                        const centerCut = typeof findCutTargetAtHole === 'function'
                            ? findCutTargetAtHole('center') : null;
                        if (centerCut) {
                            console.log(`ğŸ¤– [AI FT] Leave FT to CUT in BULLSEYE â€” high priority!`);
                            return 1.0;  // Must beat FT continue (1.0) â€” isBullseyeCut adds more
                        }
                        return 0.5;  // Empty bullseye is still a strong strategic position
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // WARPATH: Leave FT to POSITION against opponents
                    // even without an immediate cut. If any human opponent
                    // has a peg in home stretch, center, or FT â€” warpath
                    // bot exits FT to get on the outer track and hunt them.
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (GAME_CONFIG.difficulty === 'warpath' && gameState && gameState.players) {
                        let hasHuntTarget = false;
                        for (const opp of gameState.players) {
                            if (opp.index === context.player.index) continue;
                            if (isAIPlayer(opp.index)) continue;  // Only hunt humans
                            for (const op of opp.peg) {
                                if (op.holeType === 'holding') continue;
                                if (op.inHomeStretch || op.lockedToSafeZone || op.eligibleForSafeZone ||
                                    op.inBullseye || op.holeId === 'center' ||
                                    (op.onFasttrack && op.holeId?.startsWith('ft-'))) {
                                    hasHuntTarget = true;
                                    break;
                                }
                            }
                            if (hasHuntTarget) break;
                        }
                        if (hasHuntTarget) {
                            // Check if the leave-FT destination is closer to a target
                            const destHole = move.toHoleId;
                            let positionScore = 0;
                            for (const opp of gameState.players) {
                                if (opp.index === context.player.index || isAIPlayer(opp.index)) continue;
                                for (const op of opp.peg) {
                                    if (op.holeType === 'holding' || op.inBullseye) continue;
                                    if (op.inHomeStretch || op.lockedToSafeZone || op.eligibleForSafeZone) {
                                        const dist = getTrackDistance(destHole, op.holeId);
                                        if (dist !== null && dist >= 1 && dist <= 12) {
                                            positionScore = Math.max(positionScore, 0.6);
                                        }
                                    }
                                    if (op.onFasttrack && op.holeId?.startsWith('ft-')) {
                                        positionScore = Math.max(positionScore, 0.4);
                                    }
                                }
                            }
                            if (positionScore > 0) {
                                console.log(`ğŸ”¥ [WARPATH FT] Leaving FT to HUNT â€” positioning at ${move.toHoleId} (score: ${positionScore})`);
                                return positionScore;
                            }
                        }
                    }
                    
                    // No strategic reason â€” penalize leaving
                    console.log(`ğŸ¤– [AI FT] Leave FT with no cut target â€” penalized`);
                    return -0.5;
                }
                
                return 0;
            }
        },
        
        // BULLSEYE ENTRY - Risk/reward based on board state
        // Risky with many opponents out, safer with few
        isBullseyeEntry: {
            weight: 18,  // Slightly lower than FastTrack
            evaluate: (move, context) => {
                // Only applies to bullseye moves (not cutting - that's handled separately)
                if (move.toHoleId !== 'center' && !move.isCenterOption) return 0;
                
                // If cutting someone in bullseye, use isBullseyeCut rule instead
                const cutTarget = findCutTargetAtHole('center');
                if (cutTarget) return 0;  // Let isBullseyeCut handle this
                
                if (!gameState || !gameState.players) return 0.5;
                
                // Count total opponent pegs on the board (not in holding)
                let opponentPegsOnBoard = 0;
                for (const player of gameState.players) {
                    if (player.index === context.player.index) continue;
                    opponentPegsOnBoard += player.peg.filter(p => 
                        p.holeType !== 'holding' && !p.completedCircuit
                    ).length;
                }
                
                // Risk assessment:
                // 0-3 opponent pegs: Safe to enter (low chance of royal card hit)
                // 4-6 opponent pegs: Moderate risk
                // 7+ opponent pegs: High risk (someone likely to get royal)
                
                if (opponentPegsOnBoard <= 3) {
                    return 1.0;  // Go for it - few opponents can threaten
                } else if (opponentPegsOnBoard <= 6) {
                    return 0.5;  // Moderate value - some risk
                } else {
                    return 0.2;  // Low value - very risky with full board
                }
            }
        },
        
        // ENTER FROM HOLDING - Medium priority
        isEnterMove: {
            weight: 13,
            evaluate: (move, context) => {
                if (move.type !== 'enter') return 0;
                // Value having pegs on board
                const pegsOnBoard = context.player.peg.filter(p => p.holeType !== 'holding').length;
                return pegsOnBoard < 2 ? 1.0 : 0.5; // More valuable when few pegs deployed
            }
        },
        
        // STRATEGIC BACKWARD POSITIONING (for 4-card)
        // Key strategy: Position near home hole so next forward move enters safe zone
        isStrategicBackward: {
            weight: 15,  // Increased - backward positioning is important
            evaluate: (move, context) => {
                if (!context.isBackwardCard) return 0;
                const peg = context.player.peg.find(p => p.id === move.pegId);
                if (!peg) return 0;
                
                const boardPos = context.playerBoardPos;
                const destHoleId = move.toHoleId;
                
                // IDEAL POSITIONS after 4-card backward move:
                // 1. side-right-{boardPos}-* : Just past your home, moving forward will approach home
                // 2. outer-{boardPos}-* : On your section's outer track, close to home
                // 3. side-left-{boardPos}-* : Approaching home from the correct direction
                
                // Best: side-right holes on YOUR section (1-4 steps past home)
                // Moving forward from here approaches home from CLOCKWISE = safe zone eligible
                const sideRightMatch = destHoleId.match(/^side-right-(\d+)-(\d+)$/);
                if (sideRightMatch) {
                    const holePlayer = parseInt(sideRightMatch[1]);
                    const holeNum = parseInt(sideRightMatch[2]);
                    if (holePlayer === boardPos) {
                        // Perfect! side-right-{boardPos}-1 is best (closest to home)
                        return 1.0 - (holeNum - 1) * 0.1; // 1.0, 0.9, 0.8, 0.7
                    }
                }
                
                // Good: outer track on YOUR section
                const outerMatch = destHoleId.match(/^outer-(\d+)-(\d+)$/);
                if (outerMatch) {
                    const holePlayer = parseInt(outerMatch[1]);
                    const holeNum = parseInt(outerMatch[2]);
                    if (holePlayer === boardPos) {
                        // outer-{boardPos}-3 is closest to home
                        return 0.5 + (holeNum / 10); // 0.5, 0.6, 0.7, 0.8
                    }
                }
                
                // Okay: side-left on YOUR section (still approaching home)
                const sideLeftMatch = destHoleId.match(/^side-left-(\d+)-(\d+)$/);
                if (sideLeftMatch) {
                    const holePlayer = parseInt(sideLeftMatch[1]);
                    if (holePlayer === boardPos) {
                        return 0.4;
                    }
                }
                
                // Not on your section - less valuable
                return 0.1;
            }
        },
        
        // DEFENSIVE POSITIONING - Avoid vulnerable spots
        // Penalty for landing RIGHT IN FRONT of an opponent (they can cut you next turn)
        defensivePositioning: {
            weight: -20,  // Negative weight = penalty
            evaluate: (move, context) => {
                if (!gameState || !gameState.players) return 0;
                
                const destHoleId = move.toHoleId;
                // Skip safe zones, home holes, center - these are protected or special
                if (destHoleId.includes('safe') || destHoleId.includes('home') || 
                    destHoleId === 'center' || destHoleId.includes('winner')) return 0;
                
                let dangerScore = 0;
                
                // Check each opponent
                for (const opponent of gameState.players) {
                    if (opponent.index === context.player.index) continue;
                    
                    for (const oppPeg of opponent.peg) {
                        if (oppPeg.holeType === 'holding' || oppPeg.inBullseye) continue;
                        
                        // Get distance from opponent peg to our destination
                        const distance = getTrackDistance(oppPeg.holeId, destHoleId);
                        
                        // VERY DANGEROUS: 1-3 holes in front of opponent (easy cut)
                        if (distance >= 1 && distance <= 3) {
                            dangerScore = Math.max(dangerScore, 1.0);  // Max penalty
                        }
                        // DANGEROUS: 4-6 holes in front (one turn cut range)
                        else if (distance >= 4 && distance <= 6) {
                            dangerScore = Math.max(dangerScore, 0.6);
                        }
                        // MODERATE: 7-10 holes (still at risk with high cards)
                        else if (distance >= 7 && distance <= 10) {
                            dangerScore = Math.max(dangerScore, 0.3);
                        }
                    }
                }
                
                return dangerScore;
            }
        },
        
        // AVOID 4-CARD VULNERABILITY
        // Penalty for being exactly 4 holes BEHIND an opponent (they draw 4, you're cut)
        avoid4CardTrap: {
            weight: -15,
            evaluate: (move, context) => {
                if (!gameState || !gameState.players) return 0;
                
                const destHoleId = move.toHoleId;
                if (destHoleId.includes('safe') || destHoleId.includes('home') || 
                    destHoleId === 'center') return 0;
                
                let trapScore = 0;
                
                for (const opponent of gameState.players) {
                    if (opponent.index === context.player.index) continue;
                    
                    for (const oppPeg of opponent.peg) {
                        if (oppPeg.holeType === 'holding' || oppPeg.inBullseye) continue;
                        
                        // Distance from US to THEM (we are behind them)
                        const distance = getTrackDistance(destHoleId, oppPeg.holeId);
                        
                        // Exactly 4 holes behind = 4 card trap
                        if (distance === 4) {
                            trapScore = Math.max(trapScore, 1.0);
                        }
                        // 3 or 5 holes behind = slight risk
                        else if (distance === 3 || distance === 5) {
                            trapScore = Math.max(trapScore, 0.3);
                        }
                    }
                }
                
                return trapScore;
            }
        },
        
        // OFFENSIVE POSITIONING - Land just behind an opponent
        // Good spot: You might cut them on your next turn
        offensivePositioning: {
            weight: 8,
            evaluate: (move, context) => {
                if (!gameState || !gameState.players) return 0;
                
                const destHoleId = move.toHoleId;
                if (destHoleId.includes('safe') || destHoleId === 'center') return 0;
                
                let offenseScore = 0;
                
                for (const opponent of gameState.players) {
                    if (opponent.index === context.player.index) continue;
                    
                    for (const oppPeg of opponent.peg) {
                        if (oppPeg.holeType === 'holding' || oppPeg.inBullseye) continue;
                        
                        // Distance from us to them (we are behind)
                        const distance = getTrackDistance(destHoleId, oppPeg.holeId);
                        
                        // 1-3 holes behind = great position to cut with low card
                        if (distance >= 1 && distance <= 3) {
                            offenseScore = Math.max(offenseScore, 0.8);
                        }
                        // 4-7 holes behind = good position
                        else if (distance >= 4 && distance <= 7) {
                            offenseScore = Math.max(offenseScore, 0.5);
                        }
                    }
                }
                
                return offenseScore;
            }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WARPATH HUNTING â€” Dedicated warpath-only targeting AI
        // Every move is evaluated for how well it positions the bot
        // to TARGET opponent pegs, with priority on:
        //   1. Opponents in home stretch (about to win â€” must intercept)
        //   2. Opponents in center/bullseye (high-value position to steal)
        //   3. Opponents on FastTrack circuit (moving fast â€” disrupt them)
        //   4. Any opponent peg within striking range
        // This rule ONLY activates for warpath difficulty.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        warpathHunting: {
            weight: 70,  // Higher than FT traversal (60) â€” hunting overrides FT loyalty
            evaluate: (move, context) => {
                // ONLY active for warpath difficulty
                if (GAME_CONFIG.difficulty !== 'warpath') return 0;
                if (!gameState || !gameState.players) return 0;
                
                const destHoleId = move.toHoleId;
                // Can't target pegs in safe zone (protected)
                if (destHoleId.includes('safe') || destHoleId.includes('winner')) return 0;
                
                let huntScore = 0;
                
                for (const opponent of gameState.players) {
                    if (opponent.index === context.player.index) continue;
                    // Only hunt human players (skip fellow AI bots)
                    if (isAIPlayer(opponent.index)) continue;
                    
                    for (const oppPeg of opponent.peg) {
                        if (oppPeg.holeType === 'holding') continue;
                        
                        // â”€â”€ PRIORITY 1: Opponent in HOME STRETCH â”€â”€
                        // Pegs in home stretch are about to win. Any move that
                        // positions us to intercept them is top priority.
                        const oppInHomeStretch = oppPeg.inHomeStretch || oppPeg.lockedToSafeZone || oppPeg.eligibleForSafeZone;
                        
                        // â”€â”€ PRIORITY 2: Opponent in BULLSEYE/CENTER â”€â”€
                        const oppInCenter = oppPeg.inBullseye || oppPeg.holeId === 'center';
                        
                        // â”€â”€ PRIORITY 3: Opponent on FASTTRACK â”€â”€
                        const oppOnFT = oppPeg.onFasttrack && oppPeg.holeId?.startsWith('ft-');
                        
                        // Direct CUT â€” landing exactly on opponent
                        if (oppPeg.holeId === destHoleId) {
                            if (oppInHomeStretch) {
                                huntScore = Math.max(huntScore, 1.0);  // Maximum â€” derail their win
                                console.log(`ğŸ”¥ [WARPATH] DIRECT CUT on home-stretch peg at ${destHoleId}!`);
                            } else if (oppInCenter) {
                                huntScore = Math.max(huntScore, 0.95);
                                console.log(`ğŸ”¥ [WARPATH] DIRECT CUT on bullseye peg!`);
                            } else if (oppOnFT) {
                                huntScore = Math.max(huntScore, 0.9);
                                console.log(`ğŸ”¥ [WARPATH] DIRECT CUT on FT peg at ${destHoleId}!`);
                            } else {
                                huntScore = Math.max(huntScore, 0.8);
                            }
                            continue;
                        }
                        
                        // POSITIONING â€” how close does this move put us to the target?
                        // Skip center/FT pegs for distance calc (different track)
                        if (oppInCenter) {
                            // If we're moving to an ft-* hole, we can reach center with 1-hop
                            if (destHoleId.startsWith('ft-')) {
                                huntScore = Math.max(huntScore, 0.7);
                            }
                            continue;
                        }
                        
                        if (oppOnFT) {
                            // Positioning on an ft-* hole is good to target FT opponents
                            if (destHoleId.startsWith('ft-')) {
                                huntScore = Math.max(huntScore, 0.6);
                            }
                            continue;
                        }
                        
                        // Perimeter opponent â€” calculate approach distance
                        const distance = getTrackDistance(destHoleId, oppPeg.holeId);
                        if (distance === null || distance === undefined || distance < 0) continue;
                        
                        if (oppInHomeStretch) {
                            // Home stretch targets get HUGE bonus for positioning
                            if (distance >= 1 && distance <= 3) {
                                huntScore = Math.max(huntScore, 0.9);  // Kill range
                            } else if (distance >= 4 && distance <= 7) {
                                huntScore = Math.max(huntScore, 0.7);  // One-turn range
                            } else if (distance >= 8 && distance <= 12) {
                                huntScore = Math.max(huntScore, 0.5);  // Two-turn approach
                            }
                        } else {
                            // Regular opponents â€” standard tracking
                            if (distance >= 1 && distance <= 3) {
                                huntScore = Math.max(huntScore, 0.6);
                            } else if (distance >= 4 && distance <= 7) {
                                huntScore = Math.max(huntScore, 0.4);
                            }
                        }
                    }
                }
                
                return huntScore;
            }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 7 WILD CARD STRATEGIC DECISION SYSTEM
        // When card 7 is drawn, AI must decide optimal move distance (1-7)
        // and which peg to move. This rule provides strategic guidance.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        sevenCardStrategy: {
            weight: 30,  // High priority for 7 card decisions
            evaluate: (move, context) => {
                // Only applies to 7 wild card
                if (!context.currentCard || context.currentCard.rank !== '7') return 0;
                
                const peg = context.player.peg.find(p => p.id === move.pegId);
                if (!peg) return 0;
                
                let strategyScore = 0;
                const moveDistance = move.steps || 1;
                
                // â”€â”€ PRIORITY 1: FastTrack Entry (distance matters) â”€â”€
                // If peg can enter FastTrack, prefer the exact distance needed
                if (move.isFastTrackEntry) {
                    // Entering FastTrack is always good with 7 card
                    strategyScore += 0.9;
                    console.log(`ğŸ² [7-Card] FastTrack entry at distance ${moveDistance}: +0.9`);
                }
                
                // â”€â”€ PRIORITY 2: Safe Zone Entry (distance precision) â”€â”€
                // If peg is eligible for safe zone, prefer distance that enters it
                if (peg.eligibleForSafeZone && move.toHoleId.includes('safe')) {
                    strategyScore += 0.95;
                    console.log(`ğŸ² [7-Card] Safe zone entry at distance ${moveDistance}: +0.95`);
                }
                
                // â”€â”€ PRIORITY 3: Cutting Opponents (any distance works) â”€â”€
                const cutTarget = findCutTargetAtHole(move.toHoleId);
                if (cutTarget) {
                    // Cutting is valuable - distance doesn't matter much
                    strategyScore += 0.8;
                    console.log(`ğŸ² [7-Card] Cut opportunity at distance ${moveDistance}: +0.8`);
                }
                
                // â”€â”€ PRIORITY 4: Center/Bullseye Entry â”€â”€
                if (move.toHoleId === 'center' || move.isCenterOption) {
                    // Check if opponent is there (handled by isBullseyeCut)
                    const centerCut = findCutTargetAtHole('center');
                    if (!centerCut) {
                        // Empty bullseye - moderate value
                        strategyScore += 0.6;
                        console.log(`ğŸ² [7-Card] Bullseye entry at distance ${moveDistance}: +0.6`);
                    }
                }
                
                // â”€â”€ PRIORITY 5: Exit FastTrack to Safe Zone â”€â”€
                if (peg.onFasttrack && move.toHoleId.includes('safe')) {
                    // Exiting FT directly to safe zone is excellent
                    strategyScore += 0.85;
                    console.log(`ğŸ² [7-Card] FT exit to safe zone at distance ${moveDistance}: +0.85`);
                }
                
                // â”€â”€ PRIORITY 6: Stay on FastTrack (prefer longer distances) â”€â”€
                if (peg.onFasttrack && move.toHoleId.startsWith('ft-') && !move.isLeaveFastTrack) {
                    // Longer moves on FT are better (cover more ground)
                    const ftBonus = moveDistance / 7 * 0.5;  // 0.07 to 0.5
                    strategyScore += ftBonus;
                    console.log(`ğŸ² [7-Card] FT traversal distance ${moveDistance}: +${ftBonus.toFixed(2)}`);
                }
                
                // â”€â”€ PRIORITY 7: Avoid Wasting Movement â”€â”€
                // Penalize very short moves (1-2) unless there's a strategic reason
                if (moveDistance <= 2 && !cutTarget && !move.isFastTrackEntry && 
                    !move.toHoleId.includes('safe') && move.toHoleId !== 'center') {
                    strategyScore -= 0.3;
                    console.log(`ğŸ² [7-Card] Short move (${moveDistance}) with no strategy: -0.3`);
                }
                
                // â”€â”€ PRIORITY 8: Maximize Distance (when no special targets) â”€â”€
                // If no strategic reason, prefer longer moves (cover more ground)
                if (strategyScore === 0) {
                    const distanceBonus = moveDistance / 7 * 0.4;  // 0.06 to 0.4
                    strategyScore += distanceBonus;
                    console.log(`ğŸ² [7-Card] Distance bonus (${moveDistance}): +${distanceBonus.toFixed(2)}`);
                }
                
                // â”€â”€ PRIORITY 9: Peg Selection (which peg to move) â”€â”€
                // Prefer moving pegs that are:
                // - Closest to safe zone (about to finish)
                // - On FastTrack (maximize FT advantage)
                // - In vulnerable positions (escape danger)
                
                if (peg.eligibleForSafeZone) {
                    strategyScore += 0.2;  // Prioritize finishing pegs
                }
                
                if (peg.onFasttrack) {
                    strategyScore += 0.15;  // Keep FT pegs moving
                }
                
                // Check if peg is in danger (opponent nearby)
                if (gameState && gameState.players) {
                    for (const opponent of gameState.players) {
                        if (opponent.index === context.player.index) continue;
                        for (const oppPeg of opponent.peg) {
                            if (oppPeg.holeType === 'holding') continue;
                            const distance = getTrackDistance(oppPeg.holeId, peg.holeId);
                            if (distance >= 1 && distance <= 6) {
                                // Peg is in danger - prioritize moving it
                                strategyScore += 0.25;
                                console.log(`ğŸ² [7-Card] Peg in danger, moving to escape: +0.25`);
                                break;
                            }
                        }
                    }
                }
                
                return strategyScore;
            }
        },
        
        // FORWARD PROGRESS - Base priority
        forwardProgress: {
            weight: 5,
            evaluate: (move, context) => {
                if (context.isBackwardCard) return 0;
                // More steps = generally better
                return Math.min((move.steps || 1) / 10, 1);
            }
        },
        
        // RANDOM TIEBREAKER - Fibonacci(3)
        randomTiebreaker: {
            weight: 2,
            evaluate: (move, context) => {
                return Math.random() * 0.1; // Small random factor
            }
        }
    };
    
    /**
     * AI Reaction System - AI sends emoji reactions based on turn outcomes
     * Called after each move to let AI express emotions
     */
    function aiSendReaction(move, cutPeg, entryFlags) {
        if (!AI_REACTIONS.enabled) return;
        if (!gameState) return;
        
        // Get the player who just made the move
        const movingPlayer = gameState.currentPlayer;
        const movingPlayerIdx = movingPlayer.index;
        const isMovingPlayerAI = isAIPlayer(movingPlayerIdx);
        const isMovingPlayerHuman = !isMovingPlayerAI;
        const difficulty = GAME_CONFIG.difficulty || 'easy';
        const isWarpath = difficulty === 'warpath';
        
        // Helper: pick random from array
        const pick = arr => arr[Math.floor(Math.random() * arr.length)];
        
        // Helper: get bot name for chat bubbles
        const getBotName = (playerIdx) => {
            const player = gameState.players?.[playerIdx];
            if (player?.name) {
                // Strip emoji prefix for cleaner chat (icon is in name like "ğŸ–¥ï¸ Turing")
                return player.name.replace(/^[^\w\s]+\s*/, '').trim() || player.name;
            }
            return 'Bot';
        };
        
        // â”€â”€ ManifoldAI Adaptation: shift entity's position on the surface â”€â”€
        if (window.ManifoldAI) {
            if (isMovingPlayerAI) {
                if (cutPeg) ManifoldAI.adaptEntity(movingPlayerIdx, 'made_cut');
                if (entryFlags.enteredFasttrack) ManifoldAI.adaptEntity(movingPlayerIdx, 'entered_fasttrack');
                if (move.toHoleId?.includes('safe-')) ManifoldAI.adaptEntity(movingPlayerIdx, 'entered_safe');
            }
            // Victim adaptation: AI player that got cut shifts toward survivor mode
            if (cutPeg && isAIPlayer(cutPeg.player?.index)) {
                ManifoldAI.adaptEntity(cutPeg.player.index, 'was_cut');
            }
        }
        
        // Random chance to react (don't react every time â€” but chat bubbles have own probability)
        const shouldReact = Math.random() <= AI_REACTIONS.probability;
        const shouldChat = Math.random() <= 0.45; // 45% chance of chat bubble (less frequent than emoji)
        
        if (!shouldReact && !shouldChat) return;
        
        // Small delay so reaction feels more natural
        const reactionDelay = 300 + Math.random() * 500;
        const chatDelay = reactionDelay + 400 + Math.random() * 600; // Chat comes slightly after emoji
        
        setTimeout(() => {
            let reactionList = null;
            let chatList = null;
            let chatBotIdx = null; // Which bot should "say" the message
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AI MADE THE MOVE â€” check what happened
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (isMovingPlayerAI) {
                if (cutPeg && !isAIPlayer(cutPeg.player?.index)) {
                    // AI cut a HUMAN â€” playful/sportsmanlike reaction
                    reactionList = isWarpath ? AI_REACTIONS.warpathCut : AI_REACTIONS.cut;
                    chatList = isWarpath ? AI_CHAT_MESSAGES.warpathCut : AI_CHAT_MESSAGES.cut;
                    chatBotIdx = movingPlayerIdx;
                    console.log(`ğŸ¤– AI Player ${movingPlayerIdx} playfully reacting to cutting human!`);
                } else if (cutPeg && isAIPlayer(cutPeg.player?.index)) {
                    // AI cut another AI â€” just a small celebration, no chat needed
                    reactionList = AI_REACTIONS.positive;
                    console.log(`ğŸ¤– AI Player ${movingPlayerIdx} cut fellow AI â€” small celebration`);
                } else if (entryFlags.enteredFasttrack || entryFlags.enteredBullseye) {
                    // AI entered special area
                    reactionList = AI_REACTIONS.special;
                    chatList = AI_CHAT_MESSAGES.selfCelebrate;
                    chatBotIdx = movingPlayerIdx;
                    console.log(`ğŸ¤– AI Player ${movingPlayerIdx} reacting to special move!`);
                } else if (move.toHoleId?.includes('safe-') || move.toHoleId?.includes('winner')) {
                    // AI reached safe zone or winner
                    reactionList = AI_REACTIONS.positive;
                    chatList = AI_CHAT_MESSAGES.selfCelebrate;
                    chatBotIdx = movingPlayerIdx;
                    console.log(`ğŸ¤– AI Player ${movingPlayerIdx} celebrating safe/winner!`);
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HUMAN MADE THE MOVE â€” bots react with encouragement!
            // This is the heart of the warmth: bots cheer for humans
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (isMovingPlayerHuman) {
                if (cutPeg && isAIPlayer(cutPeg.player?.index)) {
                    // Human cut a bot â€” bot reacts with good sportsmanship
                    const victimIdx = cutPeg.player.index;
                    reactionList = AI_REACTIONS.negative;
                    chatList = isWarpath ? AI_CHAT_MESSAGES.warpathGotCut : AI_CHAT_MESSAGES.gotCut;
                    chatBotIdx = victimIdx;
                    console.log(`ğŸ¤– AI Player ${victimIdx} reacting to being cut by human â€” good sport!`);
                } else if (entryFlags.enteredFasttrack || entryFlags.enteredBullseye) {
                    // Human entered FT or bullseye â€” bots are impressed!
                    reactionList = AI_REACTIONS.encouragement;
                    chatList = AI_CHAT_MESSAGES.encouragement;
                    // Random AI reacts
                    chatBotIdx = AI_CONFIG.players[Math.floor(Math.random() * AI_CONFIG.players.length)];
                    console.log(`ğŸ¤– AI cheering human's FT/bullseye entry!`);
                } else if (move.toHoleId?.includes('safe-')) {
                    // Human reached safe zone â€” bots acknowledge
                    if (Math.random() < 0.5) { // Only sometimes â€” don't overdo it
                        reactionList = AI_REACTIONS.encouragement;
                        chatList = AI_CHAT_MESSAGES.encouragement;
                        chatBotIdx = AI_CONFIG.players[Math.floor(Math.random() * AI_CONFIG.players.length)];
                        console.log(`ğŸ¤– AI acknowledging human's safe zone entry`);
                    }
                } else if (move.toHoleId?.includes('winner')) {
                    // Human scored a peg â€” bots cheer/impressed
                    reactionList = AI_REACTIONS.encouragement;
                    chatList = AI_CHAT_MESSAGES.encouragement;
                    chatBotIdx = AI_CONFIG.players[Math.floor(Math.random() * AI_CONFIG.players.length)];
                    console.log(`ğŸ¤– AI cheering human's winning peg!`);
                }
            }
            
            // Send emoji reaction
            if (shouldReact && reactionList && reactionList.length > 0) {
                const reaction = pick(reactionList);
                console.log(`ğŸ¤– AI sending reaction: ${reaction.emoji} (${reaction.name})`);
                sendDesktopReaction(reaction.emoji, reaction.name);
            }
            
            // Send chat bubble (with its own delay for natural feel)
            if (shouldChat && chatList && chatList.length > 0 && chatBotIdx !== null) {
                setTimeout(() => {
                    const msg = pick(chatList);
                    const name = getBotName(chatBotIdx);
                    console.log(`ğŸ’¬ AI Chat: [${name}] "${msg}"`);
                    aiSendChatBubble(msg, name);
                }, chatDelay - reactionDelay);
            }
        }, reactionDelay);
    }
    
    /**
     * Evaluate all moves and return sorted by score (best first)
     */
    function evaluateMoves(moves, player, currentCard) {
        if (!moves || moves.length === 0) return [];
        
        const playerBoardPos = player.boardPosition;
        const isBackwardCard = currentCard && currentCard.direction === 'backward';
        const difficultyPreset = getDifficultyPreset();
        
        const scoredMoves = moves.map(move => {
            const peg = player.peg.find(p => p.id === move.pegId);
            const context = {
                player,
                peg,
                currentCard,
                playerBoardPos,
                isBackwardCard
            };
            
            // Apply all rules and sum weighted scores
            // Adjust weights based on difficulty
            let totalScore = 0;
            const ruleScores = {};
            
            for (const [ruleName, rule] of Object.entries(AI_MOVE_RULES)) {
                const rawScore = rule.evaluate(move, context);
                let weight = rule.weight;
                
                // DIFFICULTY SCALING: Apply strategy multipliers based on difficulty
                switch (ruleName) {
                    case 'isCutMove':
                        weight = rule.weight * difficultyPreset.aiCutPriority;
                        
                        // SPECIAL: Joker backward move uses same metrics as regular cuts
                        const isJokerBackward = move.type === 'joker_backward';
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // EASY: NEVER target opponents. Only cut when it is
                        // the SOLE legal move available.
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        if (GAME_CONFIG.difficulty === 'easy' && rawScore > 0) {
                            const hasNonCutMoves = moves.some(m => !findCutTargetAtHole(m.toHoleId) && m.type !== 'joker_backward');
                            if (hasNonCutMoves) {
                                weight = -100;  // Strongly avoid â€” only land on opponent if no other choice
                            } else {
                                weight = 1;  // Sole option â€” reluctantly accept
                            }
                            // Apply same penalty to Joker backward
                            if (isJokerBackward && hasNonCutMoves) {
                                weight = -100;
                            }
                        }
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // NORMAL: Cut when strategic (beneficial to progress).
                        // Default weight (1.0x) â€” balanced decision.
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // (No special logic â€” just uses aiCutPriority: 1.0)
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // HARD: Target opponents whenever it's an option.
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        if (GAME_CONFIG.difficulty === 'hard' && rawScore > 0) {
                            weight = rule.weight * 3.0;
                            const cutTarget = findCutTargetAtHole(move.toHoleId);
                            if (cutTarget) {
                                const victimPegsInSafe = cutTarget.player.peg.filter(p => 
                                    p.holeId && p.holeId.includes('safe')
                                ).length;
                                if (victimPegsInSafe > 0) weight += 20;
                            }
                            // Joker backward gets EXTRA bonus for being sneaky
                            if (isJokerBackward) {
                                weight += 15;  // Bonus for the surprise factor!
                            }
                        }
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // EXPERT: Actively hunts cuts + optimal positioning.
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        if (GAME_CONFIG.difficulty === 'expert' && rawScore > 0) {
                            weight = rule.weight * 4.0;
                            const cutTarget = findCutTargetAtHole(move.toHoleId);
                            if (cutTarget) {
                                const victimPegsInSafe = cutTarget.player.peg.filter(p => 
                                    p.holeId && p.holeId.includes('safe')
                                ).length;
                                if (victimPegsInSafe > 0) weight += 30;
                            }
                            // Joker backward gets EXTRA bonus for tactical brilliance
                            if (isJokerBackward) {
                                weight += 25;  // Expert loves the tactical surprise!
                            }
                        }
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // WARPATH: Cutting is the #1 GOAL. Will sacrifice
                        // own progress to send opponents home. The main
                        // objective is to land on opponents, even if it's
                        // not in the bot's own strategic interest.
                        // Still must be a LEGAL move.
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        if (GAME_CONFIG.difficulty === 'warpath' && rawScore > 0) {
                            weight = 100;  // Higher than almost everything except winner hole (89)
                            const cutTarget = findCutTargetAtHole(move.toHoleId);
                            if (cutTarget) {
                                const victimPegsInSafe = cutTarget.player.peg.filter(p => 
                                    p.holeId && p.holeId.includes('safe')
                                ).length;
                                // Extra obsession points for cutting leaders
                                weight += victimPegsInSafe * 15;
                            }
                            // Joker backward is WARPATH'S DREAM - ultimate aggression
                            if (isJokerBackward) {
                                weight += 50;  // MASSIVE bonus - this is peak warpath!
                            }
                        }
                        break;
                    case 'isBullseyeCut':
                        weight = rule.weight * difficultyPreset.aiBullseyeCutPriority;
                        break;
                    case 'defensivePositioning':
                    case 'avoid4CardTrap':
                        weight = rule.weight * difficultyPreset.aiDefensiveAwareness;
                        break;
                    case 'offensivePositioning':
                        weight = rule.weight * difficultyPreset.aiOffensiveAwareness;
                        break;
                    case 'warpathHunting':
                        // Only applies to warpath â€” weight is already 0 for other difficulties
                        // via the evaluate() returning 0
                        break;
                    case 'isStrategicBackward':
                        weight = rule.weight * difficultyPreset.ai4CardStrategy;
                        break;
                    case 'isFastTrackEntry':
                    case 'isBullseyeEntry':
                        weight = rule.weight * difficultyPreset.aiFastTrackPriority;
                        break;
                    case 'isFastTrackTraversal':
                        // FT traversal preference scaled by difficulty
                        // Easy/Normal: Stay on FT (high weight)
                        // Hard+: Will leave FT to cut (lower FT loyalty)
                        // Warpath: FT is secondary to hunting (low weight)
                        weight = rule.weight * difficultyPreset.aiFastTrackPriority;
                        // Ensure minimum weight so FT is still generally preferred
                        if (weight < 20) weight = 20;
                        break;
                    case 'randomTiebreaker':
                        weight = rule.weight + (difficultyPreset.aiRandomFactor * 10);
                        break;
                }
                
                const weightedScore = rawScore * weight;
                ruleScores[ruleName] = { raw: rawScore, weighted: weightedScore };
                totalScore += weightedScore;
            }
            
            return {
                move,
                score: totalScore,
                ruleScores
            };
        });
        
        // Sort by score descending
        scoredMoves.sort((a, b) => b.score - a.score);
        
        // Log decision tree for debugging
        console.log(`ğŸ¤– [AI Decision Tree] Difficulty=${GAME_CONFIG.difficulty}, cutPriority=${difficultyPreset.aiCutPriority}`);
        scoredMoves.slice(0, 5).forEach((sm, i) => {
            const topRules = Object.entries(sm.ruleScores)
                .filter(([_, v]) => v.weighted > 0)
                .sort((a, b) => b[1].weighted - a[1].weighted)
                .slice(0, 3)
                .map(([name, v]) => `${name}:${v.weighted.toFixed(1)}`)
                .join(', ');
            console.log(`  ${i+1}. ${sm.move.toHoleId} (score: ${sm.score.toFixed(1)}) [${topRules}]`);
        });
        
        return scoredMoves;
    }
    
    /**
     * Select best move using evaluation system
     */
    /**
     * Build rule-evaluator map from AI_MOVE_RULES.
     * This extracts just the evaluate() functions so ManifoldAI can apply
     * its own manifold-derived weights instead of the hardcoded Fibonacci weights.
     */
    function getManifoldRuleEvaluators() {
        const evaluators = {};
        for (const [ruleName, rule] of Object.entries(AI_MOVE_RULES)) {
            evaluators[ruleName] = rule.evaluate;
        }
        return evaluators;
    }

    /**
     * Build game-helper functions map for ManifoldAI
     */
    function getManifoldGameHelpers() {
        return {
            findCutTargetAtHole,
            getTrackDistance,
            calculateMovesForPegRange,
            getPegTrackProgress,
            getPegNumber: typeof getPegNumber === 'function' ? getPegNumber : (id) => id,
            gameState: gameState,
        };
    }

    function aiSelectBestMove() {
        if (!gameState || gameState.winner) return null;
        if (legalMoves.length === 0) return null;
        
        const player = gameState.currentPlayer;
        const currentCard = gameState.currentCard;
        const playerIdx = gameState.currentPlayerIndex;
        
        // â”€â”€ ManifoldAI Path: Use geometric surface for decision-making â”€â”€
        if (window.ManifoldAI && AI_CONFIG.useManifold) {
            const entity = ManifoldAI.getEntity(playerIdx);
            if (entity) {
                try {
                    const ruleEvaluators = getManifoldRuleEvaluators();
                    const gameHelpers = getManifoldGameHelpers();
                    const bestMove = ManifoldAI.selectBestMove(
                        entity, legalMoves, player, currentCard,
                        ruleEvaluators, gameHelpers
                    );
                    if (bestMove) return bestMove;
                    console.warn(`${entity.emoji} ManifoldAI returned null â€” falling back to legacy`);
                } catch (err) {
                    console.error(`${entity.emoji} ManifoldAI error:`, err);
                }
            }
        }
        
        // â”€â”€ Legacy Path: Original weighted evaluation â”€â”€
        try {
            const scoredMoves = evaluateMoves(legalMoves, player, currentCard);
            
            if (scoredMoves.length === 0) {
                console.warn('ğŸ¤– evaluateMoves returned empty array');
                return null;
            }
            
            // Return the highest scored move
            return scoredMoves[0].move;
        } catch (error) {
            console.error('ğŸ¤– Error in AI move evaluation:', error);
            return null; // Fallback will be used in aiSelectAndClickMove
        }
    }
    
    function aiSelectMove() {
        if (!gameState || gameState.winner) return;
        if (!isAIPlayer(gameState.currentPlayerIndex)) return;
        
        // Hide thinking indicator
        hideAIThinking();
        
        if (legalMoves.length === 0) return;
        
        // Use evaluation system to pick best move
        const selectedMove = aiSelectBestMove();
        
        // Execute the selected move
        if (selectedMove) {
            console.log('ğŸ¤– AI executing best move:', selectedMove.toHoleId, selectedMove);
            clearHighlights();
            
            // 7 card is now WILD - AI uses normal move execution
            // No special split logic needed
            animatePegMove(selectedMove, () => {
                gameState.executeMove(selectedMove);
            });
        }
    }
    
    // AI selects a move and simulates clicking on the destination hole
    function aiSelectAndClickMove() {
        console.log('ğŸ¤– aiSelectAndClickMove called, legalMoves:', legalMoves.length);
        
        if (!gameState || gameState.winner) {
            console.log('ğŸ¤– aiSelectAndClickMove: Game over or no state');
            return;
        }
        if (!isAIPlayer(gameState.currentPlayerIndex)) {
            console.log('ğŸ¤– aiSelectAndClickMove: Not AI player turn');
            return;
        }
        
        // CRITICAL: AI never uses split mode â€” ensure it's reset
        if (splitMoveState && splitMoveState.active) {
            console.warn('ğŸ¤– AI found stale splitMoveState.active=true â€” resetting');
            resetSplitMoveState();
        }
        
        hideAIThinking();
        
        if (legalMoves.length === 0) {
            console.log('ğŸ¤– aiSelectAndClickMove: No legal moves - skipping turn');
            gameState.skipTurn();
            return;
        }
        
        // Safety timeout: if AI hasn't executed within 5s, force a move
        const safetyTimer = setTimeout(() => {
            console.error('ğŸ¤– AI SAFETY TIMEOUT: Forcing move after 5s');
            if (gameState && gameState.phase === 'play' && legalMoves.length > 0) {
                clearHighlights();
                executeMoveDirectly(legalMoves[0]);
            } else if (gameState && gameState.phase === 'play') {
                gameState.skipTurn();
            }
        }, 5000);
        
        // Use the unified evaluation system to select best move
        let selectedMove = null;
        try {
            selectedMove = aiSelectBestMove();
        } catch (err) {
            console.error('ğŸ¤– AI evaluation CRASHED:', err);
        }
        
        // FALLBACK: If AI evaluation failed, pick the best available move intelligently
        if (!selectedMove && legalMoves.length > 0) {
            console.warn('ğŸ¤– AI evaluation returned null - using smart fallback');
            const card = gameState.currentCard;
            
            // 7-card is split-only (handled by aiExecuteSplit), should never reach here
            selectedMove = legalMoves[0];
        }
        
        // Execute the move
        clearTimeout(safetyTimer);
        if (selectedMove) {
            console.log('ğŸ¤– AI clicking on hole:', selectedMove.toHoleId, 'with flags:', {
                isFastTrackEntry: selectedMove.isFastTrackEntry,
                isCenterOption: selectedMove.isCenterOption,
                isLeaveFastTrack: selectedMove.isLeaveFastTrack,
                steps: selectedMove.steps
            });
            
            clearHighlights();
            executeMoveDirectly(selectedMove);
        } else {
            console.error('ğŸ¤– AI has no valid move despite legalMoves existing - forcing skip');
            gameState.skipTurn();
        }
    }
    
    /**
     * AI 7-Card Split Decision System
     * Evaluates all possible split combinations to find the optimal split.
     * 
     * A 7 card can be split between 2 pegs: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1
     * The AI evaluates each combination and picks the one with highest combined score.
     * 
     * Difficulty affects split decisions:
     * - Easy: Prefers simple splits, avoids cuts unless forced
     * - Intermediate: Balanced strategy, cuts when beneficial
     * - Hard: Actively seeks cut opportunities in splits
     */
    function aiEvaluate7CardSplit(player) {
        const difficultyPreset = getDifficultyPreset();
        console.log(`ğŸ¤– [AI 7-Split] Evaluating split options, difficulty=${GAME_CONFIG.difficulty}`);
        
        // Find all active pegs (not in holding, not completed)
        const activePegs = player.peg.filter(p => 
            p.holeType !== 'holding' && !p.completedCircuit && p.holeId
        );
        
        if (activePegs.length === 0) {
            console.log('ğŸ¤– [AI 7-Split] No active pegs for split');
            return null;
        }
        
        if (activePegs.length === 1) {
            // Only one peg - must use all 7 on it
            console.log('ğŸ¤– [AI 7-Split] Only one peg - doing full 7 move');
            return null; // Use normal flow
        }
        
        // Generate all valid split combinations
        const splitCombinations = [];
        const splitRanges = [[1, 6], [2, 5], [3, 4], [4, 3], [5, 2], [6, 1]];
        
        // Create mock card for move evaluation
        const mockCard7 = { movement: 7, direction: 'clockwise', canSplit: true };
        
        for (const peg1 of activePegs) {
            for (const peg2 of activePegs) {
                if (peg1.id === peg2.id) continue; // Must use 2 different pegs
                
                for (const [steps1, steps2] of splitRanges) {
                    // Calculate destinations for each peg
                    const dests1 = calculateMovesForPegRange(peg1, steps1, steps1);
                    const dests2 = calculateMovesForPegRange(peg2, steps2, steps2);
                    
                    if (dests1.length === 0 || dests2.length === 0) continue;
                    
                    // Evaluate each combination of destinations
                    for (const move1 of dests1) {
                        for (const move2 of dests2) {
                            // Score each move using AI rules
                            const context1 = { player, peg: peg1, currentCard: mockCard7, playerBoardPos: player.boardPosition, isBackwardCard: false };
                            const context2 = { player, peg: peg2, currentCard: mockCard7, playerBoardPos: player.boardPosition, isBackwardCard: false };
                            
                            let score1 = 0, score2 = 0;
                            
                            // Apply all AI_MOVE_RULES
                            for (const [ruleName, rule] of Object.entries(AI_MOVE_RULES)) {
                                let weight = rule.weight;
                                
                                // Apply difficulty scaling for cuts
                                if (ruleName === 'isCutMove') {
                                    weight = rule.weight * difficultyPreset.aiCutPriority;
                                    
                                    // Hard mode: Always aggressively seeks cuts even if suboptimal
                                    if (GAME_CONFIG.difficulty === 'hard') {
                                        const hasCut1 = findCutTargetAtHole(move1.toHoleId);
                                        const hasCut2 = findCutTargetAtHole(move2.toHoleId);
                                        if (hasCut1 || hasCut2) {
                                            // Hard mode actively hunts for splits that enable cuts
                                            weight = rule.weight * 3.0;
                                        }
                                    }
                                    
                                    // Intermediate mode: Cut only when strategic (opponent near winning)
                                    if (GAME_CONFIG.difficulty === 'intermediate') {
                                        const cutTarget1 = findCutTargetAtHole(move1.toHoleId);
                                        const cutTarget2 = findCutTargetAtHole(move2.toHoleId);
                                        if (cutTarget1 || cutTarget2) {
                                            // Check if target is in safe zone or near winning
                                            const targetPeg1 = cutTarget1 ? cutTarget1.peg : null;
                                            const targetPeg2 = cutTarget2 ? cutTarget2.peg : null;
                                            const isStrategicCut = (targetPeg1 && getPegTrackProgress(targetPeg1) >= 300) ||
                                                                   (targetPeg2 && getPegTrackProgress(targetPeg2) >= 300);
                                            if (isStrategicCut) {
                                                // Target is on fast track or beyond - strategic cut
                                                weight = rule.weight * 2.0;
                                            } else {
                                                // Not strategic - normal weight
                                                weight = rule.weight * 1.0;
                                            }
                                        }
                                    }
                                    
                                    // Easy mode: discourage cuts unless no other option
                                    if (GAME_CONFIG.difficulty === 'easy') {
                                        weight = rule.weight * 0.1;
                                    }
                                }
                                
                                score1 += rule.evaluate(move1, context1) * weight;
                                score2 += rule.evaluate(move2, context2) * weight;
                            }
                            
                            const combinedScore = score1 + score2;
                            
                            splitCombinations.push({
                                peg1: peg1,
                                peg2: peg2,
                                move1: move1,
                                move2: move2,
                                steps1: steps1,
                                steps2: steps2,
                                score1: score1,
                                score2: score2,
                                combinedScore: combinedScore,
                                hasCut: findCutTargetAtHole(move1.toHoleId) || findCutTargetAtHole(move2.toHoleId)
                            });
                        }
                    }
                }
            }
        }
        
        if (splitCombinations.length === 0) {
            console.log('ğŸ¤– [AI 7-Split] No valid split combinations found');
            return null;
        }
        
        // Sort by combined score (highest first)
        splitCombinations.sort((a, b) => b.combinedScore - a.combinedScore);
        
        // Log top 3 options
        console.log(`ğŸ¤– [AI 7-Split] Found ${splitCombinations.length} combinations. Top 3:`);
        splitCombinations.slice(0, 3).forEach((combo, i) => {
            const peg1Num = getPegNumber(combo.peg1.id);
            const peg2Num = getPegNumber(combo.peg2.id);
            console.log(`  ${i+1}. Peg#${peg1Num}(${combo.steps1}) + Peg#${peg2Num}(${combo.steps2}) = ${combo.combinedScore.toFixed(1)} ${combo.hasCut ? 'âœ‚ï¸CUT!' : ''}`);
        });
        
        return splitCombinations[0];
    }
    
    /**
     * Execute AI 7-card split move
     * Handles the complete split sequence: first move, then second move
     */
    function aiExecute7CardSplit() {
        const player = gameState.currentPlayer;
        const playerIdx = gameState.currentPlayerIndex;
        let bestSplit = null;

        // â”€â”€ ManifoldAI Path: Use geometric surface for split evaluation â”€â”€
        if (window.ManifoldAI && AI_CONFIG.useManifold) {
            const entity = ManifoldAI.getEntity(playerIdx);
            if (entity) {
                try {
                    const ruleEvaluators = getManifoldRuleEvaluators();
                    const gameHelpers = getManifoldGameHelpers();
                    bestSplit = ManifoldAI.evaluate7CardSplit(entity, player, ruleEvaluators, gameHelpers);
                } catch (err) {
                    console.error(`${entity.emoji} ManifoldAI 7-split error:`, err);
                }
            }
        }

        // Fallback to legacy evaluation
        if (!bestSplit) {
            bestSplit = aiEvaluate7CardSplit(player);
        }
        
        if (!bestSplit) {
            // No split found or only one peg - use normal full move
            console.log('ğŸ¤– [AI 7-Split] No split possible, using full move');
            return false;
        }
        
        console.log(`ğŸ¤– [AI 7-Split] Executing split: Peg#${getPegNumber(bestSplit.peg1.id)} moves ${bestSplit.steps1}, Peg#${getPegNumber(bestSplit.peg2.id)} moves ${bestSplit.steps2}`);
        
        // Execute first move using proper game state method (handles cuts, FastTrack, etc.)
        clearHighlights();
        
        const cutPeg1 = gameState.executeMoveWithoutEndingTurn ? 
            gameState.executeMoveWithoutEndingTurn(bestSplit.move1) : null;
        
        animatePegMove(bestSplit.move1, () => {
            // Animate cut if one occurred
            if (cutPeg1) {
                animateCut(cutPeg1);
            }
            
            // Small delay then execute second move
            setTimeout(() => {
                console.log(`ğŸ¤– [AI 7-Split] Executing second move...`);
                
                // RECALCULATE move2 from updated board state â€” peg1 has moved,
                // so peg2's path/destination may need updating.
                const peg2Live = player.peg.find(p => p.id === bestSplit.peg2.id);
                let move2 = bestSplit.move2;
                if (peg2Live) {
                    const freshDests = calculateMovesForPegRange(peg2Live, bestSplit.steps2, bestSplit.steps2);
                    if (freshDests.length > 0) {
                        // Prefer same destination if still valid, else best available
                        const sameDest = freshDests.find(m => m.toHoleId === bestSplit.move2.toHoleId);
                        move2 = sameDest || freshDests[0];
                        console.log(`ğŸ¤– [AI 7-Split] Recalculated move2: ${move2.toHoleId} (was ${bestSplit.move2.toHoleId})`);
                    } else {
                        console.warn(`ğŸ¤– [AI 7-Split] No valid move2 after recalculation! Ending split.`);
                        cardUI.clearCard();
                        if (window.mobileUI) window.mobileUI.hideFloatingCard();
                        gameState.endTurn();
                        return;
                    }
                }
                
                const cutPeg2 = gameState.executeMoveWithoutEndingTurn ? 
                    gameState.executeMoveWithoutEndingTurn(move2) : null;
                
                animatePegMove(move2, () => {
                    // Animate cut if one occurred
                    if (cutPeg2) {
                        animateCut(cutPeg2);
                    }
                    
                    // 7 card doesn't give extra turn - advance to next player
                    setTimeout(() => {
                        cardUI.clearCard();
                        if (window.mobileUI) window.mobileUI.hideFloatingCard();
                        gameState.endTurn();
                    }, 500);
                });
            }, 600);
        });
        
        return true;
    }
    
    // ============================================================
    // GAME SESSION MANAGEMENT
    // ============================================================
    
    let boardReady = false;
    
    function updateLoadingStatus(message, isReady = false) {
        const statusEl = document.getElementById('loading-status');
        const startBtn = document.getElementById('start-btn');
        if (statusEl) {
            statusEl.textContent = message;
            if (isReady) {
                statusEl.classList.add('ready');
            }
        }
        if (startBtn) {
            startBtn.disabled = !isReady;
            startBtn.style.opacity = isReady ? '1' : '0.5';
            startBtn.style.cursor = isReady ? 'pointer' : 'not-allowed';
        }
    }
    
    function startGameSession() {
        if (!boardReady) {
            console.log('Board not ready yet');
            return;
        }
        
        console.log('Starting game session...');
        console.log('Available globals:', {
            GameUIMinimal: typeof window.GameUIMinimal,
            CardUI: typeof window.CardUI,
            FastrackEngine: typeof window.FastrackEngine
        });
        
        // Hide start screen IMMEDIATELY
        const startScreen = document.getElementById('start-game-screen');
        if (startScreen) {
            console.log('Hiding start screen...');
            startScreen.style.display = 'none';
            startScreen.remove(); // Also remove from DOM entirely
            console.log('Start screen removed from DOM');
        }
        
        // Show leave game button (always visible during game)
        const leaveBtn = document.getElementById('leave-game-btn');
        if (leaveBtn) {
            leaveBtn.style.display = 'flex';
        }
        
        // Hide auth/lobby containers
        document.getElementById('auth-container').style.display = 'none';
        document.getElementById('lobby-container').style.display = 'none';
        
        // Read player count from URL params (from ai_setup.html), default to 3
        const sessionParams = new URLSearchParams(window.location.search);
        const requestedPlayers = parseInt(sessionParams.get('players')) || 3;
        const playerCount = Math.max(2, Math.min(4, requestedPlayers)); // Clamp 2-4
        const playerName = sessionParams.get('name') || 'You';
        // Decode avatar (it's URL encoded like %F0%9F%8E%AE)
        const playerAvatar = decodeURIComponent(sessionParams.get('avatar') || 'ğŸ®');
        const difficulty = sessionParams.get('difficulty') || 'normal';
        
        console.log(`[startGameSession] URL params: players=${requestedPlayers}, name=${playerName}, avatar=${playerAvatar}, difficulty=${difficulty}`);
        console.log(`[startGameSession] Final playerCount after clamping: ${playerCount}`);
        console.log(`[startGameSession] gameState.players before config:`, gameState?.players?.map(p => p.name));
        
        // Initialize game with requested player count
        console.log(`[startGameSession] Calling initGame(${playerCount})...`);
        initGame(playerCount);

        // â”€â”€ Analytics: Track game start â”€â”€
        if (window.FTAnalytics) {
            FTAnalytics.gameStart(currentGameMode, playerCount, difficulty);
        }
        console.log('[startGameSession] initGame complete, gameState:', !!gameState, 'currentPlayerIndex:', gameState?.currentPlayerIndex);
        console.log('[startGameSession] gameState.players.length:', gameState?.players?.length);
        console.log('[startGameSession] cardUI:', !!cardUI);
        
        // AI bot identities â€” pick from BoardManifold tech/sci-fi pool
        let botPool;
        if (window.BoardManifold) {
            const bots = BoardManifold.pickBots(5);
            botPool = bots.map(b => ({ name: b.name, avatar: b.icon, personality: b.name.toLowerCase() }));
            console.log('[startGameSession] Bot pool from BoardManifold:', botPool.map(b => b.name));
        } else if (window.ManifoldAI) {
            botPool = window.ManifoldAI.ARCHETYPE_POOL.map(key => {
                const arch = window.ManifoldAI.ARCHETYPES[key];
                return { name: arch.name, avatar: arch.emoji, personality: key };
            });
        } else {
            botPool = [
                { name: 'Turing', avatar: 'ğŸ–¥ï¸', personality: 'turing' },
                { name: 'Nexus', avatar: 'ğŸŒ', personality: 'nexus' },
                { name: 'Cortex', avatar: 'ğŸ§ ', personality: 'cortex' },
            ];
        }
        
        // Configure players
        if (gameState) {
            console.log(`[startGameSession] Configuring ${playerCount} players...`);
            console.log(`[startGameSession] gameState.players.length = ${gameState.players.length}`);
            
            try {
                // Player 0 is always human - explicitly set all flags
                if (!gameState.players[0]) {
                    console.error('[startGameSession] ERROR: gameState.players[0] does not exist!');
                } else {
                    gameState.players[0].name = playerName;
                    gameState.players[0].avatar = playerAvatar;  // Store avatar separately
                    gameState.players[0].isHuman = true;
                    gameState.players[0].isLocal = true;
                    gameState.players[0].isAI = false;  // Explicitly NOT an AI
                    console.log(`[startGameSession] Player 0 configured: name="${playerName}", avatar="${playerAvatar}", isAI=false, isHuman=true`);
                }
            } catch (e) {
                console.error('[startGameSession] Error configuring player 0:', e);
            }
            
            // Configure AI players (1 through playerCount-1) from manifold archetypes
            const aiIndices = [];
            for (let i = 1; i < playerCount; i++) {
                if (gameState.players[i]) {
                    const bot = botPool[(i - 1) % botPool.length];
                    gameState.players[i].name = bot.name;
                    gameState.players[i].avatar = bot.avatar;
                    gameState.players[i].isAI = true;
                    gameState.players[i].isHuman = false;
                    gameState.players[i].isLocal = false;
                    gameState.players[i].personality = bot.personality;
                    aiIndices.push(i);
                    console.log(`[startGameSession] Player ${i} configured: name="${gameState.players[i].name}", isAI=true, personality=${bot.personality}`);
                } else {
                    console.warn(`[startGameSession] Player ${i} does not exist in gameState.players!`);
                }
            }
            
            // Store difficulty in AI config AND update AI player list
            if (window.AI_CONFIG) {
                window.AI_CONFIG.difficulty = difficulty;
                window.AI_CONFIG.players = aiIndices;
                window.AI_CONFIG.enabled = true;
                window.AI_CONFIG.useManifold = !!window.ManifoldAI;
                console.log(`[startGameSession] Updated AI_CONFIG.players to:`, window.AI_CONFIG.players);
            }
            
            // Spawn ManifoldAI entities on z=xy / z=xyÂ² geometric surfaces
            if (window.ManifoldAI && aiIndices.length > 0) {
                console.log('[startGameSession] Spawning ManifoldAI geometric entities...');
                window.ManifoldAI.spawnEntities(aiIndices, difficulty);
                aiIndices.forEach(idx => {
                    console.log(window.ManifoldAI.entitySummary(idx));
                });
            }
            
            console.log(`[startGameSession] Configured ${playerCount} players:`, 
                gameState.players.map(p => ({ name: p.name, isAI: p.isAI, isHuman: p.isHuman })));
            
            // Update card UI
            if (cardUI) {
                cardUI.updateCurrentPlayer(gameState.currentPlayer);
            }
            
            // IMPORTANT: Re-sync GameUIMinimal with updated player data
            if (window.GameUIMinimal) {
                console.log('[startGameSession] Re-syncing GameUIMinimal with updated player data');
                console.log('[startGameSession] Players to set:', JSON.stringify(gameState.players.map(p => ({
                    name: p.name, avatar: p.avatar, isAI: p.isAI, isHuman: p.isHuman
                }))));
                window.GameUIMinimal.setPlayers(gameState.players, gameState.currentPlayerIndex);
                window.GameUIMinimal.setCurrentPlayer(
                    gameState.currentPlayer, 
                    gameState.currentPlayerIndex
                );
                window.GameUIMinimal.setDeckCount(gameState.currentPlayer?.deck?.remaining || 54);
            }
            
            // Update player panels with names
            setTimeout(() => {
                const panels = document.querySelectorAll('.player-panel');
                panels.forEach((panel, idx) => {
                    const nameEl = panel.querySelector('.player-name');
                    if (nameEl && gameState.players[idx]) {
                        nameEl.textContent = gameState.players[idx].name;
                    }
                });
            }, 100);
            
            // Show Mom's introduction (if enabled and not hard mode)
            setTimeout(() => {
                try {
                    if (GAME_CONFIG.showMomIntro) {
                        showMomIntro();
                    }
                } catch (e) {
                    console.warn('[startGameSession] showMomIntro skipped due to error', e);
                }
            }, 500);
            
            console.log(`Game started! You are ${playerAvatar} ${playerName} (Player 1). Click the deck to draw.`);
        }
    }
    
    // Expose startGameSession globally for multiplayer integration
    window.startGameSession = startGameSession;
    
    // Toggle rules modal visibility
    function toggleRulesModal() {
        const modal = document.getElementById('rules-modal');
        if (modal) {
            modal.classList.toggle('visible');
        }
    }
    window.toggleRulesModal = toggleRulesModal;
    
    // ============================================================
    // EXIT GAME FUNCTIONALITY
    // ============================================================
    
    // Show exit confirmation modal
    function showExitConfirm() {
        const modal = document.getElementById('exit-confirm-modal');
        if (modal) {
            modal.classList.add('visible');
        }
    }
    window.showExitConfirm = showExitConfirm;
    
    // Hide exit confirmation modal
    function hideExitConfirm() {
        const modal = document.getElementById('exit-confirm-modal');
        if (modal) {
            modal.classList.remove('visible');
        }
    }
    window.hideExitConfirm = hideExitConfirm;
    
    // Exit to lobby (disconnect from session and go to lobby)
    function exitToLobby() {
        hideExitConfirm();
        
        // Disconnect from multiplayer session if connected
        if (window.multiplayerClient && typeof multiplayerClient.isConnected === "function" && multiplayerClient.isConnected()) {
            multiplayerClient.disconnect();
        }
        
        // Sync prestige points before leaving
        if (window.PrestigeTracker) {
            PrestigeTracker.syncWithServer();
        }
        
        // Navigate to lobby
        window.location.href = 'lobby.html';
    }
    window.exitToLobby = exitToLobby;
    
    // Convert current player to AI and exit game
    function confirmExitGame() {
        hideExitConfirm();
        
        if (!gameState) {
            // No game in progress, just go back
            window.location.href = 'index.html';
            return;
        }
        
        // Find the human player (player 0 in single player, or identified multiplayer)
        const humanPlayerIdx = isMultiplayer ? 
            gameState.players.findIndex(p => p.id === myPlayerId) : 
            0; // In single player, human is always player 0
        
        if (humanPlayerIdx >= 0) {
            const player = gameState.players[humanPlayerIdx];
            console.log(`[ExitGame] Converting player ${humanPlayerIdx} (${player.name}) to AI`);
            
            // Mark this player as AI
            player.isAI = true;
            player.wasHuman = true; // Track that they were originally human
            player.name = player.name + ' (AI)';
            
            // Update player panels to show AI badge
            if (window.playerPanelUI) {
                const panelId = `player_${humanPlayerIdx}`;
                const panel = document.getElementById(panelId);
                if (panel) {
                    const nameEl = panel.querySelector('.player-name');
                    if (nameEl && !nameEl.textContent.includes('(AI)')) {
                        nameEl.textContent = player.name;
                    }
                }
            }
            
            // Show notification
            showExitNotification(player.name);
            
            // Count remaining human players
            const remainingHumans = gameState.players.filter(p => !p.isAI).length;
            console.log(`[ExitGame] Remaining human players: ${remainingHumans}`);
            
            if (remainingHumans === 0 || !isMultiplayer) {
                // All players are now AI OR single player exited - go back to menu
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 2000);
            } else {
                // ğŸŒŠ DIMENSIONAL: Manifest AI action based on phase (no if-else needed)
                const isHumanTurn = gameState.currentPlayerIndex === humanPlayerIdx;
                isHumanTurn && ObservationSubstrate.after(
                    () => IntentManifold.invokePhase('ai'),
                    1000
                );
            }
        } else {
            // No player found, just go back
            window.location.href = 'index.html';
        }
    }
    window.confirmExitGame = confirmExitGame;
    
    // Show notification that player left
    function showExitNotification(playerName) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(100,100,100,0.95), rgba(60,60,60,0.95));
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            padding: 30px 50px;
            text-align: center;
            z-index: 30000;
            animation: fadeInOut 3s ease-in-out forwards;
        `;
        notification.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 10px;">ğŸšª</div>
            <div style="font-size: 1.3em; color: #fff; font-weight: bold;">${playerName} left the game</div>
            <div style="font-size: 0.9em; color: #aaa; margin-top: 8px;">AI is now playing</div>
        `;
        
        // Add animation keyframes
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                15% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
            style.remove();
        }, 3000);
    }
    
    // Show leave game button when game is active
    function showExitButton() {
        const btn = document.getElementById('leave-game-btn');
        if (btn) btn.style.display = 'flex';
    }
    window.showExitButton = showExitButton;

    // Hide leave game button
    function hideExitButton() {
        const btn = document.getElementById('leave-game-btn');
        if (btn) btn.style.display = 'none';
    }
    window.hideExitButton = hideExitButton;

    // ğŸŒŠ DIMENSIONAL: Observe board manifestation (replaces polling loop)
    // ğŸ› TEMPORARY: Using setTimeout for debugging
    setTimeout(() => updateLoadingStatus('Initializing board...'), 100);

    // ğŸ› TEMPORARY: Using setInterval for debugging
    const boardReadyCheck = setInterval(() => {
        const hr = window.holeRegistry || holeRegistry;
        if (hr && hr.size > 0) {
            clearInterval(boardReadyCheck);
            boardReady = true;
            window.boardReady = true;
            updateLoadingStatus('âœ“ Board ready! Click START GAME', true);
            console.log('Board initialized with', hr.size, 'holes');

            // Seal every hole onto the z=xy / z=xyÂ² manifold surface
            window.BoardManifold?.sealBoard?.(hr);
            window.BoardManifold && console.log('[BoardManifold] Hole truth table:',
                JSON.stringify(BoardManifold.holeTruthTable()));
        }
    }, 100);

    // Observe timeout condition
    setTimeout(() => {
        if (!boardReady) {
            updateLoadingStatus('âš  Board loading taking long... please wait');
        }
    }, 10000);

    // ğŸŒŠ DIMENSIONAL: Observe script loading (replaces setTimeout debug)
    ObservationSubstrate.after(() => {
        console.log('=== SCRIPT LOAD CHECK ===');
        console.log('GameUIMinimal:', typeof window.GameUIMinimal);
        console.log('CardUI:', typeof window.CardUI);
        console.log('FastrackEngine:', typeof window.FastrackEngine);
        console.log('AvatarSubstrate:', typeof window.AvatarSubstrate);
        console.log('MoodSubstrate:', typeof window.MoodSubstrate);
        console.log('FastTrackThemes:', typeof window.FastTrackThemes);
        console.log('=========================');
    }, 1000);
    
    // ============================================================
    // RESPONSIVE & MOBILE ENHANCEMENTS
    // Touch controls, device adaptation, and 3D camera helpers
    // ============================================================
    
    (function() {
        'use strict';
        
        // Device detection
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isTablet = /iPad|Android/i.test(navigator.userAgent) && window.innerWidth >= 768;
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const hasGyroscope = 'DeviceOrientationEvent' in window;
        
        // Add device classes to body
        document.body.classList.add(isMobile ? 'device-mobile' : 'device-desktop');
        if (isTablet) document.body.classList.add('device-tablet');
        if (hasTouch) document.body.classList.add('touch-device');
        
        // Responsive camera adjustments
        function updateCameraForDevice() {
            if (!camera || !controls) return;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;
            
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            
            if (renderer) {
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }
            
            // Adjust camera position for device type
            if (isMobile && !isTablet) {
                // Mobile: Higher, more top-down for board visibility, still 30Â°-ish
                if (controls.target) {
                    camera.position.set(0, 350, 500);
                    controls.maxDistance = 800;
                    controls.minDistance = 200;
                }
            } else if (isTablet) {
                // Tablet: 30Â° angle
                camera.position.set(0, 320, 554);
                controls.maxDistance = 900;
                controls.minDistance = 250;
            }
            // Desktop uses default 30Â° settings
        }
        
        // Touch gesture enhancements for OrbitControls
        function enhanceTouchControls() {
            if (!controls || !hasTouch) return;
            
            // Enable touch rotation and zoom
            controls.enableRotate = true;
            controls.enableZoom = true;
            controls.enablePan = true;
            
            // Touch-friendly settings
            controls.rotateSpeed = 0.5;
            controls.zoomSpeed = 0.8;
            controls.panSpeed = 0.5;
            
            // Damping for smooth movement
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            // Limit angles for better UX
            controls.maxPolarAngle = Math.PI / 2.2; // Don't go below board
            controls.minPolarAngle = 0.2; // Don't go fully top-down
        }
        
        // Create mobile touch control buttons
        function createTouchControls() {
            if (!hasTouch) return;
            
            const touchControls = document.createElement('div');
            touchControls.className = 'touch-controls';
            touchControls.innerHTML = `
                <button class="touch-btn" id="btn-zoom-in" aria-label="Zoom In">ğŸ”+</button>
                <button class="touch-btn" id="btn-zoom-out" aria-label="Zoom Out">ğŸ”âˆ’</button>
                <button class="touch-btn" id="btn-reset-view" aria-label="Reset View">ğŸ¯</button>
            `;
            document.body.appendChild(touchControls);
            
            // Zoom in
            document.getElementById('btn-zoom-in')?.addEventListener('click', () => {
                if (camera) {
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    camera.position.addScaledVector(direction, 50);
                }
            });
            
            // Zoom out
            document.getElementById('btn-zoom-out')?.addEventListener('click', () => {
                if (camera) {
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    camera.position.addScaledVector(direction, -50);
                }
            });
            
            // Reset view
            document.getElementById('btn-reset-view')?.addEventListener('click', () => {
                setCameraView('angle');
            });
        }
        
        // Double-tap to zoom (mobile)
        function enableDoubleTapZoom() {
            if (!hasTouch) return;
            
            let lastTap = 0;
            const container = document.getElementById('container');
            
            container?.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTap < 300) {
                    // Double tap detected
                    e.preventDefault();
                    
                    // Toggle between close and default view
                    if (camera && camera.position.y < 400) {
                        setCameraView('angle');
                    } else {
                        // Zoom to tap location
                        const touch = e.changedTouches[0];
                        // Simple zoom in
                        if (camera) {
                            const direction = new THREE.Vector3();
                            camera.getWorldDirection(direction);
                            camera.position.addScaledVector(direction, 100);
                        }
                    }
                }
                lastTap = now;
            }, { passive: false });
        }
        
        // Gyroscope subtle parallax effect
        function enableGyroscopeParallax() {
            if (!hasGyroscope || !isMobile) return;
            
            // Request permission on iOS 13+
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // Will be triggered on first touch
                document.body.addEventListener('touchstart', function requestGyro() {
                    DeviceOrientationEvent.requestPermission()
                        .then(permission => {
                            if (permission === 'granted') {
                                addGyroListener();
                            }
                        })
                        .catch(console.warn);
                    document.body.removeEventListener('touchstart', requestGyro);
                }, { once: true });
            } else {
                addGyroListener();
            }
            
            function addGyroListener() {
                let lastGamma = 0, lastBeta = 0;
                
                window.addEventListener('deviceorientation', (e) => {
                    if (!camera || !controls) return;
                    
                    // Subtle camera adjustment based on device tilt
                    const gamma = e.gamma || 0; // Left/right tilt (-90 to 90)
                    const beta = e.beta || 0;   // Front/back tilt (-180 to 180)
                    
                    // Apply smooth interpolation
                    lastGamma += (gamma - lastGamma) * 0.05;
                    lastBeta += (beta - lastBeta) * 0.05;
                    
                    // Very subtle rotation effect (disabled during active touch)
                    if (!controls.enabled) return;
                    
                    // This creates a subtle "looking around" effect
                    // Uncomment to enable:
                    // controls.target.x = lastGamma * 0.5;
                    // controls.target.z = (lastBeta - 45) * 0.3;
                }, { passive: true });
            }
        }
        
        // Handle orientation changes
        function handleOrientationChange() {
            window.addEventListener('orientationchange', () => {
                setTimeout(updateCameraForDevice, 100);
            });
            
            // Also handle resize for desktop browsers
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(updateCameraForDevice, 100);
            });
        }
        
        // Prevent pull-to-refresh on mobile
        function preventPullToRefresh() {
            document.body.addEventListener('touchmove', (e) => {
                if (e.target.closest('#container')) {
                    // Allow if it's the game canvas
                    return;
                }
                // Prevent default if at top of page
                if (window.scrollY === 0 && e.touches[0].clientY > 0) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // Initialize all mobile enhancements
        function initMobileEnhancements() {
            updateCameraForDevice();
            enhanceTouchControls();
            createTouchControls();
            enableDoubleTapZoom();
            enableGyroscopeParallax();
            handleOrientationChange();
            preventPullToRefresh();
            
            console.log('ğŸ“± Mobile enhancements initialized:', {
                isMobile,
                isTablet,
                hasTouch,
                hasGyroscope
            });
        }
        
        // Wait for Three.js to be ready
        if (typeof THREE !== 'undefined') {
            // Scene might not be ready yet, wait for it
            const checkReady = setInterval(() => {
                if (typeof camera !== 'undefined' && typeof controls !== 'undefined') {
                    clearInterval(checkReady);
                    initMobileEnhancements();
                }
            }, 100);
            
            // Timeout after 5 seconds
            setTimeout(() => clearInterval(checkReady), 5000);
        }
    })();
    </script>
    
    <!-- ============================================================ -->
    <!-- BETA SESSION WEBSOCKET INTEGRATION                           -->
    <!-- ============================================================ -->
    <script>
    (function() {
        'use strict';
        
        // Session state
        let sessionData = null;
        let myPlayerId = null;
        let ws = null;
        let isMultiplayer = false;
        
        // Listen for messages from parent window (index.html iframe integration)
        window.addEventListener('message', (event) => {
            const data = event.data;
            
            if (data.type === 'initGame') {
                console.log('Received session data from parent:', data);
                sessionData = data.session;
                myPlayerId = data.playerId;
                isMultiplayer = true;
                
                // Connect to WebSocket
                connectToSession(data.wsUrl, sessionData.code);
                
                // Start the game with session players
                initMultiplayerGame();
            }
        });
        
        // Check URL params for direct game access
        const urlParams = new URLSearchParams(window.location.search);
        const sessionCode = urlParams.get('session') || urlParams.get('code');
        const playerId = urlParams.get('player');
        const debugMode = urlParams.get('debug') === '1' || urlParams.get('debug') === 'true';
        const quickplayMode = urlParams.get('quickplay') === '1' || urlParams.get('quickply') === '1';
        
        // Dimensional mode manifold â€” only observed modes manifest
        const modeManifold = {
            quickplay: quickplayMode && !sessionCode && !debugMode,
            debug: debugMode && !sessionCode,
            session: sessionCode && (playerId || urlParams.get('multiplayer') === 'true'),
            default: true // Always exists as potential
        };
        
        // Observation-based manifestation â€” no if-else branching
        const observedMode = Object.keys(modeManifold).find(key => modeManifold[key]);
        
        console.log(`[DIMENSIONAL] Observed mode: ${observedMode}`);
        
        // Each mode is a self-invoking manifold
        const modeInvocations = {
            quickplay: () => {
                console.log('[QUICKPLAY] Manifesting from observation...');
                const startScreen = document.getElementById('start-game-screen');
                if (startScreen) startScreen.style.display = 'none';
                
                if (window.GameInit) {
                    window.GameInit.waitAndStart(10000);
                } else {
                    let waitAttempts = 0;
                    const waitForGameInit = setInterval(() => {
                        waitAttempts++;
                        if (window.GameInit) {
                            clearInterval(waitForGameInit);
                            window.GameInit.waitAndStart(10000);
                        } else if (waitAttempts >= 50) {
                            clearInterval(waitForGameInit);
                            console.error('GameInit not ready after 5 seconds');
                        }
                    }, 100);
                }
            },
            
            debug: () => {
                console.log('[DEBUG] Manifesting from observation...');
                const startScreen = document.getElementById('start-game-screen');
                if (startScreen) startScreen.style.display = 'none';
                
                // Show debug overlay
                const debugOverlay = document.createElement('div');
                debugOverlay.id = 'debug-overlay';
                debugOverlay.innerHTML = `
                    <div style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px; font-family: monospace; z-index: 10000;">
                        <div>DEBUG MODE</div>
                        <div id="debug-info"></div>
                    </div>
                `;
                document.body.appendChild(debugOverlay);
                
                let debugAttempts = 0;
                const waitForDebugReady = setInterval(() => {
                    debugAttempts++;
                    const hr = window.holeRegistry;
                    const holeCount = hr ? hr.size : 0;
                    if (holeCount > 0 && !window.boardReady) {
                        window.boardReady = true;
                        document.getElementById('debug-info').innerHTML = `Board ready: ${holeCount} holes`;
                    }
                    
                    if (window.GameInit && window.GameInit.isReady()) {
                        clearInterval(waitForDebugReady);
                        window.GameInit.startGame(3);
                    } else if (debugAttempts >= 100) {
                        clearInterval(waitForDebugReady);
                        console.error('Debug mode timeout');
                    }
                }, 100);
            },
            
            session: () => {
                console.log('[SESSION] Manifesting from observation...');
                const startScreen = document.getElementById('start-game-screen');
                if (startScreen) startScreen.style.display = 'none';
                
                // Session data handling manifests from observation
                let storedSession = null;
                try {
                    const stored = sessionStorage.getItem('fasttrack_session');
                    if (stored) {
                        storedSession = JSON.parse(stored);
                        sessionStorage.removeItem('fasttrack_session');
                    }
                } catch (e) {
                    console.warn('Could not read session from storage:', e);
                }
                
                isMultiplayer = true;
                
                if (storedSession) {
                    sessionData = storedSession;
                    myPlayerId = playerId || sessionData.playerId;
                    
                    let attempts = 0;
                    const maxAttempts = 100;
                    const waitForBoard = setInterval(() => {
                        attempts++;
                        const hr = window.holeRegistry;
                        const isReady = window.boardReady || (hr && hr.size > 0);
                        
                        if (isReady || attempts >= maxAttempts) {
                            clearInterval(waitForBoard);
                            
                            if (sessionData && sessionData.players && sessionData.players.length > 0) {
                                initMultiplayerGame();
                            } else if (typeof window.initGame === 'function') {
                                window.initGame(3);
                            }
                        }
                    }, 100);
                }
            },
            
            default: () => {
                console.log('[DEFAULT] Manifesting from observation...');
                const startScreen = document.getElementById('start-game-screen');
                if (startScreen) startScreen.style.display = 'none';
                
                let attempts = 0;
                const waitForBoard = setInterval(() => {
                    attempts++;
                    const hr = window.holeRegistry;
                    const isReady = window.boardReady || (hr && hr.size > 0);
                    
                    if (isReady) {
                        clearInterval(waitForBoard);
                        window.boardReady = true;
                        
                        if (typeof window.initGame === 'function') {
                            window.initGame(3);
                        } else if (window.GameInit) {
                            window.GameInit.waitAndStart(5000);
                        }
                    } else if (attempts >= 50) {
                        clearInterval(waitForBoard);
                        console.error('Default mode timeout waiting for board');
                    }
                }, 100);
            }
        };
        
        // The observed mode manifests â€” no branching, no conditions
        modeInvocations[observedMode]?.();
        
        function connectToSession(wsUrl, code) {
            console.log(`Connecting to session ${code} at ${wsUrl}...`);
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('WebSocket connected for game session');
                
                // Request current session state
                ws.send(JSON.stringify({
                    type: 'getSession',
                    code: code
                }));
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleGameMessage(data);
            };
            
            ws.onerror = (error) => {
                console.error('Game WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('Game WebSocket closed');
                // Try to reconnect
                setTimeout(() => {
                    if (isMultiplayer && sessionData) {
                        connectToSession(wsUrl, sessionData.code);
                    }
                }, 3000);
            };
        }
        
        function handleGameMessage(data) {
            console.log('Game message:', data);
            
            switch (data.type) {
                case 'sessionState':
                    sessionData = data.session;
                    if (sessionData.phase === 'playing') {
                        initMultiplayerGame();
                    }
                    break;
                    
                case 'gameStarted':
                    sessionData = data.session;
                    initMultiplayerGame();
                    break;
                    
                case 'playCard':
                    // Another player played a card
                    if (data.data.playerId !== myPlayerId) {
                        handleRemoteCardPlay(data.data);
                    }
                    break;
                    
                case 'movePeg':
                    // Another player moved a peg
                    if (data.data.playerId !== myPlayerId) {
                        handleRemotePegMove(data.data);
                    }
                    break;
                    
                case 'drawCard':
                    // Another player drew a card
                    if (data.data.playerId !== myPlayerId) {
                        handleRemoteCardDraw(data.data);
                    }
                    break;
                    
                case 'endTurn':
                    // Turn ended
                    handleTurnEnd(data.data);
                    break;
                    
                case 'chat':
                    showChatMessage(data.username, data.message, data.avatarId);
                    break;
                    
                case 'playerLeft':
                    showNotification(`Player left the game`);
                    break;
            }
        }
        
        // Guard against multiple initMultiplayerGame calls
        let multiplayerGameInitPending = false;
        let multiplayerGameInitComplete = false;
        
        function initMultiplayerGame() {
            // Prevent duplicate initialization
            if (multiplayerGameInitComplete) {
                console.log('[initMultiplayerGame] Already initialized, skipping');
                return;
            }
            if (multiplayerGameInitPending) {
                console.log('[initMultiplayerGame] Init already pending, skipping');
                return;
            }
            multiplayerGameInitPending = true;
            
            console.log('[initMultiplayerGame] Called with sessionData:', sessionData);
            
            // Hide start screen first
            const startScreen = document.getElementById('start-game-screen');
            if (startScreen) {
                startScreen.style.display = 'none';
                startScreen.remove();
            }
            
            // Hide auth/lobby containers
            const authContainer = document.getElementById('auth-container');
            const lobbyContainer = document.getElementById('lobby-container');
            if (authContainer) authContainer.style.display = 'none';
            if (lobbyContainer) lobbyContainer.style.display = 'none';
            
            // Determine player count from session
            const playerCount = sessionData && sessionData.players ? sessionData.players.length : 3;
            console.log('[initMultiplayerGame] Player count from session:', playerCount);
            
            // Wait for boardReady flag (set by the board init code)
            const waitForReady = setInterval(() => {
                const hr = window.holeRegistry;
                const isReady = window.boardReady || (hr && hr.size > 0);
                
                if (isReady) {
                    clearInterval(waitForReady);
                    window.boardReady = true;
                    
                    console.log('[initMultiplayerGame] Board ready, initializing game with', playerCount, 'players');

                    // Show leave game button
                    const leaveBtn = document.getElementById('leave-game-btn');
                    if (leaveBtn) leaveBtn.style.display = 'flex';

                    // Initialize game with correct player count from session
                    if (typeof window.initGame === 'function') {
                        window.initGame(playerCount);
                        multiplayerGameInitComplete = true;
                        console.log('[initMultiplayerGame] Game initialized with', playerCount, 'players - marking as complete');
                        
                        // After game starts, update player names and types from session data
                        setTimeout(() => {
                            if (sessionData && sessionData.players && window.gameState) {
                                console.log('[initMultiplayerGame] Session players:', sessionData.players);
                                console.log('[initMultiplayerGame] myPlayerId:', myPlayerId);
                                
                                sessionData.players.forEach((sessionPlayer, idx) => {
                                    if (window.gameState.players[idx]) {
                                        window.gameState.players[idx].name = sessionPlayer.username;
                                        window.gameState.players[idx].isHuman = sessionPlayer.playerType === 'human';
                                        window.gameState.players[idx].isAI = sessionPlayer.playerType === 'ai';
                                        window.gameState.players[idx].sessionId = sessionPlayer.id;
                                        
                                        // Mark the local player - MUST set isAI to false!
                                        if (sessionPlayer.id === myPlayerId) {
                                            window.gameState.players[idx].isLocal = true;
                                            window.gameState.players[idx].isHuman = true;
                                            window.gameState.players[idx].isAI = false;  // Explicitly NOT AI
                                            console.log('[initMultiplayerGame] LOCAL PLAYER found at index', idx, ':', sessionPlayer.username);
                                        }
                                    }
                                });
                                
                                // Update panels with correct names
                                updatePlayerPanelsFromSession();
                                
                                // Update card UI
                                if (window.cardUI) {
                                    window.cardUI.updateCurrentPlayer(window.gameState.currentPlayer);
                                }
                                
                                console.log('[initMultiplayerGame] Players configured:', 
                                    window.gameState.players.map(p => ({ name: p.name, isAI: p.isAI, isLocal: p.isLocal })));
                            }
                        }, 300);
                    } else {
                        console.error('[initMultiplayerGame] window.initGame not found!');
                    }
                }
            }, 100);
            
            // Timeout after 10 seconds
            setTimeout(() => clearInterval(waitForReady), 10000);
        }
        
        function updatePlayerPanelsFromSession() {
            if (!sessionData) return;
            
            setTimeout(() => {
                const panels = document.querySelectorAll('.player-panel');
                panels.forEach((panel, idx) => {
                    const player = sessionData.players[idx];
                    if (!player) return;
                    
                    const nameEl = panel.querySelector('.player-name');
                    if (nameEl) {
                        let nameText = player.username;
                        if (player.id === myPlayerId) {
                            nameText += ' (You)';
                        }
                        if (player.playerType === 'ai') {
                            nameText += ' ğŸ¤–';
                        }
                        nameEl.textContent = nameText;
                    }
                    
                    // Add avatar to panel if not already there
                    const existingAvatar = panel.querySelector('.session-avatar');
                    if (!existingAvatar) {
                        const avatarEl = document.createElement('div');
                        avatarEl.className = 'session-avatar';
                        avatarEl.style.cssText = 'font-size: 24px; text-align: center; margin-bottom: 5px;';
                        
                        if (player.avatarUrl) {
                            avatarEl.innerHTML = `<img src="${player.avatarUrl}" style="width:30px;height:30px;border-radius:50%;">`;
                        } else {
                            avatarEl.textContent = player.avatarId || 'ğŸ‘¤';
                        }
                        
                        panel.insertBefore(avatarEl, panel.firstChild);
                    }
                });
            }, 200);
        }
        
        // Send game actions to server
        window.sendGameAction = function(actionType, actionData) {
            if (!isMultiplayer || !ws || ws.readyState !== WebSocket.OPEN) {
                return false;
            }
            
            ws.send(JSON.stringify({
                type: actionType,
                code: sessionData.code,
                playerId: myPlayerId,
                ...actionData
            }));
            
            return true;
        };
        
        // Check if it's local player's turn
        window.isMyTurn = function() {
            if (!isMultiplayer) return true; // Solo mode
            if (!gameState || !sessionData) return false;
            
            const currentPlayer = gameState.players[gameState.currentPlayer];
            return currentPlayer && currentPlayer.sessionId === myPlayerId;
        };
        
        // Handle remote card play
        function handleRemoteCardPlay(data) {
            console.log('Remote player played card:', data);
            // TODO: Animate the card play
            if (typeof updateGameState === 'function') {
                // Update will come from server
            }
        }
        
        // Handle remote peg move
        function handleRemotePegMove(data) {
            console.log('Remote player moved peg:', data);
            // TODO: Animate the peg movement
            if (typeof animatePegMove === 'function') {
                // animatePegMove(data.pegId, data.fromHole, data.toHole);
            }
        }
        
        // Handle remote card draw
        function handleRemoteCardDraw(data) {
            console.log('Remote player drew card:', data);
            // Visual feedback that another player drew
        }
        
        // Handle turn end
        function handleTurnEnd(data) {
            console.log('Turn ended:', data);
            if (typeof gameState !== 'undefined') {
                gameState.currentPlayer = data.nextPlayerIndex || 0;
                
                // Update UI
                if (typeof cardUI !== 'undefined' && cardUI) {
                    cardUI.updateCurrentPlayer(gameState.currentPlayer);
                }
                
                // Check if it's now my turn
                if (window.isMyTurn()) {
                    showNotification("Your turn!");
                }
            }
        }
        
        // Show notification
        function showNotification(message) {
            // Use existing notification system or create simple one
            console.log('NOTIFICATION:', message);
            
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(74, 222, 128, 0.9);
                color: #000;
                padding: 15px 30px;
                border-radius: 10px;
                font-weight: bold;
                z-index: 30020;
                animation: slideDown 0.3s ease;
            `;
            notif.textContent = message;
            document.body.appendChild(notif);
            
            setTimeout(() => notif.remove(), 3000);
        }
        
        // Show chat message
        function showChatMessage(username, message, avatarId) {
            console.log(`[CHAT] ${avatarId} ${username}: ${message}`);
            // TODO: Add chat UI to game board
        }
        
        // Expose for debugging
        window.betaSession = {
            get data() { return sessionData; },
            get playerId() { return myPlayerId; },
            get isMultiplayer() { return isMultiplayer; },
            get ws() { return ws; }
        };
        
        console.log('Beta session integration loaded');
    })();
    </script>
</body>
</html>

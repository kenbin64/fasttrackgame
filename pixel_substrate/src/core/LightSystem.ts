/**
 * LightSystem - Light Interaction for Pixels
 * 
 * Defines how pixels interact with light.
 * This REPLACES traditional shaders with physical light simulation.
 * 
 * Light interaction modes:
 * - ABSORB: Light energy is absorbed (converted to heat)
 * - REFLECT: Light bounces off surface
 * - REFRACT: Light bends when passing through
 * - SCATTER: Light spreads in multiple directions
 * - EMIT: Pixel generates light
 * 
 * Philosophy:
 * - Light is NOT just a color value
 * - Light is ENERGY with wavelength, direction, and intensity
 * - Pixels compute their own light interaction
 * - No global shader programs - each pixel is autonomous
 */

import { MaterialProperties, Spectrum } from './MaterialSystem';

/**
 * Light ray
 * Represents incoming or outgoing light
 */
export interface LightRay {
  /**
   * Direction vector (normalized)
   */
  direction: [number, number, number];
  
  /**
   * Wavelength (nanometers)
   * - 380-450: Violet/Blue
   * - 450-495: Blue
   * - 495-570: Green
   * - 570-590: Yellow
   * - 590-620: Orange
   * - 620-750: Red
   */
  wavelength: number;
  
  /**
   * Intensity [0-1]
   */
  intensity: number;
  
  /**
   * Polarization (optional)
   */
  polarization?: [number, number, number];
}

/**
 * Light interaction state
 * 
 * Stores all light-related data for a pixel
 */
export interface LightInteraction {
  // ========================================
  // INCOMING LIGHT
  // ========================================
  
  /**
   * All incoming light rays
   * Updated each frame by light sources and reflections
   */
  incomingLight: LightRay[];
  
  // ========================================
  // OUTGOING LIGHT
  // ========================================
  
  /**
   * Reflected light rays
   * Computed from incoming light + material properties
   */
  reflectedLight: LightRay[];
  
  /**
   * Refracted light rays
   * Light that passed through the pixel
   */
  refractedLight: LightRay[];
  
  /**
   * Scattered light rays
   * Light that scattered in random directions
   */
  scatteredLight: LightRay[];
  
  /**
   * Emitted light rays
   * Light generated by this pixel (if it's an emitter)
   */
  emittedLight: LightRay[];
  
  // ========================================
  // COMPUTED VALUES
  // ========================================
  
  /**
   * Total absorbed energy
   * Sum of all absorbed light (converted to heat)
   */
  absorbedEnergy: number;
  
  /**
   * Final color [R, G, B, A]
   * Computed from reflected + emitted light
   */
  finalColor: [number, number, number, number];
}

/**
 * Create default light interaction
 */
export function createDefaultLightInteraction(): LightInteraction {
  return {
    incomingLight: [],
    reflectedLight: [],
    refractedLight: [],
    scatteredLight: [],
    emittedLight: [],
    absorbedEnergy: 0,
    finalColor: [0, 0, 0, 1],
  };
}

/**
 * Absorb light based on material properties
 * 
 * @param incoming Incoming light ray
 * @param material Material properties
 * @returns Absorbed energy
 */
export function absorbLight(
  incoming: LightRay,
  material: MaterialProperties
): number {
  // Get absorption coefficient for this wavelength
  const absorption = material.absorptionSpectrum.get(incoming.wavelength) ?? 0.5;
  
  // Absorbed energy = intensity × absorption coefficient
  return incoming.intensity * absorption;
}

/**
 * Reflect light based on material properties
 * 
 * @param incoming Incoming light ray
 * @param normal Surface normal vector
 * @param material Material properties
 * @returns Reflected light ray (or null if fully absorbed)
 */
export function reflectLight(
  incoming: LightRay,
  normal: [number, number, number],
  material: MaterialProperties
): LightRay | null {
  // Get reflection coefficient for this wavelength
  const reflection = material.reflectionSpectrum.get(incoming.wavelength) ?? 0.5;
  
  // If no reflection, return null
  if (reflection === 0) return null;
  
  // Compute reflection direction: r = d - 2(d·n)n
  const [dx, dy, dz] = incoming.direction;
  const [nx, ny, nz] = normal;
  const dot = dx * nx + dy * ny + dz * nz;
  const reflectedDirection: [number, number, number] = [
    dx - 2 * dot * nx,
    dy - 2 * dot * ny,
    dz - 2 * dot * nz,
  ];
  
  return {
    direction: reflectedDirection,
    wavelength: incoming.wavelength,
    intensity: incoming.intensity * reflection,
  };
}

/**
 * Refract light based on material properties
 * 
 * @param incoming Incoming light ray
 * @param normal Surface normal vector
 * @param material Material properties
 * @param externalIndex Refractive index of external medium (default: air = 1.0)
 * @returns Refracted light ray (or null if total internal reflection)
 */
export function refractLight(
  incoming: LightRay,
  normal: [number, number, number],
  material: MaterialProperties,
  externalIndex: number = 1.0
): LightRay | null {
  // Snell's law: n1 * sin(θ1) = n2 * sin(θ2)
  const n1 = externalIndex;
  const n2 = material.refractiveIndex;
  const ratio = n1 / n2;
  
  const [dx, dy, dz] = incoming.direction;
  const [nx, ny, nz] = normal;
  const cosI = -(dx * nx + dy * ny + dz * nz);
  const sinT2 = ratio * ratio * (1.0 - cosI * cosI);
  
  // Total internal reflection
  if (sinT2 > 1.0) return null;
  
  const cosT = Math.sqrt(1.0 - sinT2);
  const refractedDirection: [number, number, number] = [
    ratio * dx + (ratio * cosI - cosT) * nx,
    ratio * dy + (ratio * cosI - cosT) * ny,
    ratio * dz + (ratio * cosI - cosT) * nz,
  ];
  
  // Intensity reduced by opacity
  const transmission = 1.0 - material.opacity;
  
  return {
    direction: refractedDirection,
    wavelength: incoming.wavelength,
    intensity: incoming.intensity * transmission,
  };
}

